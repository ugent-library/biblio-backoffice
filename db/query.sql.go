// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCandidateRecord = `-- name: AddCandidateRecord :one
INSERT INTO candidate_records (
  id, source_name, source_id, source_metadata, type, metadata, assigned_user_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT(source_name, source_id)
DO
  UPDATE SET source_metadata = EXCLUDED.source_metadata, type = EXCLUDED.type, metadata = EXCLUDED.metadata, assigned_user_id = EXCLUDED.assigned_user_id
RETURNING id
`

type AddCandidateRecordParams struct {
	ID             string
	SourceName     string
	SourceID       string
	SourceMetadata []byte
	Type           string
	Metadata       []byte
	AssignedUserID pgtype.Text
}

func (q *Queries) AddCandidateRecord(ctx context.Context, arg AddCandidateRecordParams) (string, error) {
	row := q.db.QueryRow(ctx, addCandidateRecord,
		arg.ID,
		arg.SourceName,
		arg.SourceID,
		arg.SourceMetadata,
		arg.Type,
		arg.Metadata,
		arg.AssignedUserID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getCandidateRecordsByUser = `-- name: GetCandidateRecordsByUser :many
SELECT id, source_name, source_id, source_metadata, type, metadata, assigned_user_id, date_created FROM candidate_records
WHERE assigned_user_id = $1
`

func (q *Queries) GetCandidateRecordsByUser(ctx context.Context, assignedUserID pgtype.Text) ([]CandidateRecord, error) {
	rows, err := q.db.Query(ctx, getCandidateRecordsByUser, assignedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CandidateRecord
	for rows.Next() {
		var i CandidateRecord
		if err := rows.Scan(
			&i.ID,
			&i.SourceName,
			&i.SourceID,
			&i.SourceMetadata,
			&i.Type,
			&i.Metadata,
			&i.AssignedUserID,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
