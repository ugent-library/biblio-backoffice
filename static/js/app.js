/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/app.js":
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ui_check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/check.js */ \"./assets/js/ui/check.js\");\n/* harmony import */ var _ui_bootstrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui/bootstrap.js */ \"./assets/js/ui/bootstrap.js\");\n/* harmony import */ var _ui_draggable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/draggable.js */ \"./assets/js/ui/draggable.js\");\n/* harmony import */ var _ui_multiple_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/multiple.js */ \"./assets/js/ui/multiple.js\");\n/* harmony import */ var _ui_form_change_submit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui/form_change_submit.js */ \"./assets/js/ui/form_change_submit.js\");\n/* harmony import */ var _ui_form_submit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/form_submit.js */ \"./assets/js/ui/form_submit.js\");\n/* harmony import */ var _ui_modal_close_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui/modal_close.js */ \"./assets/js/ui/modal_close.js\");\n/* harmony import */ var _ui_modal_popper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/modal_popper.js */ \"./assets/js/ui/modal_popper.js\");\n/* harmony import */ var _ui_multi_select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/multi_select.js */ \"./assets/js/ui/multi_select.js\");\n/* harmony import */ var _ui_tabs_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ui/tabs.js */ \"./assets/js/ui/tabs.js\");\n/* harmony import */ var _ui_radio_card_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/radio_card.js */ \"./assets/js/ui/radio_card.js\");\n/* harmony import */ var _ui_toast_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ui/toast.js */ \"./assets/js/ui/toast.js\");\n\n\n\n\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  (0,_ui_tabs_js__WEBPACK_IMPORTED_MODULE_9__.default)();\n  (0,_ui_check_js__WEBPACK_IMPORTED_MODULE_0__.default)();\n  (0,_ui_bootstrap_js__WEBPACK_IMPORTED_MODULE_1__.default)();\n  (0,_ui_draggable_js__WEBPACK_IMPORTED_MODULE_2__.draggable)();\n  (0,_ui_multiple_js__WEBPACK_IMPORTED_MODULE_3__.default)();\n  (0,_ui_form_change_submit_js__WEBPACK_IMPORTED_MODULE_4__.default)();\n  (0,_ui_form_submit_js__WEBPACK_IMPORTED_MODULE_5__.default)();\n  (0,_ui_modal_close_js__WEBPACK_IMPORTED_MODULE_6__.default)();\n  (0,_ui_modal_popper_js__WEBPACK_IMPORTED_MODULE_7__.default)();\n  (0,_ui_multi_select_js__WEBPACK_IMPORTED_MODULE_8__.default)();\n  (0,_ui_radio_card_js__WEBPACK_IMPORTED_MODULE_10__.default)();\n  (0,_ui_toast_js__WEBPACK_IMPORTED_MODULE_11__.default)();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYXBwLmpzPzllMGUiXSwibmFtZXMiOlsiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwidGFicyIsImNoZWNrIiwiYm9vdHN0cmFwIiwiZHJhZ2dhYmxlIiwibXVsdGlwbGUiLCJjaGFuZ2VTdWJtaXQiLCJzdWJtaXQiLCJtb2RhbENsb3NlIiwibW9kYWxQb3BwZXIiLCJtdWx0aXBsZVNlbGVjdCIsInJhZGlvQ2FyZCIsInRvYXN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDLFlBQVk7QUFDdERDLHNEQUFJO0FBQ0pDLHVEQUFLO0FBQ0xDLDJEQUFTO0FBQ1RDLDZEQUFTO0FBQ1RDLDBEQUFRO0FBQ1JDLG9FQUFZO0FBQ1pDLDZEQUFNO0FBQ05DLDZEQUFVO0FBQ1ZDLDhEQUFXO0FBQ1hDLDhEQUFjO0FBQ2RDLDZEQUFTO0FBQ1RDLHdEQUFLO0FBQ1IsQ0FiRCIsImZpbGUiOiIuL2Fzc2V0cy9qcy9hcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hlY2sgZnJvbSAnLi91aS9jaGVjay5qcydcbmltcG9ydCBib290c3RyYXAgZnJvbSAnLi91aS9ib290c3RyYXAuanMnXG5pbXBvcnQgeyBkcmFnZ2FibGUgfSBmcm9tICcuL3VpL2RyYWdnYWJsZS5qcydcbmltcG9ydCBtdWx0aXBsZSBmcm9tICcuL3VpL211bHRpcGxlLmpzJ1xuaW1wb3J0IGNoYW5nZVN1Ym1pdCBmcm9tICcuL3VpL2Zvcm1fY2hhbmdlX3N1Ym1pdC5qcydcbmltcG9ydCBzdWJtaXQgZnJvbSAnLi91aS9mb3JtX3N1Ym1pdC5qcydcbmltcG9ydCBtb2RhbENsb3NlIGZyb20gJy4vdWkvbW9kYWxfY2xvc2UuanMnXG5pbXBvcnQgbW9kYWxQb3BwZXIgZnJvbSAnLi91aS9tb2RhbF9wb3BwZXIuanMnXG5pbXBvcnQgbXVsdGlwbGVTZWxlY3QgZnJvbSAnLi91aS9tdWx0aV9zZWxlY3QuanMnXG5pbXBvcnQgdGFicyBmcm9tICcuL3VpL3RhYnMuanMnXG5pbXBvcnQgcmFkaW9DYXJkIGZyb20gJy4vdWkvcmFkaW9fY2FyZC5qcydcbmltcG9ydCB0b2FzdCBmcm9tICcuL3VpL3RvYXN0LmpzJ1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRhYnMoKVxuICAgIGNoZWNrKClcbiAgICBib290c3RyYXAoKVxuICAgIGRyYWdnYWJsZSgpXG4gICAgbXVsdGlwbGUoKVxuICAgIGNoYW5nZVN1Ym1pdCgpXG4gICAgc3VibWl0KClcbiAgICBtb2RhbENsb3NlKClcbiAgICBtb2RhbFBvcHBlcigpXG4gICAgbXVsdGlwbGVTZWxlY3QoKVxuICAgIHJhZGlvQ2FyZCgpXG4gICAgdG9hc3QoKVxufSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/app.js\n");

/***/ }),

/***/ "./assets/js/classes/draggableTable.js":
/*!*********************************************!*\
  !*** ./assets/js/classes/draggableTable.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DraggableTable\": () => (/* binding */ DraggableTable)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n/**\n * DraggableTable\n *\n * Turn a table into a table with rows which can be drag and dropped.\n * This allows users to (re)order the rows in the table. An optional API callback\n * can be passed to the constructor. This allows sending the the state of the table\n * to the backend.\n *\n * Code repurposed from: https://htmldom.dev/drag-and-drop-table-row/\n */\n\nvar DraggableTable = /*#__PURE__*/function () {\n  /**\n   * Dragable Table constructor.\n   * @param { string } DOM element to be selected. It must be a HTML Table tag - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table\n   * @param { callback } The backend callback to notify after swapping the element.\n   */\n  function DraggableTable(_ref) {\n    var tableSelector = _ref.tableSelector,\n        callback = _ref.callback;\n\n    _classCallCheck(this, DraggableTable);\n\n    _defineProperty(this, \"_table\", void 0);\n\n    _defineProperty(this, \"_tableSelector\", void 0);\n\n    _defineProperty(this, \"_callback\", void 0);\n\n    _defineProperty(this, \"_draggingEle\", void 0);\n\n    _defineProperty(this, \"_draggingRowIndex\", void 0);\n\n    _defineProperty(this, \"_placeholder\", void 0);\n\n    _defineProperty(this, \"_list\", void 0);\n\n    _defineProperty(this, \"_isDraggingStarted\", void 0);\n\n    _defineProperty(this, \"_x\", void 0);\n\n    _defineProperty(this, \"_y\", void 0);\n\n    _defineProperty(this, \"_mouseUp\", void 0);\n\n    _defineProperty(this, \"_mouseMove\", void 0);\n\n    _defineProperty(this, \"_mouseDown\", void 0);\n\n    _defineProperty(this, \"_mouseHandlers\", []);\n\n    this._tableSelector = tableSelector;\n    this._callback = callback !== null && callback !== void 0 ? callback : \"\";\n    this._isDraggingStarted = false; // The current position of mouse relative to the dragging element\n\n    this._x = 0;\n    this._y = 0;\n  }\n\n  _createClass(DraggableTable, [{\n    key: \"_swap\",\n    value: function _swap(nodeA, nodeB) {\n      var parentA = nodeA.parentNode;\n      var siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling; // Move `nodeA` to before the `nodeB`\n\n      nodeB.parentNode.insertBefore(nodeA, nodeB); // Move `nodeB` to before the sibling of `nodeA`\n\n      parentA.insertBefore(nodeB, siblingA);\n    }\n  }, {\n    key: \"_isAbove\",\n    value: function _isAbove(nodeA, nodeB) {\n      // Get the bounding rectangle of nodes\n      var rectA = nodeA.getBoundingClientRect();\n      var rectB = nodeB.getBoundingClientRect();\n      return rectA.top + rectA.height / 2 < rectB.top + rectB.height / 2;\n    }\n  }, {\n    key: \"_cloneTable\",\n    value: function _cloneTable() {\n      // const rect = this._table.getBoundingClientRect();\n      var width = parseInt(window.getComputedStyle(this._table).width);\n      this._list = document.createElement('div');\n\n      this._list.classList.add('clone-list'); // list.style.position = 'absolute';\n      // list.style.left = `${rect.left}px`;\n      // list.style.top = `${rect.top}px`;\n\n\n      this._table.parentNode.insertBefore(this._list, this._table); // Hide the original table\n\n\n      this._table.style.visibility = 'hidden';\n\n      this._table.classList.add(\"d-none\");\n\n      this._table.querySelectorAll('tr').forEach(function (row) {\n        // Create a new table from given row\n        var item = document.createElement('div');\n        item.classList.add('draggable');\n        var newTable = document.createElement('table');\n        newTable.setAttribute('class', 'clone-table table');\n        newTable.style.width = \"\".concat(width, \"px\");\n        var newRow = document.createElement('tr');\n        var cells = [].slice.call(row.children);\n        cells.forEach(function (cell) {\n          var newCell = cell.cloneNode(true);\n          newRow.appendChild(newCell);\n        });\n        newTable.appendChild(newRow);\n        item.appendChild(newTable);\n\n        this._list.appendChild(item);\n      }, this);\n    }\n  }, {\n    key: \"_mouseDownHandler\",\n    value: function _mouseDownHandler(e) {\n      // Get the original row\n      var originalRow = e.target.closest('tr');\n      this._draggingRowIndex = [].slice.call(this._table.querySelectorAll('tr')).indexOf(originalRow); // Determine the mouse position\n\n      this._x = e.clientX;\n      this._y = e.clientY; // Attach the listeners to `document`\n\n      this._mouseMove = this._mouseMoveHandler.bind(this);\n      document.addEventListener('mousemove', this._mouseMove);\n      this._mouseUp = this._mouseUpHandler.bind(this);\n      document.addEventListener('mouseup', this._mouseUp);\n    }\n  }, {\n    key: \"_mouseMoveHandler\",\n    value: function _mouseMoveHandler(e) {\n      if (!this._isDraggingStarted) {\n        this._isDraggingStarted = true;\n\n        this._cloneTable();\n\n        this._draggingEle = [].slice.call(this._list.children)[this._draggingRowIndex];\n\n        this._draggingEle.classList.add('dragging'); // Let the placeholder take the height of dragging element\n        // So the next element won't move up\n\n\n        this._placeholder = document.createElement('div');\n\n        this._placeholder.classList.add('placeholder');\n\n        this._draggingEle.parentNode.insertBefore(this._placeholder, this._draggingEle.nextSibling);\n\n        this._placeholder.style.height = \"\".concat(this._draggingEle.offsetHeight, \"px\");\n      } // Set position for dragging element\n\n\n      this._draggingEle.style.position = 'absolute';\n      this._draggingEle.style.top = \"\".concat(this._draggingEle.offsetTop + e.clientY - this._y, \"px\");\n      this._draggingEle.style.left = \"\".concat(this._draggingEle.offsetLeft + e.clientX - this._x, \"px\"); // Reassign the position of mouse\n\n      this._x = e.clientX;\n      this._y = e.clientY; // The current order\n      // prevEle\n      // draggingEle\n      // placeholder\n      // nextEle\n\n      var prevEle = this._draggingEle.previousElementSibling;\n      var nextEle = this._placeholder.nextElementSibling; // The dragging element is above the previous element\n      // User moves the dragging element to the top\n      // We don't allow to drop above the header\n      // (which doesn't have `previousElementSibling`)\n\n      if (prevEle && prevEle.previousElementSibling && this._isAbove(this._draggingEle, prevEle)) {\n        // The current order    -> The new order\n        // prevEle              -> placeholder\n        // draggingEle          -> draggingEle\n        // placeholder          -> prevEle\n        this._swap(this._placeholder, this._draggingEle);\n\n        this._swap(this._placeholder, prevEle);\n\n        return;\n      } // The dragging element is below the next element\n      // User moves the dragging element to the bottom\n\n\n      if (nextEle && this._isAbove(nextEle, this._draggingEle)) {\n        // The current order    -> The new order\n        // draggingEle          -> nextEle\n        // placeholder          -> placeholder\n        // nextEle              -> draggingEle\n        this._swap(nextEle, this._placeholder);\n\n        this._swap(nextEle, this._draggingEle);\n      }\n    }\n  }, {\n    key: \"_mouseUpHandler\",\n    value: function _mouseUpHandler(e) {\n      // Remove the placeholder\n      this._placeholder && this._placeholder.parentNode.removeChild(this._placeholder);\n\n      this._draggingEle.classList.remove('dragging');\n\n      this._draggingEle.style.removeProperty('top');\n\n      this._draggingEle.style.removeProperty('left');\n\n      this._draggingEle.style.removeProperty('position'); // Get the end index\n\n\n      var endRowIndex = [].slice.call(this._list.children).indexOf(this._draggingEle);\n      this._isDraggingStarted = false; // Remove the `list` element\n\n      this._list.parentNode.removeChild(this._list); // Move the dragged row to `endRowIndex`\n\n\n      var rows = [].slice.call(this._table.querySelectorAll('tr'));\n      this._draggingRowIndex > endRowIndex ? rows[endRowIndex].parentNode.insertBefore(rows[this._draggingRowIndex], rows[endRowIndex]) : rows[endRowIndex].parentNode.insertBefore(rows[this._draggingRowIndex], rows[endRowIndex].nextSibling); // Bring back the table\n\n      this._table.style.removeProperty('visibility');\n\n      this._table.classList.remove('d-none');\n\n      if (this._callback !== \"\") {\n        var start = this._draggingRowIndex - 1;\n        var end = endRowIndex - 1;\n        var callback = this._callback;\n        callback = callback.replace(':start', start);\n        callback = callback.replace(':end', end);\n        htmx_org__WEBPACK_IMPORTED_MODULE_0___default().ajax('PUT', callback, this._table.querySelector(\"tbody\"));\n      } // Remove the handlers of `mousemove` and `mouseup`\n\n\n      document.removeEventListener('mousemove', this._mouseMove);\n      document.removeEventListener('mouseup', this._mouseUp);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this._table = document.getElementById(this._tableSelector);\n\n      this._table.querySelectorAll('tr').forEach(function (row, index) {\n        // Ignore the header\n        // We don't want user to change the order of header\n        if (index === 0) {\n          return;\n        }\n\n        var firstCell = row.firstElementChild;\n        firstCell.classList.add('draggable');\n        this._mouseHandlers[index] = this._mouseDownHandler.bind(this);\n        firstCell.addEventListener('mousedown', this._mouseHandlers[index]);\n      }, this);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._table = document.getElementById(this._tableSelector);\n\n      this._table.querySelectorAll('tr:not(.row-new)').forEach(function (row, index) {\n        // Ignore the header\n        // We don't want user to change the order of header\n        if (index === 0) {\n          return;\n        }\n\n        var firstCell = row.firstElementChild;\n        firstCell.classList.remove('draggable');\n        firstCell.removeEventListener('mousedown', this._mouseHandlers[index]);\n      }, this);\n    }\n  }]);\n\n  return DraggableTable;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvY2xhc3Nlcy9kcmFnZ2FibGVUYWJsZS5qcz81M2YwIl0sIm5hbWVzIjpbIkRyYWdnYWJsZVRhYmxlIiwidGFibGVTZWxlY3RvciIsImNhbGxiYWNrIiwiX3RhYmxlU2VsZWN0b3IiLCJfY2FsbGJhY2siLCJfaXNEcmFnZ2luZ1N0YXJ0ZWQiLCJfeCIsIl95Iiwibm9kZUEiLCJub2RlQiIsInBhcmVudEEiLCJwYXJlbnROb2RlIiwic2libGluZ0EiLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsInJlY3RBIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdEIiLCJ0b3AiLCJoZWlnaHQiLCJ3aWR0aCIsInBhcnNlSW50Iiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIl90YWJsZSIsIl9saXN0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJyb3ciLCJpdGVtIiwibmV3VGFibGUiLCJzZXRBdHRyaWJ1dGUiLCJuZXdSb3ciLCJjZWxscyIsInNsaWNlIiwiY2FsbCIsImNoaWxkcmVuIiwiY2VsbCIsIm5ld0NlbGwiLCJjbG9uZU5vZGUiLCJhcHBlbmRDaGlsZCIsImUiLCJvcmlnaW5hbFJvdyIsInRhcmdldCIsImNsb3Nlc3QiLCJfZHJhZ2dpbmdSb3dJbmRleCIsImluZGV4T2YiLCJjbGllbnRYIiwiY2xpZW50WSIsIl9tb3VzZU1vdmUiLCJfbW91c2VNb3ZlSGFuZGxlciIsImJpbmQiLCJhZGRFdmVudExpc3RlbmVyIiwiX21vdXNlVXAiLCJfbW91c2VVcEhhbmRsZXIiLCJfY2xvbmVUYWJsZSIsIl9kcmFnZ2luZ0VsZSIsIl9wbGFjZWhvbGRlciIsIm9mZnNldEhlaWdodCIsInBvc2l0aW9uIiwib2Zmc2V0VG9wIiwibGVmdCIsIm9mZnNldExlZnQiLCJwcmV2RWxlIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsIm5leHRFbGUiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJfaXNBYm92ZSIsIl9zd2FwIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmUiLCJyZW1vdmVQcm9wZXJ0eSIsImVuZFJvd0luZGV4Iiwicm93cyIsInN0YXJ0IiwiZW5kIiwicmVwbGFjZSIsImh0bXgiLCJxdWVyeVNlbGVjdG9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldEVsZW1lbnRCeUlkIiwiaW5kZXgiLCJmaXJzdENlbGwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIl9tb3VzZUhhbmRsZXJzIiwiX21vdXNlRG93bkhhbmRsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxJQUFNQSxjQUFiO0FBZ0JJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDSSxnQ0FBeUM7QUFBQSxRQUEzQkMsYUFBMkIsUUFBM0JBLGFBQTJCO0FBQUEsUUFBWkMsUUFBWSxRQUFaQSxRQUFZOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBLDRDQVB4QixFQU93Qjs7QUFDckMsU0FBS0MsY0FBTCxHQUFzQkYsYUFBdEI7QUFDQSxTQUFLRyxTQUFMLEdBQWlCRixRQUFqQixhQUFpQkEsUUFBakIsY0FBaUJBLFFBQWpCLEdBQTZCLEVBQTdCO0FBQ0EsU0FBS0csa0JBQUwsR0FBMEIsS0FBMUIsQ0FIcUMsQ0FLckM7O0FBQ0EsU0FBS0MsRUFBTCxHQUFVLENBQVY7QUFDQSxTQUFLQyxFQUFMLEdBQVUsQ0FBVjtBQUNIOztBQTdCTDtBQUFBO0FBQUEsV0ErQkksZUFBTUMsS0FBTixFQUFhQyxLQUFiLEVBQW9CO0FBQ2hCLFVBQU1DLE9BQU8sR0FBR0YsS0FBSyxDQUFDRyxVQUF0QjtBQUNBLFVBQU1DLFFBQVEs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QixDQUEyQixXQUEzQjtBQUVBWSxpQkFBUyxDQUFDSCxtQkFBVixDQUE4QixXQUE5QixFQUEyQyxLQUFLSyxjQUFMLENBQW9CSCxLQUFwQixDQUEzQztBQUNILE9BWEQsRUFXRyxJQVhIO0FBWUg7QUFuUEw7O0FBQUE7QUFBQSIsImZpbGUiOiIuL2Fzc2V0cy9qcy9jbGFzc2VzL2RyYWdnYWJsZVRhYmxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0bXggZnJvbSAnaHRteC5vcmcnO1xuXG4vKipcbiAqIERyYWdnYWJsZVRhYmxlXG4gKlxuICogVHVybiBhIHRhYmxlIGludG8gYSB0YWJsZSB3aXRoIHJvd3Mgd2hpY2ggY2FuIGJlIGRyYWcgYW5kIGRyb3BwZWQuXG4gKiBUaGlzIGFsbG93cyB1c2VycyB0byAocmUpb3JkZXIgdGhlIHJvd3MgaW4gdGhlIHRhYmxlLiBBbiBvcHRpb25hbCBBUEkgY2FsbGJhY2tcbiAqIGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBUaGlzIGFsbG93cyBzZW5kaW5nIHRoZSB0aGUgc3RhdGUgb2YgdGhlIHRhYmxlXG4gKiB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBDb2RlIHJlcHVycG9zZWQgZnJvbTogaHR0cHM6Ly9odG1sZG9tLmRldi9kcmFnLWFuZC1kcm9wLXRhYmxlLXJvdy9cbiAqL1xuZXhwb3J0IGNsYXNzIERyYWdnYWJsZVRhYmxlIHtcbiAgICBfdGFibGU7XG4gICAgX3RhYmxlU2VsZWN0b3I7XG4gICAgX2NhbGxiYWNrO1xuICAgIF9kcmFnZ2luZ0VsZTtcbiAgICBfZHJhZ2dpbmdSb3dJbmRleDtcbiAgICBfcGxhY2Vob2xkZXI7XG4gICAgX2xpc3Q7XG4gICAgX2lzRHJhZ2dpbmdTdGFydGVkO1xuICAgIF94O1xuICAgIF95O1xuICAgIF9tb3VzZVVwO1xuICAgIF9tb3VzZU1vdmU7XG4gICAgX21vdXNlRG93bjtcbiAgICBfbW91c2VIYW5kbGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRHJhZ2FibGUgVGFibGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gRE9NIGVsZW1lbnQgdG8gYmUgc2VsZWN0ZWQuIEl0IG11c3QgYmUgYSBIVE1MIFRhYmxlIHRhZyAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC90YWJsZVxuICAgICAqIEBwYXJhbSB7IGNhbGxiYWNrIH0gVGhlIGJhY2tlbmQgY2FsbGJhY2sgdG8gbm90aWZ5IGFmdGVyIHN3YXBwaW5nIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdGFibGVTZWxlY3RvciwgY2FsbGJhY2sgfSkge1xuICAgICAgICB0aGlzLl90YWJsZVNlbGVjdG9yID0gdGFibGVTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjayA/PyBcIlwiO1xuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIG1vdXNlIHJlbGF0aXZlIHRvIHRoZSBkcmFnZ2luZyBlbGVtZW50XG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICB9XG5cbiAgICBfc3dhcChub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QSA9IG5vZGVBLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdBID0gbm9kZUEubmV4dFNpYmxpbmcgPT09IG5vZGVCID8gbm9kZUEgOiBub2RlQS5uZXh0U2libGluZztcblxuICAgICAgICAvLyBNb3ZlIGBub2RlQWAgdG8gYmVmb3JlIHRoZSBgbm9kZUJgXG4gICAgICAgIG5vZGVCLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVBLCBub2RlQik7XG5cbiAgICAgICAgLy8gTW92ZSBgbm9kZUJgIHRvIGJlZm9yZSB0aGUgc2libGluZyBvZiBgbm9kZUFgXG4gICAgICAgIHBhcmVudEEuaW5zZXJ0QmVmb3JlKG5vZGVCLCBzaWJsaW5nQSk7XG4gICAgfVxuXG4gICAgX2lzQWJvdmUobm9kZUEsIG5vZGVCKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGVzXG4gICAgICAgIGNvbnN0IHJlY3RBID0gbm9kZUEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHJlY3RCID0gbm9kZUIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJlY3RBLnRvcCArIHJlY3RBLmhlaWdodCAvIDIgPCByZWN0Qi50b3AgKyByZWN0Qi5oZWlnaHQgLyAyO1xuICAgIH1cblxuICAgIF9jbG9uZVRhYmxlKCkge1xuICAgICAgICAvLyBjb25zdCByZWN0ID0gdGhpcy5fdGFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fdGFibGUpLndpZHRoKTtcblxuICAgICAgICB0aGlzLl9saXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xhc3NMaXN0LmFkZCgnY2xvbmUtbGlzdCcpO1xuICAgICAgICAvLyBsaXN0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgLy8gbGlzdC5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgLy8gbGlzdC5zdHlsZS50b3AgPSBgJHtyZWN0LnRvcH1weGA7XG4gICAgICAgIHRoaXMuX3RhYmxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX2xpc3QsIHRoaXMuX3RhYmxlKTtcblxuICAgICAgICAvLyBIaWRlIHRoZSBvcmlnaW5hbCB0YWJsZVxuICAgICAgICB0aGlzLl90YWJsZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX3RhYmxlLmNsYXNzTGlzdC5hZGQoXCJkLW5vbmVcIik7XG5cbiAgICAgICAgdGhpcy5fdGFibGUucXVlcnlTZWxlY3RvckFsbCgndHInKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0YWJsZSBmcm9tIGdpdmVuIHJvd1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdkcmFnZ2FibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgbmV3VGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgICAgICAgICAgbmV3VGFibGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdjbG9uZS10YWJsZSB0YWJsZScpO1xuICAgICAgICAgICAgbmV3VGFibGUuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IFtdLnNsaWNlLmNhbGwocm93LmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDZWxsID0gY2VsbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgbmV3Um93LmFwcGVuZENoaWxkKG5ld0NlbGwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG5ld1RhYmxlLmFwcGVuZENoaWxkKG5ld1Jvdyk7XG4gICAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKG5ld1RhYmxlKTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIF9tb3VzZURvd25IYW5kbGVyKGUpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCByb3dcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSb3cgPSBlLnRhcmdldC5jbG9zZXN0KCd0cicpO1xuICAgICAgICB0aGlzLl9kcmFnZ2luZ1Jvd0luZGV4ID0gW10uc2xpY2UuY2FsbCh0aGlzLl90YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0cicpKS5pbmRleE9mKG9yaWdpbmFsUm93KTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3ggPSBlLmNsaWVudFg7XG4gICAgICAgIHRoaXMuX3kgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgLy8gQXR0YWNoIHRoZSBsaXN0ZW5lcnMgdG8gYGRvY3VtZW50YFxuICAgICAgICB0aGlzLl9tb3VzZU1vdmUgPSB0aGlzLl9tb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlTW92ZSk7XG5cbiAgICAgICAgdGhpcy5fbW91c2VVcCA9IHRoaXMuX21vdXNlVXBIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9tb3VzZVVwKTtcbiAgICB9XG5cbiAgICBfbW91c2VNb3ZlSGFuZGxlcihlKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNEcmFnZ2luZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmdTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fY2xvbmVUYWJsZSgpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUgPSBbXS5zbGljZS5jYWxsKHRoaXMuX2xpc3QuY2hpbGRyZW4pW3RoaXMuX2RyYWdnaW5nUm93SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUuY2xhc3NMaXN0LmFkZCgnZHJhZ2dpbmcnKTtcblxuXG4gICAgICAgICAgICAvLyBMZXQgdGhlIHBsYWNlaG9sZGVyIHRha2UgdGhlIGhlaWdodCBvZiBkcmFnZ2luZyBlbGVtZW50XG4gICAgICAgICAgICAvLyBTbyB0aGUgbmV4dCBlbGVtZW50IHdvbid0IG1vdmUgdXBcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5jbGFzc0xpc3QuYWRkKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fcGxhY2Vob2xkZXIsIHRoaXMuX2RyYWdnaW5nRWxlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuX2RyYWdnaW5nRWxlLm9mZnNldEhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgcG9zaXRpb24gZm9yIGRyYWdnaW5nIGVsZW1lbnRcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9kcmFnZ2luZ0VsZS5zdHlsZS50b3AgPSBgJHt0aGlzLl9kcmFnZ2luZ0VsZS5vZmZzZXRUb3AgKyBlLmNsaWVudFkgLSB0aGlzLl95fXB4YDtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuX2RyYWdnaW5nRWxlLm9mZnNldExlZnQgKyBlLmNsaWVudFggLSB0aGlzLl94fXB4YDtcblxuICAgICAgICAvLyBSZWFzc2lnbiB0aGUgcG9zaXRpb24gb2YgbW91c2VcbiAgICAgICAgdGhpcy5feCA9IGUuY2xpZW50WDtcbiAgICAgICAgdGhpcy5feSA9IGUuY2xpZW50WTtcblxuICAgICAgICAvLyBUaGUgY3VycmVudCBvcmRlclxuICAgICAgICAvLyBwcmV2RWxlXG4gICAgICAgIC8vIGRyYWdnaW5nRWxlXG4gICAgICAgIC8vIHBsYWNlaG9sZGVyXG4gICAgICAgIC8vIG5leHRFbGVcbiAgICAgICAgY29uc3QgcHJldkVsZSA9IHRoaXMuX2RyYWdnaW5nRWxlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGNvbnN0IG5leHRFbGUgPSB0aGlzLl9wbGFjZWhvbGRlci5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgLy8gVGhlIGRyYWdnaW5nIGVsZW1lbnQgaXMgYWJvdmUgdGhlIHByZXZpb3VzIGVsZW1lbnRcbiAgICAgICAgLy8gVXNlciBtb3ZlcyB0aGUgZHJhZ2dpbmcgZWxlbWVudCB0byB0aGUgdG9wXG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IHRvIGRyb3AgYWJvdmUgdGhlIGhlYWRlclxuICAgICAgICAvLyAod2hpY2ggZG9lc24ndCBoYXZlIGBwcmV2aW91c0VsZW1lbnRTaWJsaW5nYClcbiAgICAgICAgaWYgKHByZXZFbGUgJiYgcHJldkVsZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIHRoaXMuX2lzQWJvdmUodGhpcy5fZHJhZ2dpbmdFbGUsIHByZXZFbGUpKSB7XG4gICAgICAgICAgICAvLyBUaGUgY3VycmVudCBvcmRlciAgICAtPiBUaGUgbmV3IG9yZGVyXG4gICAgICAgICAgICAvLyBwcmV2RWxlICAgICAgICAgICAgICAtPiBwbGFjZWhvbGRlclxuICAgICAgICAgICAgLy8gZHJhZ2dpbmdFbGUgICAgICAgICAgLT4gZHJhZ2dpbmdFbGVcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyICAgICAgICAgIC0+IHByZXZFbGVcbiAgICAgICAgICAgIHRoaXMuX3N3YXAodGhpcy5fcGxhY2Vob2xkZXIsIHRoaXMuX2RyYWdnaW5nRWxlKTtcbiAgICAgICAgICAgIHRoaXMuX3N3YXAodGhpcy5fcGxhY2Vob2xkZXIsIHByZXZFbGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGRyYWdnaW5nIGVsZW1lbnQgaXMgYmVsb3cgdGhlIG5leHQgZWxlbWVudFxuICAgICAgICAvLyBVc2VyIG1vdmVzIHRoZSBkcmFnZ2luZyBlbGVtZW50IHRvIHRoZSBib3R0b21cbiAgICAgICAgaWYgKG5leHRFbGUgJiYgdGhpcy5faXNBYm92ZShuZXh0RWxlLCB0aGlzLl9kcmFnZ2luZ0VsZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IG9yZGVyICAgIC0+IFRoZSBuZXcgb3JkZXJcbiAgICAgICAgICAgIC8vIGRyYWdnaW5nRWxlICAgICAgICAgIC0+IG5leHRFbGVcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyICAgICAgICAgIC0+IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAvLyBuZXh0RWxlICAgICAgICAgICAgICAtPiBkcmFnZ2luZ0VsZVxuICAgICAgICAgICAgdGhpcy5fc3dhcChuZXh0RWxlLCB0aGlzLl9wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB0aGlzLl9zd2FwKG5leHRFbGUsIHRoaXMuX2RyYWdnaW5nRWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9tb3VzZVVwSGFuZGxlcihlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgJiYgdGhpcy5fcGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9wbGFjZWhvbGRlcik7XG5cbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmcnKTtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdFbGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RvcCcpO1xuICAgICAgICB0aGlzLl9kcmFnZ2luZ0VsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbGVmdCcpO1xuICAgICAgICB0aGlzLl9kcmFnZ2luZ0VsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9zaXRpb24nKTtcblxuICAgICAgICAvLyBHZXQgdGhlIGVuZCBpbmRleFxuICAgICAgICBjb25zdCBlbmRSb3dJbmRleCA9IFtdLnNsaWNlLmNhbGwodGhpcy5fbGlzdC5jaGlsZHJlbikuaW5kZXhPZih0aGlzLl9kcmFnZ2luZ0VsZSk7XG5cbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGBsaXN0YCBlbGVtZW50XG4gICAgICAgIHRoaXMuX2xpc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9saXN0KTtcblxuICAgICAgICAvLyBNb3ZlIHRoZSBkcmFnZ2VkIHJvdyB0byBgZW5kUm93SW5kZXhgXG4gICAgICAgIGxldCByb3dzID0gW10uc2xpY2UuY2FsbCh0aGlzLl90YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0cicpKTtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdSb3dJbmRleCA+IGVuZFJvd0luZGV4XG4gICAgICAgICAgICA/IHJvd3NbZW5kUm93SW5kZXhdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJvd3NbdGhpcy5fZHJhZ2dpbmdSb3dJbmRleF0sIHJvd3NbZW5kUm93SW5kZXhdKVxuICAgICAgICAgICAgOiByb3dzW2VuZFJvd0luZGV4XS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgcm93c1t0aGlzLl9kcmFnZ2luZ1Jvd0luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcm93c1tlbmRSb3dJbmRleF0ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgIC8vIEJyaW5nIGJhY2sgdGhlIHRhYmxlXG4gICAgICAgIHRoaXMuX3RhYmxlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd2aXNpYmlsaXR5Jyk7XG4gICAgICAgIHRoaXMuX3RhYmxlLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFjayAhPT0gXCJcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fZHJhZ2dpbmdSb3dJbmRleCAtMVxuICAgICAgICAgICAgbGV0IGVuZCA9IGVuZFJvd0luZGV4IC0xXG5cbiAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrLnJlcGxhY2UoJzpzdGFydCcsIHN0YXJ0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gIGNhbGxiYWNrLnJlcGxhY2UoJzplbmQnLCBlbmQpO1xuICAgICAgICAgICAgaHRteC5hamF4KCdQVVQnLCBjYWxsYmFjaywgdGhpcy5fdGFibGUucXVlcnlTZWxlY3RvcihcInRib2R5XCIpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBoYW5kbGVycyBvZiBgbW91c2Vtb3ZlYCBhbmQgYG1vdXNldXBgXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9tb3VzZVVwKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl90YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX3RhYmxlU2VsZWN0b3IpO1xuXG4gICAgICAgIHRoaXMuX3RhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJykuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBoZWFkZXJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdXNlciB0byBjaGFuZ2UgdGhlIG9yZGVyIG9mIGhlYWRlclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmaXJzdENlbGwgPSByb3cuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICBmaXJzdENlbGwuY2xhc3NMaXN0LmFkZCgnZHJhZ2dhYmxlJyk7XG5cbiAgICAgICAgICAgIHRoaXMuX21vdXNlSGFuZGxlcnNbaW5kZXhdID0gdGhpcy5fbW91c2VEb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgZmlyc3RDZWxsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlSGFuZGxlcnNbaW5kZXhdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3RhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fdGFibGVTZWxlY3Rvcik7XG5cbiAgICAgICAgdGhpcy5fdGFibGUucXVlcnlTZWxlY3RvckFsbCgndHI6bm90KC5yb3ctbmV3KScpLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgaGVhZGVyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHVzZXIgdG8gY2hhbmdlIHRoZSBvcmRlciBvZiBoZWFkZXJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gcm93LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgZmlyc3RDZWxsLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnYWJsZScpO1xuXG4gICAgICAgICAgICBmaXJzdENlbGwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2VIYW5kbGVyc1tpbmRleF0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/classes/draggableTable.js\n");

/***/ }),

/***/ "./assets/js/ui/bootstrap.js":
/*!***********************************!*\
  !*** ./assets/js/ui/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap.native/dist/bootstrap-native-v4 */ \"./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\");\n/* harmony import */ var bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\n * Initialize Bootstrap Native after HTMX has settled the DOM.\n *\n * When HTMX is executed, the updated parts of the DOM won't be\n * registered with Bootstrap Native. Elements like i.e. popovers,\n * alerts, tooltips,... won't work passed via HTMX won't work.\n * This function re-initializes Bootstrap Native on the updated DOM.\n */\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    bootstrap_native_dist_bootstrap_native_v4__WEBPACK_IMPORTED_MODULE_1___default().initCallback();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvYm9vdHN0cmFwLmpzPzFlZTMiXSwibmFtZXMiOlsiaHRteCIsImV2dCIsIkJTTiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSw2QkFBZSxzQ0FBVztBQUN0QkEsb0RBQUEsQ0FBUSxrQkFBUixFQUE0QixVQUFTQyxHQUFULEVBQWM7QUFDdENDLGlHQUFBO0FBQ0gsR0FGRDtBQUdIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL2Jvb3RzdHJhcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodG14IGZyb20gJ2h0bXgub3JnJztcbmltcG9ydCBCU04gZnJvbSBcImJvb3RzdHJhcC5uYXRpdmUvZGlzdC9ib290c3RyYXAtbmF0aXZlLXY0XCI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBCb290c3RyYXAgTmF0aXZlIGFmdGVyIEhUTVggaGFzIHNldHRsZWQgdGhlIERPTS5cbiAqXG4gKiBXaGVuIEhUTVggaXMgZXhlY3V0ZWQsIHRoZSB1cGRhdGVkIHBhcnRzIG9mIHRoZSBET00gd29uJ3QgYmVcbiAqIHJlZ2lzdGVyZWQgd2l0aCBCb290c3RyYXAgTmF0aXZlLiBFbGVtZW50cyBsaWtlIGkuZS4gcG9wb3ZlcnMsXG4gKiBhbGVydHMsIHRvb2x0aXBzLC4uLiB3b24ndCB3b3JrIHBhc3NlZCB2aWEgSFRNWCB3b24ndCB3b3JrLlxuICogVGhpcyBmdW5jdGlvbiByZS1pbml0aWFsaXplcyBCb290c3RyYXAgTmF0aXZlIG9uIHRoZSB1cGRhdGVkIERPTS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gICAgaHRteC5vbihcImh0bXg6YWZ0ZXJTZXR0bGVcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIEJTTi5pbml0Q2FsbGJhY2soKVxuICAgIH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/ui/bootstrap.js\n");

/***/ }),

/***/ "./assets/js/ui/check.js":
/*!*******************************!*\
  !*** ./assets/js/ui/check.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var formCheckAll = function formCheckAll(evt) {\n    var form = evt.target.closest(\"form\");\n    var chks = form.querySelectorAll(\"input[type='checkbox']\");\n    chks.forEach(function (el) {\n      return el.checked = true;\n    });\n  };\n\n  document.querySelectorAll(\"button.form-check-all\").forEach(function (el) {\n    return el.addEventListener(\"click\", formCheckAll);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvY2hlY2suanM/MDI1NSJdLCJuYW1lcyI6WyJmb3JtQ2hlY2tBbGwiLCJldnQiLCJmb3JtIiwidGFyZ2V0IiwiY2xvc2VzdCIsImNoa3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwiY2hlY2tlZCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZCQUFlLHNDQUFXO0FBQ3RCLE1BQUlBLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQVVDLEdBQVYsRUFBZTtBQUM5QixRQUFJQyxJQUFJLEdBQUdELEdBQUcsQ0FBQ0UsTUFBSixDQUFXQyxPQUFYLENBQW1CLE1BQW5CLENBQVg7QUFDQSxRQUFJQyxJQUFJLEdBQUdILElBQUksQ0FBQ0ksZ0JBQUwsQ0FBc0Isd0JBQXRCLENBQVg7QUFDQUQsUUFBSSxDQUFDRSxPQUFMLENBQWEsVUFBQUMsRUFBRTtBQUFBLGFBQ1hBLEVBQUUsQ0FBQ0MsT0FBSCxHQUFhLElBREY7QUFBQSxLQUFmO0FBR0gsR0FORDs7QUFRQUMsVUFBUSxDQUFDSixnQkFBVCxDQUEwQix1QkFBMUIsRUFBbURDLE9BQW5ELENBQTJELFVBQUFDLEVBQUU7QUFBQSxXQUN6REEsRUFBRSxDQUFDRyxnQkFBSCxDQUFvQixPQUFwQixFQUE2QlgsWUFBN0IsQ0FEeUQ7QUFBQSxHQUE3RDtBQUdIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL2NoZWNrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gICAgbGV0IGZvcm1DaGVja0FsbCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgbGV0IGZvcm0gPSBldnQudGFyZ2V0LmNsb3Nlc3QoXCJmb3JtXCIpXG4gICAgICAgIGxldCBjaGtzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbdHlwZT0nY2hlY2tib3gnXVwiKVxuICAgICAgICBjaGtzLmZvckVhY2goZWwgPT5cbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSB0cnVlXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiYnV0dG9uLmZvcm0tY2hlY2stYWxsXCIpLmZvckVhY2goZWwgPT5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZvcm1DaGVja0FsbClcbiAgICApXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/ui/check.js\n");

/***/ }),

/***/ "./assets/js/ui/draggable.js":
/*!***********************************!*\
  !*** ./assets/js/ui/draggable.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"draggable\": () => (/* binding */ draggable)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _classes_draggableTable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/draggableTable.js */ \"./assets/js/classes/draggableTable.js\");\n\n // TODO: We likely want to turn this into a separate class too.\n//  we just want to set the callback and ensure everything gets hooked\n//  to specific DOM elements, rather then generic selectors as we do now.\n\nfunction draggable() {\n  // Disable buttons when we edit / add a row.\n  var disableRowButtons = function disableRowButtons(evt) {\n    var rows = document.querySelector('table.inline-editing tbody').children;\n\n    for (var i = 0; i < rows.length; i++) {\n      var row = rows[i];\n\n      if (!row.classList.contains(\"row-new\") && !row.classList.contains(\"row-edit\")) {\n        var buttons = row.getElementsByTagName(\"button\");\n        Array.from(buttons).forEach(function (button) {\n          button.classList.add(\"d-none\");\n        });\n      }\n    }\n  }; // Compose a spinner element\n\n\n  var createSpinner = function createSpinner() {\n    var spinner = document.createElement(\"div\");\n    spinner.classList.add('spinner-border');\n    var text = document.createElement(\"span\");\n    text.classList.add(\"sr-only\");\n    var cta = document.createTextNode(\"Loading...\");\n    text.appendChild(cta);\n    spinner.appendChild(text);\n    return spinner;\n  };\n\n  var currentUrl = new URL(window.location.href);\n  var callback = \"\";\n  var tableSelector; // Generate the callback for the authors\n  // TODO: Turn the pattern matching into something that incorporates the basePath of the Go app.\n\n  if (currentUrl.pathname.match(new RegExp(\"^.*/publication/[0-9]*$\", 'gm'))) {\n    callback = currentUrl.pathname + \"/htmx/authors/order/:start/:end\";\n    tableSelector = \"authors-table\";\n  }\n\n  if (tableSelector !== undefined && document.getElementById(tableSelector)) {\n    // Init the Draggable table\n    var table = new _classes_draggableTable_js__WEBPACK_IMPORTED_MODULE_1__.DraggableTable({\n      tableSelector: tableSelector,\n      callback: callback\n    });\n    table.init(); // Init the addAuthor button\n\n    var addAuthor = document.querySelector(\"button.btn-outline-primary.add-author\"); // Init a spinner (loading...) object\n\n    var spinner; // ... This is where the magic starts to happen ...\n    // After the table is refreshed\n\n    htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"ITListAfterSwap\", function (evt) {\n      // Make the table draggable again.\n      table.init(); // We can click the 'add author' button from the top menu.\n\n      addAuthor.removeAttribute(\"disabled\"); // We remove the spinner if there is any active\n\n      if (spinner !== undefined) {\n        spinner.remove();\n      }\n    }); // After the order was changed thru drag n' droppin'\n\n    htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"ITOrderAuthorsAfterSwap\", function (evt) {\n      table.init();\n    }); // A new empty row form was added. Disable all add / edit / delete buttons\n\n    htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"ITAddRowAfterSwap\", function (evt) {\n      // Make the table static non-draggable.\n      table.reset(); // Disable the 'Add author' button from the top menu.\n\n      addAuthor.setAttribute(\"disabled\", \"true\"); // Remove all buttons except the one's on the active form.\n\n      disableRowButtons(evt); // Add spinner handler to the 'create' button.\n\n      var updateButton = document.querySelector(\"table#authors-table button.create-author\");\n      updateButton.addEventListener(\"click\", function (e) {\n        spinner = createSpinner();\n        addAuthor.after(spinner);\n      });\n    }); // An row is being edited. Disable all add / edit / delete buttons\n\n    htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"ITEditRowAfterSwap\", function (evt) {\n      table.reset();\n      addAuthor.setAttribute(\"disabled\", \"true\");\n      disableRowButtons(evt);\n      var createButton = document.querySelector(\"table#authors-table button.update-author\");\n      createButton.addEventListener(\"click\", function (e) {\n        spinner = createSpinner();\n        addAuthor.after(spinner);\n      });\n    }); // A row is being deleted. Show a spinner next to the 'delete' button in the popup\n\n    htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"ITConfirmRemoveFromPublicationAfterSwap\", function (evt) {\n      var removeButton = document.querySelector(\"div.modal-confirm-author-removal button.delete-author\");\n      removeButton.addEventListener(\"click\", function (e) {\n        spinner = createSpinner();\n        removeButton.after(spinner);\n      });\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvZHJhZ2dhYmxlLmpzP2YxODAiXSwibmFtZXMiOlsiZHJhZ2dhYmxlIiwiZGlzYWJsZVJvd0J1dHRvbnMiLCJldnQiLCJyb3dzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiY2hpbGRyZW4iLCJpIiwibGVuZ3RoIiwicm93IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJidXR0b25zIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJBcnJheSIsImZyb20iLCJmb3JFYWNoIiwiYnV0dG9uIiwiYWRkIiwiY3JlYXRlU3Bpbm5lciIsInNwaW5uZXIiLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImN0YSIsImNyZWF0ZVRleHROb2RlIiwiYXBwZW5kQ2hpbGQiLCJjdXJyZW50VXJsIiwiVVJMIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiY2FsbGJhY2siLCJ0YWJsZVNlbGVjdG9yIiwicGF0aG5hbWUiLCJtYXRjaCIsIlJlZ0V4cCIsInVuZGVmaW5lZCIsImdldEVsZW1lbnRCeUlkIiwidGFibGUiLCJEcmFnZ2FibGVUYWJsZSIsImluaXQiLCJhZGRBdXRob3IiLCJodG14IiwicmVtb3ZlQXR0cmlidXRlIiwicmVtb3ZlIiwicmVzZXQiLCJzZXRBdHRyaWJ1dGUiLCJ1cGRhdGVCdXR0b24iLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImFmdGVyIiwiY3JlYXRlQnV0dG9uIiwicmVtb3ZlQnV0dG9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Q0FHQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0EsU0FBVCxHQUFxQjtBQUV4QjtBQUNBLE1BQUlDLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsQ0FBU0MsR0FBVCxFQUFjO0FBQ2xDLFFBQUlDLElBQUksR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLDRCQUF2QixFQUFxREMsUUFBaEU7O0FBRUEsU0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FB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QUE5QixFQUF1QyxVQUFTQyxDQUFULEVBQVk7QUFDL0M3QixlQUFPLEdBQUdELGFBQWEsRUFBdkI7QUFDQWlDLG9CQUFZLENBQUNGLEtBQWIsQ0FBbUI5QixPQUFuQjtBQUNILE9BSEQ7QUFJSCxLQU5EO0FBT0g7QUFDSiIsImZpbGUiOiIuL2Fzc2V0cy9qcy91aS9kcmFnZ2FibGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHRteCBmcm9tICdodG14Lm9yZyc7XG5pbXBvcnQgeyBEcmFnZ2FibGVUYWJsZSB9IGZyb20gJy4uL2NsYXNzZXMvZHJhZ2dhYmxlVGFibGUuanMnO1xuXG4vLyBUT0RPOiBXZSBsaWtlbHkgd2FudCB0byB0dXJuIHRoaXMgaW50byBhIHNlcGFyYXRlIGNsYXNzIHRvby5cbi8vICB3ZSBqdXN0IHdhbnQgdG8gc2V0IHRoZSBjYWxsYmFjayBhbmQgZW5zdXJlIGV2ZXJ5dGhpbmcgZ2V0cyBob29rZWRcbi8vICB0byBzcGVjaWZpYyBET00gZWxlbWVudHMsIHJhdGhlciB0aGVuIGdlbmVyaWMgc2VsZWN0b3JzIGFzIHdlIGRvIG5vdy5cbmV4cG9ydCBmdW5jdGlvbiBkcmFnZ2FibGUoKSB7XG5cbiAgICAvLyBEaXNhYmxlIGJ1dHRvbnMgd2hlbiB3ZSBlZGl0IC8gYWRkIGEgcm93LlxuICAgIGxldCBkaXNhYmxlUm93QnV0dG9ucyA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBsZXQgcm93cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlLmlubGluZS1lZGl0aW5nIHRib2R5JykuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcm93ID0gcm93c1tpXTtcblxuICAgICAgICAgICAgaWYgKCAhIHJvdy5jbGFzc0xpc3QuY29udGFpbnMoXCJyb3ctbmV3XCIpICYmICEgcm93LmNsYXNzTGlzdC5jb250YWlucyhcInJvdy1lZGl0XCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvbnMgPSByb3cuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJidXR0b25cIik7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShidXR0b25zKS5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkLW5vbmVcIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXBvc2UgYSBzcGlubmVyIGVsZW1lbnRcbiAgICBsZXQgY3JlYXRlU3Bpbm5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBzcGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICBzcGlubmVyLmNsYXNzTGlzdC5hZGQoJ3NwaW5uZXItYm9yZGVyJylcblxuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgdGV4dC5jbGFzc0xpc3QuYWRkKFwic3Itb25seVwiKVxuICAgICAgICBsZXQgY3RhID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJMb2FkaW5nLi4uXCIpXG4gICAgICAgIHRleHQuYXBwZW5kQ2hpbGQoY3RhKVxuXG4gICAgICAgIHNwaW5uZXIuYXBwZW5kQ2hpbGQodGV4dClcblxuICAgICAgICByZXR1cm4gc3Bpbm5lclxuICAgIH1cblxuICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgbGV0IGNhbGxiYWNrID0gXCJcIjtcbiAgICBsZXQgdGFibGVTZWxlY3RvcjtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGF1dGhvcnNcbiAgICAvLyBUT0RPOiBUdXJuIHRoZSBwYXR0ZXJuIG1hdGNoaW5nIGludG8gc29tZXRoaW5nIHRoYXQgaW5jb3Jwb3JhdGVzIHRoZSBiYXNlUGF0aCBvZiB0aGUgR28gYXBwLlxuICAgIGlmIChjdXJyZW50VXJsLnBhdGhuYW1lLm1hdGNoKG5ldyBSZWdFeHAoYF5cXC4qXFwvcHVibGljYXRpb25cXC9bMC05XSokYCwgJ2dtJykpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY3VycmVudFVybC5wYXRobmFtZSArIFwiL2h0bXgvYXV0aG9ycy9vcmRlci86c3RhcnQvOmVuZFwiXG4gICAgICAgIHRhYmxlU2VsZWN0b3IgPSBcImF1dGhvcnMtdGFibGVcIjtcbiAgICB9XG5cbiAgICBpZiAodGFibGVTZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhYmxlU2VsZWN0b3IpKSB7XG4gICAgICAgIC8vIEluaXQgdGhlIERyYWdnYWJsZSB0YWJsZVxuICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBEcmFnZ2FibGVUYWJsZSh7IHRhYmxlU2VsZWN0b3I6IHRhYmxlU2VsZWN0b3IsIGNhbGxiYWNrOiBjYWxsYmFjayB9KTtcbiAgICAgICAgdGFibGUuaW5pdCgpO1xuXG4gICAgICAgIC8vIEluaXQgdGhlIGFkZEF1dGhvciBidXR0b25cbiAgICAgICAgbGV0IGFkZEF1dGhvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uYnRuLW91dGxpbmUtcHJpbWFyeS5hZGQtYXV0aG9yXCIpO1xuXG4gICAgICAgIC8vIEluaXQgYSBzcGlubmVyIChsb2FkaW5nLi4uKSBvYmplY3RcbiAgICAgICAgbGV0IHNwaW5uZXI7XG5cbiAgICAgICAgLy8gLi4uIFRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIHN0YXJ0cyB0byBoYXBwZW4gLi4uXG5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIHRhYmxlIGlzIHJlZnJlc2hlZFxuICAgICAgICBodG14Lm9uKFwiSVRMaXN0QWZ0ZXJTd2FwXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgLy8gTWFrZSB0aGUgdGFibGUgZHJhZ2dhYmxlIGFnYWluLlxuICAgICAgICAgICAgdGFibGUuaW5pdCgpO1xuICAgICAgICAgICAgLy8gV2UgY2FuIGNsaWNrIHRoZSAnYWRkIGF1dGhvcicgYnV0dG9uIGZyb20gdGhlIHRvcCBtZW51LlxuICAgICAgICAgICAgYWRkQXV0aG9yLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuXG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhlIHNwaW5uZXIgaWYgdGhlcmUgaXMgYW55IGFjdGl2ZVxuICAgICAgICAgICAgaWYgKHNwaW5uZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNwaW5uZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFmdGVyIHRoZSBvcmRlciB3YXMgY2hhbmdlZCB0aHJ1IGRyYWcgbicgZHJvcHBpbidcbiAgICAgICAgaHRteC5vbihcIklUT3JkZXJBdXRob3JzQWZ0ZXJTd2FwXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdGFibGUuaW5pdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBIG5ldyBlbXB0eSByb3cgZm9ybSB3YXMgYWRkZWQuIERpc2FibGUgYWxsIGFkZCAvIGVkaXQgLyBkZWxldGUgYnV0dG9uc1xuICAgICAgICBodG14Lm9uKFwiSVRBZGRSb3dBZnRlclN3YXBcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAvLyBNYWtlIHRoZSB0YWJsZSBzdGF0aWMgbm9uLWRyYWdnYWJsZS5cbiAgICAgICAgICAgIHRhYmxlLnJlc2V0KCk7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIHRoZSAnQWRkIGF1dGhvcicgYnV0dG9uIGZyb20gdGhlIHRvcCBtZW51LlxuICAgICAgICAgICAgYWRkQXV0aG9yLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgYnV0dG9ucyBleGNlcHQgdGhlIG9uZSdzIG9uIHRoZSBhY3RpdmUgZm9ybS5cbiAgICAgICAgICAgIGRpc2FibGVSb3dCdXR0b25zKGV2dCk7XG4gICAgICAgICAgICAvLyBBZGQgc3Bpbm5lciBoYW5kbGVyIHRvIHRoZSAnY3JlYXRlJyBidXR0b24uXG4gICAgICAgICAgICBsZXQgdXBkYXRlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRhYmxlI2F1dGhvcnMtdGFibGUgYnV0dG9uLmNyZWF0ZS1hdXRob3JcIik7XG4gICAgICAgICAgICB1cGRhdGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzcGlubmVyID0gY3JlYXRlU3Bpbm5lcigpO1xuICAgICAgICAgICAgICAgIGFkZEF1dGhvci5hZnRlcihzcGlubmVyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFuIHJvdyBpcyBiZWluZyBlZGl0ZWQuIERpc2FibGUgYWxsIGFkZCAvIGVkaXQgLyBkZWxldGUgYnV0dG9uc1xuICAgICAgICBodG14Lm9uKFwiSVRFZGl0Um93QWZ0ZXJTd2FwXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdGFibGUucmVzZXQoKTtcbiAgICAgICAgICAgIGFkZEF1dGhvci5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICBkaXNhYmxlUm93QnV0dG9ucyhldnQpO1xuICAgICAgICAgICAgbGV0IGNyZWF0ZUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0YWJsZSNhdXRob3JzLXRhYmxlIGJ1dHRvbi51cGRhdGUtYXV0aG9yXCIpO1xuICAgICAgICAgICAgY3JlYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc3Bpbm5lciA9IGNyZWF0ZVNwaW5uZXIoKTtcbiAgICAgICAgICAgICAgICBhZGRBdXRob3IuYWZ0ZXIoc3Bpbm5lcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBIHJvdyBpcyBiZWluZyBkZWxldGVkLiBTaG93IGEgc3Bpbm5lciBuZXh0IHRvIHRoZSAnZGVsZXRlJyBidXR0b24gaW4gdGhlIHBvcHVwXG4gICAgICAgIGh0bXgub24oXCJJVENvbmZpcm1SZW1vdmVGcm9tUHVibGljYXRpb25BZnRlclN3YXBcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdi5tb2RhbC1jb25maXJtLWF1dGhvci1yZW1vdmFsIGJ1dHRvbi5kZWxldGUtYXV0aG9yXCIpO1xuICAgICAgICAgICAgcmVtb3ZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc3Bpbm5lciA9IGNyZWF0ZVNwaW5uZXIoKTtcbiAgICAgICAgICAgICAgICByZW1vdmVCdXR0b24uYWZ0ZXIoc3Bpbm5lcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/js/ui/draggable.js\n");

/***/ }),

/***/ "./assets/js/ui/form_change_submit.js":
/*!********************************************!*\
  !*** ./assets/js/ui/form_change_submit.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  document.querySelectorAll(\"form.form-change-submit\").forEach(function (el) {\n    return el.addEventListener(\"change\", function (evt) {\n      return el.submit();\n    });\n  });\n  document.querySelectorAll(\"form .form-change-submit\").forEach(function (el) {\n    return el.addEventListener(\"change\", function (evt) {\n      return evt.target.closest(\"form\").submit();\n    });\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvZm9ybV9jaGFuZ2Vfc3VibWl0LmpzPzhmMjYiXSwibmFtZXMiOlsiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2dCIsInN1Ym1pdCIsInRhcmdldCIsImNsb3Nlc3QiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2QkFBZSxzQ0FBVztBQUN0QkEsVUFBUSxDQUFDQyxnQkFBVCxDQUEwQix5QkFBMUIsRUFBcURDLE9BQXJELENBQTZELFVBQUFDLEVBQUU7QUFBQSxXQUMzREEsRUFBRSxDQUFDQyxnQkFBSCxDQUFvQixRQUFwQixFQUE4QixVQUFBQyxHQUFHO0FBQUEsYUFDN0JGLEVBQUUsQ0FBQ0csTUFBSCxFQUQ2QjtBQUFBLEtBQWpDLENBRDJEO0FBQUEsR0FBL0Q7QUFLQU4sVUFBUSxDQUFDQyxnQkFBVCxDQUEwQiwwQkFBMUIsRUFBc0RDLE9BQXRELENBQThELFVBQUFDLEVBQUU7QUFBQSxXQUM1REEsRUFBRSxDQUFDQyxnQkFBSCxDQUFvQixRQUFwQixFQUE4QixVQUFBQyxHQUFHO0FBQUEsYUFDN0JBLEdBQUcsQ0FBQ0UsTUFBSixDQUFXQyxPQUFYLENBQW1CLE1BQW5CLEVBQTJCRixNQUEzQixFQUQ2QjtBQUFBLEtBQWpDLENBRDREO0FBQUEsR0FBaEU7QUFLSCIsImZpbGUiOiIuL2Fzc2V0cy9qcy91aS9mb3JtX2NoYW5nZV9zdWJtaXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiZm9ybS5mb3JtLWNoYW5nZS1zdWJtaXRcIikuZm9yRWFjaChlbCA9PlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2dCA9PlxuICAgICAgICAgICAgZWwuc3VibWl0KClcbiAgICAgICAgKVxuICAgIClcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiZm9ybSAuZm9ybS1jaGFuZ2Utc3VibWl0XCIpLmZvckVhY2goZWwgPT5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldnQgPT5cbiAgICAgICAgICAgIGV2dC50YXJnZXQuY2xvc2VzdChcImZvcm1cIikuc3VibWl0KClcbiAgICAgICAgKVxuICAgIClcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/js/ui/form_change_submit.js\n");

/***/ }),

/***/ "./assets/js/ui/form_submit.js":
/*!*************************************!*\
  !*** ./assets/js/ui/form_submit.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n // import BSN from \"bootstrap.native/dist/bootstrap-native-v4\";\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  // Compose a spinner element\n  function createSpinner() {\n    var spinner = document.createElement(\"div\");\n    spinner.classList.add('spinner-border');\n    var text = document.createElement(\"span\");\n    text.classList.add(\"sr-only\");\n    var cta = document.createTextNode(\"Loading...\");\n    text.appendChild(cta);\n    spinner.appendChild(text);\n    return spinner;\n  } // On submit, disable the cancel / save buttons & set the spinner\n\n\n  function formSubmit(form) {\n    var submitButton = form.querySelector('.btn-save');\n    var cancelButton = form.querySelector('.btn-cancel'); // Load the spinner when the button is clicked\n\n    if (submitButton !== null) {\n      htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(submitButton, \"click\", function (evt) {\n        var spinner = createSpinner();\n        submitButton.after(spinner);\n      });\n    } // Disable the buttons after HTMX has started, but before the XHR request is\n    // dispatched. Doing this on the 'click' event blocks triggering the HTMX lifecycle.\n    //\n    // See: https://github.com/bigskysoftware/htmx/issues/394\n\n\n    htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:beforeRequest\", function (evt) {\n      submitButton.setAttribute(\"disabled\", \"\");\n      cancelButton.setAttribute(\"disabled\", \"\");\n    });\n  } // After submission, auto-dismiss all alerts after 10 seconds.\n  // TODO: if 2 consecutive save actions happen within the 10 second interval,\n  //    the first displayed alert will be destroyed by HTMX, causing the setTimeout\n  //    to trigger a runtime error as it tries to apply a BSN.alert on a non-existing\n  //    element.\n  // function closeAlerts() {\n  //     let alerts = document.querySelectorAll('.alert')\n  //     alerts.forEach((el) => {\n  //         setTimeout(() => {\n  //             let alert = new BSN.Alert(el)\n  //             alert.close()\n  //         }, 10000)\n  //     })\n  // }\n  // Init event listeners whenever HTMX swaps in a card-collapsible having a form element.\n\n\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    var item = evt.detail.target.children.item(0);\n\n    if (item && item.nodeName && item.nodeName.toLowerCase() == \"form\") {\n      formSubmit(item);\n    } else {// closeAlerts()\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvZm9ybV9zdWJtaXQuanM/ZDg3OSJdLCJuYW1lcyI6WyJjcmVhdGVTcGlubmVyIiwic3Bpbm5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInRleHQiLCJjdGEiLCJjcmVhdGVUZXh0Tm9kZSIsImFwcGVuZENoaWxkIiwiZm9ybVN1Ym1pdCIsImZvcm0iLCJzdWJtaXRCdXR0b24iLCJxdWVyeVNlbGVjdG9yIiwiY2FuY2VsQnV0dG9uIiwiaHRteCIsImV2dCIsImFmdGVyIiwic2V0QXR0cmlidXRlIiwiaXRlbSIsImRldGFpbCIsInRhcmdldCIsImNoaWxkcmVuIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0NBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFFdEI7QUFDQSxXQUFTQSxhQUFULEdBQXlCO0FBQ3JCLFFBQU1DLE9BQU8sR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FGLFdBQU8sQ0FBQ0csU0FBUixDQUFrQkMsR0FBbEIsQ0FBc0IsZ0JBQXRCO0FBRUEsUUFBTUMsSUFBSSxHQUFHSixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBYjtBQUNBRyxRQUFJLENBQUNGLFNBQUwsQ0FBZUMsR0FBZixDQUFtQixTQUFuQjtBQUNBLFFBQUlFLEdBQUcsR0FBR0wsUUFBUSxDQUFDTSxjQUFULENBQXdCLFlBQXhCLENBQVY7QUFDQUYsUUFBSSxDQUFDRyxXQUFMLENBQWlCRixHQUFqQjtBQUVBTixXQUFPLENBQUNRLFdBQVIsQ0FBb0JILElBQXBCO0FBRUEsV0FBT0wsT0FBUDtBQUNILEdBZnFCLENBaUJ0Qjs7O0FBQ0EsV0FBU1MsVUFBVCxDQUFvQkMsSUFBcEIsRUFBMEI7QUFDdEIsUUFBTUMsWUFBWSxHQUFHRCxJQUFJLENBQUNFLGFBQUwsQ0FBbUIsV0FBbkIsQ0FBckI7QUFDQSxRQUFNQyxZQUFZLEdBQUdILElBQUksQ0FBQ0UsYUFBTCxDQUFtQixhQUFuQixDQUFyQixDQUZzQixDQUl0Qjs7QUFDQSxRQUFJRCxZQUFZLEtBQUssSUFBckIsRUFBMkI7QUFDdkJHLHdEQUFBLENBQVFILFlBQVIsRUFBc0IsT0FBdEIsRUFBK0IsVUFBU0ksR0FBVCxFQUFjO0FBQ3pDLFlBQU1mLE9BQU8sR0FBR0QsYUFBYSxFQUE3QjtBQUNBWSxvQkFBWSxDQUFDSyxLQUFiLENBQW1CaEIsT0FBbkI7QUFDSCxPQUhEO0FBSUgsS0FWcUIsQ0FZdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUNBYyxzREFBQSxDQUFRLG9CQUFSLEVBQThCLFVBQVNDLEdBQVQsRUFBYztBQUN4Q0osa0JBQVksQ0FBQ00sWUFBYixDQUEwQixVQUExQixFQUFzQyxFQUF0QztBQUNBSixrQkFBWSxDQUFDSSxZQUFiLENBQTBCLFVBQTFCLEVBQXNDLEVBQXRDO0FBQ0gsS0FIRDtBQUlILEdBdENxQixDQXdDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQUgsb0RBQUEsQ0FBUSxrQkFBUixFQUE0QixVQUFTQyxHQUFULEVBQWM7QUFDdEMsUUFBSUcsSUFBSSxHQUFHSCxHQUFHLENBQUNJLE1BQUosQ0FBV0MsTUFBWCxDQUFrQkMsUUFBbEIsQ0FBMkJILElBQTNCLENBQWdDLENBQWhDLENBQVg7O0FBQ0EsUUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUNJLFFBQWIsSUFBMEJKLElBQUksQ0FBQ0ksUUFBTCxDQUFjQyxXQUFkLE1BQStCLE1BQTdELEVBQXNFO0FBQ2xFZCxnQkFBVSxDQUFDUyxJQUFELENBQVY7QUFDSCxLQUZELE1BRU8sQ0FDSDtBQUNIO0FBQ0osR0FQRDtBQVFIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL2Zvcm1fc3VibWl0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0bXggZnJvbSAnaHRteC5vcmcnO1xuLy8gaW1wb3J0IEJTTiBmcm9tIFwiYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBDb21wb3NlIGEgc3Bpbm5lciBlbGVtZW50XG4gICAgZnVuY3Rpb24gY3JlYXRlU3Bpbm5lcigpIHtcbiAgICAgICAgY29uc3Qgc3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgc3Bpbm5lci5jbGFzc0xpc3QuYWRkKCdzcGlubmVyLWJvcmRlcicpXG5cbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIHRleHQuY2xhc3NMaXN0LmFkZChcInNyLW9ubHlcIilcbiAgICAgICAgbGV0IGN0YSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiTG9hZGluZy4uLlwiKVxuICAgICAgICB0ZXh0LmFwcGVuZENoaWxkKGN0YSlcblxuICAgICAgICBzcGlubmVyLmFwcGVuZENoaWxkKHRleHQpXG5cbiAgICAgICAgcmV0dXJuIHNwaW5uZXJcbiAgICB9XG5cbiAgICAvLyBPbiBzdWJtaXQsIGRpc2FibGUgdGhlIGNhbmNlbCAvIHNhdmUgYnV0dG9ucyAmIHNldCB0aGUgc3Bpbm5lclxuICAgIGZ1bmN0aW9uIGZvcm1TdWJtaXQoZm9ybSkge1xuICAgICAgICBjb25zdCBzdWJtaXRCdXR0b24gPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoJy5idG4tc2F2ZScpXG4gICAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGZvcm0ucXVlcnlTZWxlY3RvcignLmJ0bi1jYW5jZWwnKVxuXG4gICAgICAgIC8vIExvYWQgdGhlIHNwaW5uZXIgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgaWYgKHN1Ym1pdEJ1dHRvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaHRteC5vbihzdWJtaXRCdXR0b24sIFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bpbm5lciA9IGNyZWF0ZVNwaW5uZXIoKVxuICAgICAgICAgICAgICAgIHN1Ym1pdEJ1dHRvbi5hZnRlcihzcGlubmVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIGJ1dHRvbnMgYWZ0ZXIgSFRNWCBoYXMgc3RhcnRlZCwgYnV0IGJlZm9yZSB0aGUgWEhSIHJlcXVlc3QgaXNcbiAgICAgICAgLy8gZGlzcGF0Y2hlZC4gRG9pbmcgdGhpcyBvbiB0aGUgJ2NsaWNrJyBldmVudCBibG9ja3MgdHJpZ2dlcmluZyB0aGUgSFRNWCBsaWZlY3ljbGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JpZ3NreXNvZnR3YXJlL2h0bXgvaXNzdWVzLzM5NFxuICAgICAgICBodG14Lm9uKFwiaHRteDpiZWZvcmVSZXF1ZXN0XCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgc3VibWl0QnV0dG9uLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBBZnRlciBzdWJtaXNzaW9uLCBhdXRvLWRpc21pc3MgYWxsIGFsZXJ0cyBhZnRlciAxMCBzZWNvbmRzLlxuICAgIC8vIFRPRE86IGlmIDIgY29uc2VjdXRpdmUgc2F2ZSBhY3Rpb25zIGhhcHBlbiB3aXRoaW4gdGhlIDEwIHNlY29uZCBpbnRlcnZhbCxcbiAgICAvLyAgICB0aGUgZmlyc3QgZGlzcGxheWVkIGFsZXJ0IHdpbGwgYmUgZGVzdHJveWVkIGJ5IEhUTVgsIGNhdXNpbmcgdGhlIHNldFRpbWVvdXRcbiAgICAvLyAgICB0byB0cmlnZ2VyIGEgcnVudGltZSBlcnJvciBhcyBpdCB0cmllcyB0byBhcHBseSBhIEJTTi5hbGVydCBvbiBhIG5vbi1leGlzdGluZ1xuICAgIC8vICAgIGVsZW1lbnQuXG4gICAgLy8gZnVuY3Rpb24gY2xvc2VBbGVydHMoKSB7XG4gICAgLy8gICAgIGxldCBhbGVydHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWxlcnQnKVxuICAgIC8vICAgICBhbGVydHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAvLyAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vICAgICAgICAgICAgIGxldCBhbGVydCA9IG5ldyBCU04uQWxlcnQoZWwpXG4gICAgLy8gICAgICAgICAgICAgYWxlcnQuY2xvc2UoKVxuICAgIC8vICAgICAgICAgfSwgMTAwMDApXG4gICAgLy8gICAgIH0pXG4gICAgLy8gfVxuXG4gICAgLy8gSW5pdCBldmVudCBsaXN0ZW5lcnMgd2hlbmV2ZXIgSFRNWCBzd2FwcyBpbiBhIGNhcmQtY29sbGFwc2libGUgaGF2aW5nIGEgZm9ybSBlbGVtZW50LlxuICAgIGh0bXgub24oXCJodG14OmFmdGVyU2V0dGxlXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBsZXQgaXRlbSA9IGV2dC5kZXRhaWwudGFyZ2V0LmNoaWxkcmVuLml0ZW0oMClcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5ub2RlTmFtZSAmJiAoaXRlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgZm9ybVN1Ym1pdChpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2xvc2VBbGVydHMoKVxuICAgICAgICB9XG4gICAgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/ui/form_submit.js\n");

/***/ }),

/***/ "./assets/js/ui/modal_close.js":
/*!*************************************!*\
  !*** ./assets/js/ui/modal_close.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n // Set an event handler on any buttons that have the 'modal-close' class.\n// This ensures that any and all modals can be closed via 'close', 'cancel', etc. buttons.\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var modalClose = function modalClose(e) {\n    var modal = document.querySelectorAll(\".modal\").item(0);\n    var backdrop = document.querySelectorAll(\".modal-backdrop\").item(0);\n\n    if (modal) {\n      modal.classList.remove(\"show\");\n    }\n\n    if (backdrop) {\n      backdrop.classList.remove(\"show\");\n    } // Timeout gives us a fluid animation\n\n\n    setTimeout(function () {\n      if (backdrop) {\n        backdrop.remove();\n      }\n\n      if (modal) {\n        modal.remove();\n      }\n    }, 100);\n  }; // Close the modal after the item was deleted from the backend.\n  //\n  // If we tried to add the modal-close class directly to the \"confirm\" button\n  // on a confirmation button, the modal would be removed from the DOM before\n  // the itemDeleted event could be triggered. Without the modal nodes present\n  // in the DOM, the event won't be registered correctly by HTMX. As a result,\n  // other triggers listening for the event won't execute. Instead, we\n  // use the event itself as a trigger for the modal to close.\n\n\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"ITRemoveItem\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"PublicationCreateAbstract\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"PublicationUpdateAbstract\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"PublicationRemoveAbstract\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"PublicationCreateLink\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"PublicationUpdateLink\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"PublicationRemoveLink\", function (evt) {\n    modalClose();\n  });\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    var container = evt.detail.target;\n\n    if (container.classList.contains(\"modals\")) {\n      container.querySelectorAll(\".modal-close\").forEach(function (el) {\n        el.addEventListener(\"click\", modalClose);\n      });\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvbW9kYWxfY2xvc2UuanM/ZmZkYyJdLCJuYW1lcyI6WyJtb2RhbENsb3NlIiwiZSIsIm1vZGFsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaXRlbSIsImJhY2tkcm9wIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwic2V0VGltZW91dCIsImh0bXgiLCJldnQiLCJjb250YWluZXIiLCJkZXRhaWwiLCJ0YXJnZXQiLCJjb250YWlucyIsImZvckVhY2giLCJlbCIsImFkZEV2ZW50TGlzdGVuZXIiXSwibWFwcGluZ3MiOiI7Ozs7OztDQUVBO0FBQ0E7O0FBQ0EsNkJBQWUsc0NBQVc7QUFDdEIsTUFBSUEsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBU0MsQ0FBVCxFQUFZO0FBQ3pCLFFBQUlDLEtBQUssR0FBR0MsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixRQUExQixFQUFvQ0MsSUFBcEMsQ0FBeUMsQ0FBekMsQ0FBWjtBQUNBLFFBQUlDLFFBQVEsR0FBR0gsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixpQkFBMUIsRUFBNkNDLElBQTdDLENBQWtELENBQWxELENBQWY7O0FBRUEsUUFBSUgsS0FBSixFQUFXO0FBQ1BBLFdBQUssQ0FBQ0ssU0FBTixDQUFnQkMsTUFBaEIsQ0FBdUIsTUFBdkI7QUFDSDs7QUFFRCxRQUFJRixRQUFKLEVBQWM7QUFDVkEsY0FBUSxDQUFDQyxTQUFULENBQW1CQyxNQUFuQixDQUEwQixNQUExQjtBQUNILEtBVndCLENBWXpCOzs7QUFDQUMsY0FBVSxDQUFDLFlBQVc7QUFDbEIsVUFBSUgsUUFBSixFQUFjO0FBQ1ZBLGdCQUFRLENBQUNFLE1BQVQ7QUFDSDs7QUFFRCxVQUFJTixLQUFKLEVBQVc7QUFDUEEsYUFBSyxDQUFDTSxNQUFOO0FBQ0g7QUFDSixLQVJTLEVBUVAsR0FSTyxDQUFWO0FBU0gsR0F0QkQsQ0FEc0IsQ0F5QnRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBRSxvREFBQSxDQUFRLGNBQVIsRUFBd0IsVUFBU0MsR0FBVCxFQUFjO0FBQ2xDWCxjQUFVO0FBQ2IsR0FGRDtBQUlBVSxvREFBQSxDQUFRLDJCQUFSLEVBQXFDLFVBQVNDLEdBQVQsRUFBYztBQUMvQ1gsY0FBVTtBQUNiLEdBRkQ7QUFJQVUsb0RBQUEsQ0FBUSwyQkFBUixFQUFxQyxVQUFTQyxHQUFULEVBQWM7QUFDL0NYLGNBQVU7QUFDYixHQUZEO0FBSUFVLG9EQUFBLENBQVEsMkJBQVIsRUFBcUMsVUFBU0MsR0FBVCxFQUFjO0FBQy9DWCxjQUFVO0FBQ2IsR0FGRDtBQUlBVSxvREFBQSxDQUFRLHVCQUFSLEVBQWlDLFVBQVNDLEdBQVQsRUFBYztBQUMzQ1gsY0FBVTtBQUNiLEdBRkQ7QUFJQVUsb0RBQUEsQ0FBUSx1QkFBUixFQUFpQyxVQUFTQyxHQUFULEVBQWM7QUFDM0NYLGNBQVU7QUFDYixHQUZEO0FBSUFVLG9EQUFBLENBQVEsdUJBQVIsRUFBaUMsVUFBU0MsR0FBVCxFQUFjO0FBQzNDWCxjQUFVO0FBQ2IsR0FGRDtBQUlBVSxvREFBQSxDQUFRLGtCQUFSLEVBQTRCLFVBQVNDLEdBQVQsRUFBYztBQUN0QyxRQUFJQyxTQUFTLEdBQUdELEdBQUcsQ0FBQ0UsTUFBSixDQUFXQyxNQUEzQjs7QUFDQSxRQUFJRixTQUFTLENBQUNMLFNBQVYsQ0FBb0JRLFFBQXBCLENBQTZCLFFBQTdCLENBQUosRUFBNEM7QUFDeENILGVBQVMsQ0FBQ1IsZ0JBQVYsQ0FBMkIsY0FBM0IsRUFBMkNZLE9BQTNDLENBQW9ELFVBQVVDLEVBQVYsRUFBYztBQUM5REEsVUFBRSxDQUFDQyxnQkFBSCxDQUFvQixPQUFwQixFQUE2QmxCLFVBQTdCO0FBQ0gsT0FGRDtBQUdIO0FBQ0osR0FQRDtBQVFIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL21vZGFsX2Nsb3NlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0bXggZnJvbSAnaHRteC5vcmcnO1xuXG4vLyBTZXQgYW4gZXZlbnQgaGFuZGxlciBvbiBhbnkgYnV0dG9ucyB0aGF0IGhhdmUgdGhlICdtb2RhbC1jbG9zZScgY2xhc3MuXG4vLyBUaGlzIGVuc3VyZXMgdGhhdCBhbnkgYW5kIGFsbCBtb2RhbHMgY2FuIGJlIGNsb3NlZCB2aWEgJ2Nsb3NlJywgJ2NhbmNlbCcsIGV0Yy4gYnV0dG9ucy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICAgIGxldCBtb2RhbENsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBsZXQgbW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm1vZGFsXCIpLml0ZW0oMClcbiAgICAgICAgbGV0IGJhY2tkcm9wID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5tb2RhbC1iYWNrZHJvcFwiKS5pdGVtKDApXG5cbiAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGltZW91dCBnaXZlcyB1cyBhIGZsdWlkIGFuaW1hdGlvblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3AucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDApXG4gICAgfVxuXG4gICAgLy8gQ2xvc2UgdGhlIG1vZGFsIGFmdGVyIHRoZSBpdGVtIHdhcyBkZWxldGVkIGZyb20gdGhlIGJhY2tlbmQuXG4gICAgLy9cbiAgICAvLyBJZiB3ZSB0cmllZCB0byBhZGQgdGhlIG1vZGFsLWNsb3NlIGNsYXNzIGRpcmVjdGx5IHRvIHRoZSBcImNvbmZpcm1cIiBidXR0b25cbiAgICAvLyBvbiBhIGNvbmZpcm1hdGlvbiBidXR0b24sIHRoZSBtb2RhbCB3b3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIERPTSBiZWZvcmVcbiAgICAvLyB0aGUgaXRlbURlbGV0ZWQgZXZlbnQgY291bGQgYmUgdHJpZ2dlcmVkLiBXaXRob3V0IHRoZSBtb2RhbCBub2RlcyBwcmVzZW50XG4gICAgLy8gaW4gdGhlIERPTSwgdGhlIGV2ZW50IHdvbid0IGJlIHJlZ2lzdGVyZWQgY29ycmVjdGx5IGJ5IEhUTVguIEFzIGEgcmVzdWx0LFxuICAgIC8vIG90aGVyIHRyaWdnZXJzIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IHdvbid0IGV4ZWN1dGUuIEluc3RlYWQsIHdlXG4gICAgLy8gdXNlIHRoZSBldmVudCBpdHNlbGYgYXMgYSB0cmlnZ2VyIGZvciB0aGUgbW9kYWwgdG8gY2xvc2UuXG4gICAgaHRteC5vbihcIklUUmVtb3ZlSXRlbVwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbW9kYWxDbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaHRteC5vbihcIlB1YmxpY2F0aW9uQ3JlYXRlQWJzdHJhY3RcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIG1vZGFsQ2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGh0bXgub24oXCJQdWJsaWNhdGlvblVwZGF0ZUFic3RyYWN0XCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBtb2RhbENsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBodG14Lm9uKFwiUHVibGljYXRpb25SZW1vdmVBYnN0cmFjdFwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbW9kYWxDbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaHRteC5vbihcIlB1YmxpY2F0aW9uQ3JlYXRlTGlua1wiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbW9kYWxDbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaHRteC5vbihcIlB1YmxpY2F0aW9uVXBkYXRlTGlua1wiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbW9kYWxDbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaHRteC5vbihcIlB1YmxpY2F0aW9uUmVtb3ZlTGlua1wiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbW9kYWxDbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaHRteC5vbihcImh0bXg6YWZ0ZXJTZXR0bGVcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBldnQuZGV0YWlsLnRhcmdldFxuICAgICAgICBpZiAoY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcIm1vZGFsc1wiKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubW9kYWwtY2xvc2VcIikuZm9yRWFjaCggZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG1vZGFsQ2xvc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/js/ui/modal_close.js\n");

/***/ }),

/***/ "./assets/js/ui/modal_popper.js":
/*!**************************************!*\
  !*** ./assets/js/ui/modal_popper.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! popper.js */ \"./node_modules/popper.js/dist/esm/popper.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n\n // Wire in popper.js support. This ensure popups stay within the viewport.\n//\n// Bootstrap Native doesn't incorporate Popper.js. We have to wire everything ourselves.\n// See: https://github.com/thednp/bootstrap.native/issues/211\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var popper = function popper() {\n    document.querySelectorAll(\"div.dropdown > button\").forEach(function (button) {\n      button.addEventListener(\"click\", function (evt) {\n        var menu = button.parentElement.children.item(1);\n\n        if (menu.classList.contains(\"show\")) {\n          menu.removeAttribute(\"x-placement\");\n          menu.removeAttribute(\"style\");\n\n          var _popper = new popper_js__WEBPACK_IMPORTED_MODULE_1__.default(button, menu, {\n            modifiers: {\n              preventOverflow: {\n                enabled: true\n              },\n              flip: {\n                enabled: true\n              },\n              hide: {\n                enabled: false\n              }\n            }\n          });\n        }\n      });\n    });\n  };\n\n  popper();\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    popper();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvbW9kYWxfcG9wcGVyLmpzP2U1ZWEiXSwibmFtZXMiOlsicG9wcGVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImJ1dHRvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldnQiLCJtZW51IiwicGFyZW50RWxlbWVudCIsImNoaWxkcmVuIiwiaXRlbSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwicmVtb3ZlQXR0cmlidXRlIiwiUG9wcGVyIiwibW9kaWZpZXJzIiwicHJldmVudE92ZXJmbG93IiwiZW5hYmxlZCIsImZsaXAiLCJoaWRlIiwiaHRteCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0NBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsNkJBQWUsc0NBQVc7QUFDdEIsTUFBSUEsTUFBTSxHQUFHLFNBQVRBLE1BQVMsR0FBVztBQUNwQkMsWUFBUSxDQUFDQyxnQkFBVCxDQUEwQix1QkFBMUIsRUFBbURDLE9BQW5ELENBQTJELFVBQVNDLE1BQVQsRUFBaUI7QUFDeEVBLFlBQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUMsVUFBU0MsR0FBVCxFQUFjO0FBQzNDLFlBQUlDLElBQUksR0FBR0gsTUFBTSxDQUFDSSxhQUFQLENBQXFCQyxRQUFyQixDQUE4QkMsSUFBOUIsQ0FBbUMsQ0FBbkMsQ0FBWDs7QUFFQSxZQUFJSCxJQUFJLENBQUNJLFNBQUwsQ0FBZUMsUUFBZixDQUF3QixNQUF4QixDQUFKLEVBQXFDO0FBQ2pDTCxjQUFJLENBQUNNLGVBQUwsQ0FBcUIsYUFBckI7QUFDQU4sY0FBSSxDQUFDTSxlQUFMLENBQXFCLE9BQXJCOztBQUVBLGNBQUliLE9BQU0sR0FBRyxJQUFJYyw4Q0FBSixDQUFXVixNQUFYLEVBQW1CRyxJQUFuQixFQUF5QjtBQUNsQ1EscUJBQVMsRUFBRTtBQUNQQyw2QkFBZSxFQUFFO0FBQUVDLHVCQUFPLEVBQUU7QUFBWCxlQURWO0FBRVBDLGtCQUFJLEVBQUU7QUFBRUQsdUJBQU8sRUFBRTtBQUFYLGVBRkM7QUFHUEUsa0JBQUksRUFBRTtBQUFFRix1QkFBTyxFQUFFO0FBQVg7QUFIQztBQUR1QixXQUF6QixDQUFiO0FBT0g7QUFDSixPQWZEO0FBZ0JILEtBakJEO0FBa0JILEdBbkJEOztBQXFCQWpCLFFBQU07QUFFTm9CLG9EQUFBLENBQVEsa0JBQVIsRUFBNEIsVUFBU2QsR0FBVCxFQUFjO0FBQ3RDTixVQUFNO0FBQ1QsR0FGRDtBQUlIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL21vZGFsX3BvcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJ1xuaW1wb3J0IGh0bXggZnJvbSAnaHRteC5vcmcnO1xuXG4vLyBXaXJlIGluIHBvcHBlci5qcyBzdXBwb3J0LiBUaGlzIGVuc3VyZSBwb3B1cHMgc3RheSB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuLy9cbi8vIEJvb3RzdHJhcCBOYXRpdmUgZG9lc24ndCBpbmNvcnBvcmF0ZSBQb3BwZXIuanMuIFdlIGhhdmUgdG8gd2lyZSBldmVyeXRoaW5nIG91cnNlbHZlcy5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2lzc3Vlcy8yMTFcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICAgIGxldCBwb3BwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImRpdi5kcm9wZG93biA+IGJ1dHRvblwiKS5mb3JFYWNoKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVudSA9IGJ1dHRvbi5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLml0ZW0oMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWVudS5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbnUucmVtb3ZlQXR0cmlidXRlKFwieC1wbGFjZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lbnUucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcHBlciA9IG5ldyBQb3BwZXIoYnV0dG9uLCBtZW51LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsaXA6IHsgZW5hYmxlZDogdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogeyBlbmFibGVkOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcG9wcGVyKCk7XG5cbiAgICBodG14Lm9uKFwiaHRteDphZnRlclNldHRsZVwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcG9wcGVyKCk7XG4gICAgfSk7XG5cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/js/ui/modal_popper.js\n");

/***/ }),

/***/ "./assets/js/ui/multi_select.js":
/*!**************************************!*\
  !*** ./assets/js/ui/multi_select.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*!\n * IconicMultiSelect v0.7.0\n * Licence:  MIT\n * (c) 2021 Sidney Wimart.\n *\n * See: https://github.com/sidneywm/iconic-multiselect\n *\n * This is plugin is installed manually since no package on NPM exists.\n */\n\n/**\n * @version IconicMultiSelect v0.7.0\n * @licence  MIT\n */\n\nvar IconicMultiSelect = /*#__PURE__*/function () {\n  /**\n   * Iconic Multiselect constructor.\n   * @param { Object[] } data - Array of objects.\n   * @param { string } noData - Defines the message when there is no data input.\n   * @param { string } noResults - Defines the message when there is no result if options are filtered.\n   * @param { string } placeholder -  Defines the placeholder's text.\n   * @param { string } select - DOM element to be selected. It must be a HTML Select tag - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select\n   * @param { string } textField - Field to select in the object for the text.\n   * @param { string } valueField - Field to select in the object for the value.\n   */\n  function IconicMultiSelect(_ref) {\n    var data = _ref.data,\n        itemTemplate = _ref.itemTemplate,\n        noData = _ref.noData,\n        noResults = _ref.noResults,\n        placeholder = _ref.placeholder,\n        select = _ref.select,\n        tagTemplate = _ref.tagTemplate,\n        textField = _ref.textField,\n        valueField = _ref.valueField;\n\n    _classCallCheck(this, IconicMultiSelect);\n\n    _defineProperty(this, \"_data\", void 0);\n\n    _defineProperty(this, \"_domElements\", void 0);\n\n    _defineProperty(this, \"_event\", function () {});\n\n    _defineProperty(this, \"_itemTemplate\", void 0);\n\n    _defineProperty(this, \"_multiselect\", void 0);\n\n    _defineProperty(this, \"_noData\", void 0);\n\n    _defineProperty(this, \"_noResults\", void 0);\n\n    _defineProperty(this, \"_options\", []);\n\n    _defineProperty(this, \"_placeholder\", void 0);\n\n    _defineProperty(this, \"_select\", void 0);\n\n    _defineProperty(this, \"_selectContainer\", void 0);\n\n    _defineProperty(this, \"_selectedOptions\", []);\n\n    _defineProperty(this, \"_tagTemplate\", void 0);\n\n    _defineProperty(this, \"_textField\", void 0);\n\n    _defineProperty(this, \"_valueField\", void 0);\n\n    _defineProperty(this, \"_cross\", \"\\n      <svg\\n        width=\\\"24\\\"\\n        height=\\\"24\\\"\\n        viewBox=\\\"0 0 24 24\\\"\\n        fill=\\\"none\\\"\\n        xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n      >\\n        <path\\n          d=\\\"M6.2253 4.81108C5.83477 4.42056 5.20161 4.42056 4.81108 4.81108C4.42056 5.20161 4.42056 5.83477 4.81108 6.2253L10.5858 12L4.81114 17.7747C4.42062 18.1652 4.42062 18.7984 4.81114 19.1889C5.20167 19.5794 5.83483 19.5794 6.22535 19.1889L12 13.4142L17.7747 19.1889C18.1652 19.5794 18.7984 19.5794 19.1889 19.1889C19.5794 18.7984 19.5794 18.1652 19.1889 17.7747L13.4142 12L19.189 6.2253C19.5795 5.83477 19.5795 5.20161 19.189 4.81108C18.7985 4.42056 18.1653 4.42056 17.7748 4.81108L12 10.5858L6.2253 4.81108Z\\\"\\n          fill=\\\"currentColor\\\"\\n        />\\n      </svg>\\n      \");\n\n    this._data = data !== null && data !== void 0 ? data : [];\n    this._itemTemplate = itemTemplate !== null && itemTemplate !== void 0 ? itemTemplate : null;\n    this._noData = noData !== null && noData !== void 0 ? noData : \"No data found.\";\n    this._noResults = noResults !== null && noResults !== void 0 ? noResults : \"No results found.\";\n    this._placeholder = placeholder !== null && placeholder !== void 0 ? placeholder : \"Select...\";\n    this._select = select;\n    this._selectContainer = document.querySelector(select);\n    this._tagTemplate = tagTemplate !== null && tagTemplate !== void 0 ? tagTemplate : null;\n    this._textField = textField !== null && textField !== void 0 ? textField : null;\n    this._valueField = valueField !== null && valueField !== void 0 ? valueField : null;\n  }\n  /**\n   * Initialize the Iconic Multiselect component.\n   * @public\n   */\n\n\n  _createClass(IconicMultiSelect, [{\n    key: \"init\",\n    value: function init() {\n      if (this._selectContainer && this._selectContainer.nodeName === \"SELECT\") {\n        if (this._itemTemplate && this._data.length === 0) throw new Error(\"itemTemplate must be initialized with data from the component settings\");\n        if (this._tagTemplate && this._data.length === 0) throw new Error(\"tagTemplate must be initialized with data from the component settings\");\n        this._options = this._data.length > 0 ? this._getDataFromSettings() : this._getDataFromSelectTag();\n\n        this._renderMultiselect();\n\n        this._renderOptionsList();\n\n        this._domElements = {\n          clear: this._multiselect.querySelector(\".multiselect__clear-btn\"),\n          input: this._multiselect.querySelector(\".multiselect__input\"),\n          optionsContainer: this._multiselect.querySelector(\".multiselect__options\"),\n          optionsContainerList: this._multiselect.querySelector(\".multiselect__options > ul\"),\n          options: {\n            list: this._multiselect.querySelectorAll(\".multiselect__options > ul > li\"),\n            find: function find(callbackFn) {\n              for (var i = 0; i < this.list.length; i++) {\n                var node = this.list[i];\n                if (callbackFn(node)) return node;\n              }\n\n              return undefined;\n            },\n            some: function some(callbackFn) {\n              for (var i = 0; i < this.list.length; i++) {\n                var node = this.list[i];\n                if (callbackFn(node, i)) return true;\n              }\n\n              return false;\n            }\n          }\n        };\n\n        this._enableEventListenners();\n\n        this._initSelectedList();\n      } else {\n        throw new Error(\"The selector '\".concat(this._select, \"' did not select any valid select tag.\"));\n      }\n    }\n    /**\n     * Subscribes to the emitted events.\n     * @param { Function } callback - Callback function which emits a custom event object.\n     * @public\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      if (typeof callback === \"function\") {\n        this._event = callback;\n      } else {\n        throw new Error(\"parameter in the subscribe method is not a function\");\n      }\n    }\n    /**\n     * Add an option to the selection list.\n     * @param { Object: { text: string; value: string; }} option\n     * @private\n     */\n\n  }, {\n    key: \"_addOptionToList\",\n    value: function _addOptionToList(option, index) {\n      var _this = this;\n\n      var html = \"<span class=\\\"multiselect__selected\\\" data-value=\\\"\".concat(option.value, \"\\\">\").concat(this._tagTemplate ? this._processTemplate(this._tagTemplate, index) : option.text, \"<span class=\\\"multiselect__remove-btn\\\">\").concat(this._cross, \"</span></span>\");\n\n      this._domElements.input.insertAdjacentHTML(\"beforebegin\", html);\n\n      var _this$_multiselect$qu = this._multiselect.querySelector(\"span[data-value=\\\"\".concat(option.value, \"\\\"]\")),\n          removeBtn = _this$_multiselect$qu.lastElementChild;\n\n      removeBtn.addEventListener(\"click\", function () {\n        var target = _this._domElements.options.find(function (el) {\n          return el.dataset.value == option.value;\n        });\n\n        _this._handleOption(target);\n      });\n    }\n    /**\n     * Clears all selected options.\n     * @private\n     */\n\n  }, {\n    key: \"_clearSelection\",\n    value: function _clearSelection() {\n      var _this2 = this;\n\n      var _loop = function _loop(i) {\n        var option = _this2._selectedOptions[i];\n\n        var target = _this2._domElements.options.find(function (el) {\n          return el.dataset.value == option.value;\n        });\n\n        target.classList.remove(\"multiselect__options--selected\");\n\n        _this2._removeOptionFromList(target.dataset.value);\n      };\n\n      for (var i = 0; i < this._selectedOptions.length; i++) {\n        _loop(i);\n      }\n\n      this._selectedOptions = [];\n\n      this._handleClearSelectionBtn();\n\n      this._handlePlaceholder();\n\n      this._dispatchEvent({\n        action: \"CLEAR_ALL_OPTIONS\",\n        selection: this._selectedOptions\n      });\n    }\n    /**\n     * Close the options container.\n     * @private\n     */\n\n  }, {\n    key: \"_closeList\",\n    value: function _closeList() {\n      this._domElements.input.value = \"\";\n\n      this._domElements.optionsContainer.classList.remove(\"visible\");\n\n      this._filterOptions(\"\");\n\n      this._removeAllArrowSelected();\n    }\n    /**\n     * Dispatches new events.\n     * @param { object : { action: string; selection: { option: string; text: string; }[]; value?: string; } } event\n     * @private\n     */\n\n  }, {\n    key: \"_dispatchEvent\",\n    value: function _dispatchEvent(event) {\n      this._event(event);\n    }\n    /**\n     * Enables all main event listenners.\n     * @private\n     */\n\n  }, {\n    key: \"_enableEventListenners\",\n    value: function _enableEventListenners() {\n      var _this3 = this;\n\n      document.addEventListener(\"mouseup\", function (_ref2) {\n        var target = _ref2.target;\n\n        if (!_this3._multiselect.contains(target)) {\n          _this3._filterOptions(\"\");\n\n          _this3._closeList();\n\n          _this3._handlePlaceholder();\n        }\n      });\n\n      this._domElements.clear.addEventListener(\"click\", function () {\n        _this3._clearSelection();\n      });\n\n      for (var i = 0; i < this._domElements.options.list.length; i++) {\n        var option = this._domElements.options.list[i];\n        option.addEventListener(\"click\", function (_ref3) {\n          var target = _ref3.target;\n\n          _this3._handleOption(target);\n\n          _this3._closeList();\n        });\n      }\n\n      this._domElements.input.addEventListener(\"focus\", function () {\n        _this3._domElements.optionsContainer.classList.add(\"visible\");\n\n        _this3._domElements.input.placeholder = \"\";\n      });\n\n      this._domElements.input.addEventListener(\"input\", function (_ref4) {\n        var value = _ref4.target.value;\n\n        if (_this3._domElements.options.list.length > 0) {\n          _this3._filterOptions(value);\n        }\n      });\n\n      this._domElements.input.addEventListener(\"keydown\", function (e) {\n        _this3._handleArrows(e);\n\n        _this3._handleBackspace(e);\n\n        _this3._handleEnter(e);\n      });\n    }\n    /**\n     * Filters user input.\n     * @param { string } value\n     * @private\n     */\n\n  }, {\n    key: \"_filterOptions\",\n    value: function _filterOptions(value) {\n      var _this4 = this;\n\n      var isOpen = this._domElements.optionsContainer.classList.contains(\"visible\");\n\n      var valueLowerCase = value.toLowerCase();\n\n      if (!isOpen && value.length > 0) {\n        this._domElements.optionsContainer.classList.add(\"visible\");\n      }\n\n      if (this._domElements.options.list.length > 0) {\n        for (var i = 0; i < this._domElements.options.list.length; i++) {\n          var el = this._domElements.options.list[i];\n          var text = this._itemTemplate ? this._data[i][this._textField] : el.textContent;\n\n          if (text.toLowerCase().substring(0, valueLowerCase.length) === valueLowerCase) {\n            this._domElements.optionsContainerList.appendChild(el);\n          } else {\n            el.parentNode && el.parentNode.removeChild(el);\n          }\n        }\n\n        var hasResults = this._domElements.options.some(function (el, index) {\n          return (_this4._itemTemplate ? _this4._data[index][_this4._textField] : el.textContent).toLowerCase().substring(0, valueLowerCase.length) === valueLowerCase;\n        });\n\n        this._showNoResults(!hasResults);\n      }\n    }\n  }, {\n    key: \"_generateId\",\n    value: function _generateId(length) {\n      var result = \"\";\n      var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n      var charactersLength = characters.length;\n\n      for (var i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n      }\n\n      return result;\n    }\n    /**\n     * Gets data from select tag.\n     * @private\n     */\n\n  }, {\n    key: \"_getDataFromSelectTag\",\n    value: function _getDataFromSelectTag() {\n      var arr = [];\n      var options = this._selectContainer.options;\n\n      for (var i = 0; i < options.length; i++) {\n        var item = options[i];\n        arr.push({\n          text: item.text,\n          value: item.value,\n          selected: item.hasAttribute('selected')\n        });\n      }\n\n      return arr;\n    }\n    /**\n     * Gets data from settings.\n     * @private\n     */\n\n  }, {\n    key: \"_getDataFromSettings\",\n    value: function _getDataFromSettings() {\n      if (this._data.length > 0 && this._valueField && this._textField) {\n        var isValueFieldValid = typeof this._valueField === \"string\";\n        var isTextFieldValid = typeof this._textField === \"string\";\n        var arr = [];\n\n        if (!isValueFieldValid || !isTextFieldValid) {\n          throw new Error(\"textField and valueField must be of type string\");\n        }\n\n        for (var i = 0; i < this._data.length; i++) {\n          var item = this._data[i];\n          arr.push({\n            value: item[this._valueField],\n            text: item[this._textField],\n            selected: typeof item.selected === \"boolean\" ? item.selected : false\n          });\n        }\n\n        return arr;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Handles Arrow up & Down. Selection of an option is also possible with these keys.\n     * @param { Event } event\n     * @private\n     */\n\n  }, {\n    key: \"_handleArrows\",\n    value: function _handleArrows(event) {\n      if (event.keyCode === 40 || event.keyCode === 38) {\n        event.preventDefault();\n\n        var isOpen = this._domElements.optionsContainer.classList.contains(\"visible\"); // An updated view of the container is needed because of the filtering option\n\n\n        var optionsContainerList = this._multiselect.querySelector(\".multiselect__options > ul\");\n\n        if (!isOpen) {\n          this._domElements.optionsContainer.classList.add(\"visible\");\n\n          optionsContainerList.firstElementChild.classList.add(\"arrow-selected\");\n          optionsContainerList.firstElementChild.scrollIntoView(false);\n        } else {\n          var selected = this._multiselect.querySelector(\".multiselect__options ul li.arrow-selected\");\n\n          var action = {\n            ArrowUp: \"previous\",\n            Up: \"previous\",\n            ArrowDown: \"next\",\n            Down: \"next\"\n          };\n\n          if (!selected) {\n            optionsContainerList.firstElementChild.classList.add(\"arrow-selected\");\n            optionsContainerList.firstElementChild.scrollIntoView(false);\n            return;\n          }\n\n          selected.classList.remove(\"arrow-selected\");\n          selected = selected[action[event.key] + \"ElementSibling\"]; // Go to start or end of the popup list\n\n          if (!selected) {\n            selected = optionsContainerList.children[action[event.key] === \"next\" ? 0 : optionsContainerList.children.length - 1];\n            selected.classList.add(\"arrow-selected\");\n\n            this._scrollIntoView(optionsContainerList, selected);\n\n            return;\n          }\n\n          selected.classList.add(\"arrow-selected\");\n\n          this._scrollIntoView(optionsContainerList, selected);\n        }\n      }\n    }\n    /**\n     * Handles the backspace key event - Deletes the preceding option in the selection list.\n     * @param { Event } e\n     * @private\n     */\n\n  }, {\n    key: \"_handleBackspace\",\n    value: function _handleBackspace(e) {\n      if (e.keyCode === 8 && e.target.value === \"\") {\n        var lastSelectedOption = this._selectedOptions.length > 0 ? this._selectedOptions[this._selectedOptions.length - 1] : null;\n\n        if (lastSelectedOption) {\n          var targetLastSelectedOption = this._multiselect.querySelector(\"li[data-value=\\\"\".concat(lastSelectedOption.value, \"\\\"]\"));\n\n          this._handleOption(targetLastSelectedOption);\n\n          if (this._selectedOptions.length === 0) {\n            this._domElements.optionsContainer.classList.remove(\"visible\");\n          }\n        }\n      }\n    }\n    /**\n     * Shows clear selection button if some options are selected.\n     * @private\n     */\n\n  }, {\n    key: \"_handleClearSelectionBtn\",\n    value: function _handleClearSelectionBtn() {\n      if (this._selectedOptions.length > 0) {\n        this._domElements.clear.style.display = \"flex\";\n      } else {\n        this._domElements.clear.style.display = \"none\";\n      }\n    }\n    /**\n     * Handles the enter key event.\n     * @param { Event } event\n     * @private\n     */\n\n  }, {\n    key: \"_handleEnter\",\n    value: function _handleEnter(event) {\n      if (event.keyCode === 13) {\n        var selected = this._multiselect.querySelector(\".multiselect__options ul li.arrow-selected\");\n\n        if (selected) {\n          this._handleOption(selected);\n\n          this._closeList();\n        }\n      }\n    }\n  }, {\n    key: \"_handleOption\",\n    value: function _handleOption(target) {\n      var dispatchEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Remove\n      for (var i = 0; i < this._selectedOptions.length; i++) {\n        var el = this._selectedOptions[i];\n\n        if (el.value == target.dataset.value) {\n          target.classList.remove(\"multiselect__options--selected\");\n\n          this._selectedOptions.splice(i, 1);\n\n          this._removeOptionFromList(target.dataset.value);\n\n          this._handleClearSelectionBtn();\n\n          this._handlePlaceholder();\n\n          return dispatchEvent && this._dispatchEvent({\n            action: \"REMOVE_OPTION\",\n            value: target.dataset.value,\n            selection: this._selectedOptions\n          });\n        }\n      } // Add\n\n\n      for (var _i = 0; _i < this._options.length; _i++) {\n        var option = this._options[_i];\n\n        if (option.value == target.dataset.value) {\n          target.classList.add(\"multiselect__options--selected\");\n          this._selectedOptions = [].concat(_toConsumableArray(this._selectedOptions), [option]);\n\n          this._addOptionToList(option, _i);\n\n          this._handleClearSelectionBtn();\n\n          this._handlePlaceholder();\n\n          return dispatchEvent && this._dispatchEvent({\n            action: \"ADD_OPTION\",\n            value: target.dataset.value,\n            selection: this._selectedOptions\n          });\n        }\n      }\n    }\n    /**\n     * Shows the placeholder if no options are selected.\n     * @private\n     */\n\n  }, {\n    key: \"_handlePlaceholder\",\n    value: function _handlePlaceholder() {\n      if (this._selectedOptions.length > 0) {\n        this._domElements.input.placeholder = \"\";\n      } else {\n        this._domElements.input.placeholder = this._placeholder;\n      }\n    }\n  }, {\n    key: \"_initSelectedList\",\n    value: function _initSelectedList() {\n      var _this5 = this;\n\n      var hasItemsSelected = false;\n\n      var _loop2 = function _loop2(i) {\n        var option = _this5._options[i];\n\n        if (option.selected) {\n          hasItemsSelected = true;\n\n          var target = _this5._domElements.options.find(function (el) {\n            return el.dataset.value == option.value;\n          });\n\n          target.classList.add(\"multiselect__options--selected\");\n          _this5._selectedOptions = [].concat(_toConsumableArray(_this5._selectedOptions), [option]);\n\n          _this5._addOptionToList(option, i);\n        }\n      };\n\n      for (var i = 0; i < this._options.length; i++) {\n        _loop2(i);\n      }\n\n      if (hasItemsSelected) this._handleClearSelectionBtn();\n\n      this._handlePlaceholder();\n    }\n    /**\n     * Process the custom template.\n     * @param { string } template\n     * @private\n     */\n\n  }, {\n    key: \"_processTemplate\",\n    value: function _processTemplate(template, index) {\n      var processedTemplate = template;\n      var objAttr = template.match(/\\$\\{(\\w+)\\}/g).map(function (e) {\n        return e.replace(/\\$\\{|\\}/g, \"\");\n      });\n\n      for (var i = 0; i < objAttr.length; i++) {\n        var _this$_data$index$att;\n\n        var attr = objAttr[i];\n        processedTemplate = processedTemplate.replace(\"${\".concat(attr, \"}\"), (_this$_data$index$att = this._data[index][attr]) !== null && _this$_data$index$att !== void 0 ? _this$_data$index$att : \"\");\n      }\n\n      return processedTemplate;\n    }\n  }, {\n    key: \"_removeAllArrowSelected\",\n    value: function _removeAllArrowSelected() {\n      var className = \"arrow-selected\";\n\n      var target = this._domElements.options.find(function (el) {\n        return el.classList.contains(className);\n      });\n\n      target && target.classList.remove(className);\n    }\n    /**\n     * Removes an option from the list.\n     * @param { string } value\n     * @private\n     */\n\n  }, {\n    key: \"_removeOptionFromList\",\n    value: function _removeOptionFromList(value) {\n      var optionDom = this._multiselect.querySelector(\"span[data-value=\\\"\".concat(value, \"\\\"]\"));\n\n      optionDom && optionDom.parentNode && optionDom.parentNode.removeChild(optionDom);\n    }\n    /**\n     * Renders the multiselect options list view.\n     * @private\n     */\n\n  }, {\n    key: \"_renderOptionsList\",\n    value: function _renderOptionsList() {\n      var _this6 = this;\n\n      var html = \"\\n          <div class=\\\"multiselect__options\\\">\\n            <ul>\\n            \".concat(this._options.length > 0 && !this._itemTemplate ? this._options.map(function (option) {\n        return \"\\n                <li data-value=\\\"\".concat(option.value, \"\\\">\").concat(option.text, \"</li>\\n              \");\n      }).join(\"\") : \"\", \"\\n\\n            \").concat(this._options.length > 0 && this._itemTemplate ? this._options.map(function (option, index) {\n        return \"\\n                <li data-value=\\\"\".concat(option.value, \"\\\">\").concat(_this6._processTemplate(_this6._itemTemplate, index), \"</li>\\n              \");\n      }).join(\"\") : \"\", \"\\n            \").concat(this._showNoData(this._options.length === 0), \"\\n            </ul>\\n          </div>\\n        \");\n\n      this._multiselect.insertAdjacentHTML(\"beforeend\", html);\n    }\n    /**\n     * Renders the multiselect view.\n     * @private\n     */\n\n  }, {\n    key: \"_renderMultiselect\",\n    value: function _renderMultiselect() {\n      this._selectContainer.style.display = \"none\";\n\n      var id = \"iconic-\" + this._generateId(20);\n\n      var html = \"\\n        <div id=\\\"\".concat(id, \"\\\" class=\\\"multiselect__container\\\">\\n          <div class=\\\"multiselect__wrapper\\\">\\n            <input class=\\\"multiselect__input\\\" placeholder=\\\"\").concat(this._placeholder, \"\\\" />\\n          </div>\\n          <span style=\\\"display: none;\\\" class=\\\"multiselect__clear-btn\\\">\").concat(this._cross, \"</span>\\n        </div>\\n      \");\n\n      this._selectContainer.insertAdjacentHTML(\"afterend\", html);\n\n      this._multiselect = document.querySelector(\"#\".concat(id));\n    }\n    /**\n     * ScrollIntoView - This small utility reproduces the behavior of .scrollIntoView({ block: \"nearest\", inline: \"nearest\" })\n     * This is for IE compatibility without a need of a polyfill\n     * @private\n     */\n\n  }, {\n    key: \"_scrollIntoView\",\n    value: function _scrollIntoView(parent, child) {\n      var rectParent = parent.getBoundingClientRect();\n      var rectChild = child.getBoundingClientRect(); // Detect if not visible at top and then scroll to the top\n\n      if (!(rectParent.top < rectChild.bottom - child.offsetHeight)) {\n        parent.scrollTop = child.clientHeight + (child.offsetTop - child.offsetHeight);\n      } // Detect if not visible at bottom and then scroll to the bottom\n\n\n      if (!(rectParent.bottom > rectChild.top + child.offsetHeight)) {\n        parent.scrollTop = child.clientHeight + (child.offsetTop - child.offsetHeight) - (parent.offsetHeight - (child.offsetHeight + (child.offsetHeight - child.clientHeight)));\n      }\n    }\n    /**\n     * Shows a no data message.\n     * @param { boolean } condition\n     * @private\n     */\n\n  }, {\n    key: \"_showNoData\",\n    value: function _showNoData(condition) {\n      return condition ? \"<p class=\\\"multiselect__options--no-data\\\">\".concat(this._noData, \"</p>\") : \"\";\n    }\n    /**\n     * Shows a no results message.\n     * @param { boolean } condition\n     * @private\n     */\n\n  }, {\n    key: \"_showNoResults\",\n    value: function _showNoResults(condition) {\n      var dom = this._multiselect.querySelector(\".multiselect__options--no-results\");\n\n      if (condition) {\n        var html = \"<p class=\\\"multiselect__options--no-results\\\">\".concat(this._noResults, \"</p>\");\n        !dom && this._domElements.optionsContainerList.insertAdjacentHTML(\"beforeend\", html);\n      } else {\n        dom && dom.parentNode && dom.parentNode.removeChild(dom);\n      }\n    }\n  }]);\n\n  return IconicMultiSelect;\n}();\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  function setMultiSelect() {\n    document.querySelectorAll(\".custom-multi-select\").forEach(function (el) {\n      var iconicMultiSelectElement = new IconicMultiSelect({\n        select: \"#\" + el.id\n      }); // See: https://github.com/sidneywm/iconic-multiselect/issues/10\n\n      iconicMultiSelectElement.subscribe(function (evt) {\n        switch (evt.action) {\n          case 'ADD_OPTION':\n            for (var i = 0; i < iconicMultiSelectElement._selectContainer.options.length; i++) {\n              if (iconicMultiSelectElement._selectContainer.options[i].value == evt.value) {\n                iconicMultiSelectElement._selectContainer.options[i].selected = true;\n\n                iconicMultiSelectElement._selectContainer.options[i].setAttribute(\"selected\", \"\");\n              }\n            }\n\n            break;\n\n          case 'REMOVE_OPTION':\n            for (var _i2 = 0; _i2 < iconicMultiSelectElement._selectContainer.options.length; _i2++) {\n              if (iconicMultiSelectElement._selectContainer.options[_i2].value == evt.value) {\n                iconicMultiSelectElement._selectContainer.options[_i2].selected = false;\n\n                iconicMultiSelectElement._selectContainer.options[_i2].removeAttribute(\"selected\", \"\");\n              }\n            }\n\n            break;\n        }\n      });\n      iconicMultiSelectElement.init();\n    });\n  } // TODO\n  //   Disable the IconicMultiSelect for now. We're not allt hat\n  // setMultiSelect()\n  // htmx.on(\"htmx:afterSettle\", function(evt) {\n  //     setMultiSelect()\n  // });\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvbXVsdGlfc2VsZWN0LmpzP2YxNWQiXSwibmFtZXMiOlsiSWNvbmljTXVsdGlTZWxlY3QiLCJkYXRhIiwiaXRlbVRlbXBsYXRlIiwibm9EYXRhIiwibm9SZXN1bHRzIiwicGxhY2Vob2xkZXIiLCJzZWxlY3QiLCJ0YWdUZW1wbGF0ZSIsInRleHRGaWVsZCIsInZhbHVlRmllbGQiLCJfZGF0YSIsIl9pdGVtVGVtcGxhdGUiLCJfbm9EYXRhIiwiX25vUmVzdWx0cyIsIl9wbGFjZWhvbGRlciIsIl9zZWxlY3QiLCJfc2VsZWN0Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiX3RhZ1RlbXBsYXRlIiwiX3RleHRGaWVsZCIsIl92YWx1ZUZpZWxkIiwibm9kZU5hbWUiLCJsZW5ndGgiLCJFcnJvciIsIl9vcHRpb25zIiwiX2dldERhdGFGcm9tU2V0dGluZ3MiLCJfZ2V0RGF0YUZyb21TZWxlY3RUYWciLCJfcmVuZGVyTXVsdGlzZWxlY3QiLCJfcmVuZGVyT3B0aW9uc0xpc3QiLCJfZG9tRWxlbWVudHMiLCJjbGVhciIsIl9tdWx0aXNlbGVjdCIsImlucHV0Iiwib3B0aW9uc0NvbnRhaW5lciIsIm9wdGlvbnNDb250YWluZXJMaXN0Iiwib3B0aW9ucyIsImxpc3QiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZmluZCIsImNhbGxiYWNrRm4iLCJpIiwibm9kZSIsInVuZGVmaW5lZCIsInNvbWUiLCJfZW5hYmxlRXZlbnRMaXN0ZW5uZXJzIiwiX2luaXRTZWxlY3RlZExpc3QiLCJjYWxsYmFjayIsIl9ldmVudCIsIm9wdGlvbiIsImluZGV4IiwiaHRtbCIsInZhbHVlIiwiX3Byb2Nlc3NUZW1wbGF0ZSIsInRleHQiLCJfY3Jvc3MiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJyZW1vdmVCdG4iLCJsYXN0RWxlbWVudENoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRhcmdldCIsImVsIiwiZGF0YXNldCIsIl9oYW5kbGVPcHRpb24iLCJfc2VsZWN0ZWRPcHRpb25zIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiX3JlbW92ZU9wdGlvbkZyb21MaXN0IiwiX2hhbmRsZUNsZWFyU2VsZWN0aW9uQnRuIiwiX2hhbmRsZVBsYWNlaG9sZGVyIiwiX2Rpc3BhdGNoRXZlbnQiLCJhY3Rpb24iLCJzZWxlY3Rpb24iLCJfZmlsdGVyT3B0aW9ucyIsIl9yZW1vdmVBbGxBcnJvd1NlbGVjdGVkIiwiZXZlbnQiLCJjb250YWlucyIsIl9jbG9zZUxpc3QiLCJfY2xlYXJTZWxlY3Rpb24iLCJhZGQiLCJlIiwiX2hhbmRsZUFycm93cyIsIl9oYW5kbGVCYWNrc3BhY2UiLCJfaGFuZGxlRW50ZXIiLCJpc09wZW4iLCJ2YWx1ZUxvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwidGV4dENvbnRlbnQiLCJzdWJzdHJpbmciLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImhhc1Jlc3VsdHMiLCJfc2hvd05vUmVzdWx0cyIsInJlc3VsdCIsImNoYXJhY3RlcnMiLCJjaGFyYWN0ZXJzTGVuZ3RoIiwiY2hhckF0IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiYXJyIiwiaXRlbSIsInB1c2giLCJzZWxlY3RlZCIsImhhc0F0dHJpYnV0ZSIsImlzVmFsdWVGaWVsZFZhbGlkIiwiaXNUZXh0RmllbGRWYWxpZCIsImtleUNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImZpcnN0RWxlbWVudENoaWxkIiwic2Nyb2xsSW50b1ZpZXciLCJBcnJvd1VwIiwiVXAiLCJBcnJvd0Rvd24iLCJEb3duIiwia2V5IiwiY2hpbGRyZW4iLCJfc2Nyb2xsSW50b1ZpZXciLCJsYXN0U2VsZWN0ZWRPcHRpb24iLCJ0YXJnZXRMYXN0U2VsZWN0ZWRPcHRpb24iLCJzdHlsZSIsImRpc3BsYXkiLCJkaXNwYXRjaEV2ZW50Iiwic3BsaWNlIiwiX2FkZE9wdGlvblRvTGlzdCIsImhhc0l0ZW1zU2VsZWN0ZWQiLCJ0ZW1wbGF0ZSIsInByb2Nlc3NlZFRlbXBsYXRlIiwib2JqQXR0ciIsIm1hdGNoIiwibWFwIiwicmVwbGFjZSIsImF0dHIiLCJjbGFzc05hbWUiLCJvcHRpb25Eb20iLCJqb2luIiwiX3Nob3dOb0RhdGEiLCJpZCIsIl9nZW5lcmF0ZUlkIiwicGFyZW50IiwiY2hpbGQiLCJyZWN0UGFyZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdENoaWxkIiwidG9wIiwiYm90dG9tIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0VG9wIiwiY29uZGl0aW9uIiwiZG9tIiwic2V0TXVsdGlTZWxlY3QiLCJmb3JFYWNoIiwiaWNvbmljTXVsdGlTZWxlY3RFbGVtZW50Iiwic3Vic2NyaWJlIiwiZXZ0Iiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiaW5pdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztJQUNNQSxpQjtBQStCRjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJLG1DQUFnSDtBQUFBLFFBQWxHQyxJQUFrRyxRQUFsR0EsSUFBa0c7QUFBQSxRQUE1RkMsWUFBNEYsUUFBNUZBLFlBQTRGO0FBQUEsUUFBOUVDLE1BQThFLFFBQTlFQSxNQUE4RTtBQUFBLFFBQXRFQyxTQUFzRSxRQUF0RUEsU0FBc0U7QUFBQSxRQUEzREMsV0FBMkQsUUFBM0RBLFdBQTJEO0FBQUEsUUFBOUNDLE1BQThDLFFBQTlDQSxNQUE4QztBQUFBLFFBQXRDQyxXQUFzQyxRQUF0Q0EsV0FBc0M7QUFBQSxRQUF6QkMsU0FBeUIsUUFBekJBLFNBQXlCO0FBQUEsUUFBZEMsVUFBYyxRQUFkQSxVQUFjOztBQUFBOztBQUFBOztBQUFBOztBQUFBLG9DQXRDdkcsWUFBTSxDQUFFLENBc0MrRjs7QUFBQTs7QUFBQTs7QUFBQTs7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QzNJLGdCQUF6QixDQUEwQ29CLE9BQTFDLENBQWtESyxHQUFsRCxFQUFxRCtELFFBQXJELEdBQWdFLEtBQWhFOztBQUNBbUQsd0NBQXdCLENBQUMzSSxnQkFBekIsQ0FBMENvQixPQUExQyxDQUFrREssR0FBbEQsRUFBcURzSCxlQUFyRCxDQUFxRSxVQUFyRSxFQUFpRixFQUFqRjtBQUNEO0FBQ0Q7O0FBQ0Y7QUFoQko7QUFrQkgsT0FuQkQ7QUFxQkFKLDhCQUF3QixDQUFDSyxJQUF6QjtBQUNILEtBNUJEO0FBNkJILEdBL0JzQixDQWlDdkI7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUNIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL211bHRpX3NlbGVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogSWNvbmljTXVsdGlTZWxlY3QgdjAuNy4wXG4gKiBMaWNlbmNlOiAgTUlUXG4gKiAoYykgMjAyMSBTaWRuZXkgV2ltYXJ0LlxuICpcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3NpZG5leXdtL2ljb25pYy1tdWx0aXNlbGVjdFxuICpcbiAqIFRoaXMgaXMgcGx1Z2luIGlzIGluc3RhbGxlZCBtYW51YWxseSBzaW5jZSBubyBwYWNrYWdlIG9uIE5QTSBleGlzdHMuXG4gKi9cblxuaW1wb3J0IGh0bXggZnJvbSAnaHRteC5vcmcnO1xuXG4vKipcbiAqIEB2ZXJzaW9uIEljb25pY011bHRpU2VsZWN0IHYwLjcuMFxuICogQGxpY2VuY2UgIE1JVFxuICovXG5jbGFzcyBJY29uaWNNdWx0aVNlbGVjdCB7XG4gICAgX2RhdGE7XG4gICAgX2RvbUVsZW1lbnRzO1xuICAgIF9ldmVudCA9ICgpID0+IHt9O1xuICAgIF9pdGVtVGVtcGxhdGU7XG4gICAgX211bHRpc2VsZWN0O1xuICAgIF9ub0RhdGE7XG4gICAgX25vUmVzdWx0cztcbiAgICBfb3B0aW9ucyA9IFtdO1xuICAgIF9wbGFjZWhvbGRlcjtcbiAgICBfc2VsZWN0O1xuICAgIF9zZWxlY3RDb250YWluZXI7XG4gICAgX3NlbGVjdGVkT3B0aW9ucyA9IFtdO1xuICAgIF90YWdUZW1wbGF0ZTtcbiAgICBfdGV4dEZpZWxkO1xuICAgIF92YWx1ZUZpZWxkO1xuICAgIF9jcm9zcyA9IGBcbiAgICAgIDxzdmdcbiAgICAgICAgd2lkdGg9XCIyNFwiXG4gICAgICAgIGhlaWdodD1cIjI0XCJcbiAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICA+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk02LjIyNTMgNC44MTEwOEM1LjgzNDc3IDQuNDIwNTYgNS4yMDE2MSA0LjQyMDU2IDQuODExMDggNC44MTEwOEM0LjQyMDU2IDUuMjAxNjEgNC40MjA1NiA1LjgzNDc3IDQuODExMDggNi4yMjUzTDEwLjU4NTggMTJMNC44MTExNCAxNy43NzQ3QzQuNDIwNjIgMTguMTY1MiA0LjQyMDYyIDE4Ljc5ODQgNC44MTExNCAxOS4xODg5QzUuMjAxNjcgMTkuNTc5NCA1LjgzNDgzIDE5LjU3OTQgNi4yMjUzNSAxOS4xODg5TDEyIDEzLjQxNDJMMTcuNzc0NyAxOS4xODg5QzE4LjE2NTIgMTkuNTc5NCAxOC43OTg0IDE5LjU3OTQgMTkuMTg4OSAxOS4xODg5QzE5LjU3OTQgMTguNzk4NCAxOS41Nzk0IDE4LjE2NTIgMTkuMTg4OSAxNy43NzQ3TDEzLjQxNDIgMTJMMTkuMTg5IDYuMjI1M0MxOS41Nzk1IDUuODM0NzcgMTkuNTc5NSA1LjIwMTYxIDE5LjE4OSA0LjgxMTA4QzE4Ljc5ODUgNC40MjA1NiAxOC4xNjUzIDQuNDIwNTYgMTcuNzc0OCA0LjgxMTA4TDEyIDEwLjU4NThMNi4yMjUzIDQuODExMDhaXCJcbiAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAgYDtcblxuICAgIC8qKlxuICAgICAqIEljb25pYyBNdWx0aXNlbGVjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0geyBPYmplY3RbXSB9IGRhdGEgLSBBcnJheSBvZiBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IG5vRGF0YSAtIERlZmluZXMgdGhlIG1lc3NhZ2Ugd2hlbiB0aGVyZSBpcyBubyBkYXRhIGlucHV0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IG5vUmVzdWx0cyAtIERlZmluZXMgdGhlIG1lc3NhZ2Ugd2hlbiB0aGVyZSBpcyBubyByZXN1bHQgaWYgb3B0aW9ucyBhcmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gcGxhY2Vob2xkZXIgLSAgRGVmaW5lcyB0aGUgcGxhY2Vob2xkZXIncyB0ZXh0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHNlbGVjdCAtIERPTSBlbGVtZW50IHRvIGJlIHNlbGVjdGVkLiBJdCBtdXN0IGJlIGEgSFRNTCBTZWxlY3QgdGFnIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3NlbGVjdFxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHRleHRGaWVsZCAtIEZpZWxkIHRvIHNlbGVjdCBpbiB0aGUgb2JqZWN0IGZvciB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB2YWx1ZUZpZWxkIC0gRmllbGQgdG8gc2VsZWN0IGluIHRoZSBvYmplY3QgZm9yIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEsIGl0ZW1UZW1wbGF0ZSwgbm9EYXRhLCBub1Jlc3VsdHMsIHBsYWNlaG9sZGVyLCBzZWxlY3QsIHRhZ1RlbXBsYXRlLCB0ZXh0RmllbGQsIHZhbHVlRmllbGQgfSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGEgPz8gW107XG4gICAgICB0aGlzLl9pdGVtVGVtcGxhdGUgPSBpdGVtVGVtcGxhdGUgPz8gbnVsbDtcbiAgICAgIHRoaXMuX25vRGF0YSA9IG5vRGF0YSA/PyBcIk5vIGRhdGEgZm91bmQuXCI7XG4gICAgICB0aGlzLl9ub1Jlc3VsdHMgPSBub1Jlc3VsdHMgPz8gXCJObyByZXN1bHRzIGZvdW5kLlwiO1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlciA/PyBcIlNlbGVjdC4uLlwiO1xuICAgICAgdGhpcy5fc2VsZWN0ID0gc2VsZWN0O1xuICAgICAgdGhpcy5fc2VsZWN0Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3QpO1xuICAgICAgdGhpcy5fdGFnVGVtcGxhdGUgPSB0YWdUZW1wbGF0ZSA/PyBudWxsO1xuICAgICAgdGhpcy5fdGV4dEZpZWxkID0gdGV4dEZpZWxkID8/IG51bGw7XG4gICAgICB0aGlzLl92YWx1ZUZpZWxkID0gdmFsdWVGaWVsZCA/PyBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIEljb25pYyBNdWx0aXNlbGVjdCBjb21wb25lbnQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5fc2VsZWN0Q29udGFpbmVyICYmIHRoaXMuX3NlbGVjdENvbnRhaW5lci5ub2RlTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICAgICAgICBpZiAodGhpcy5faXRlbVRlbXBsYXRlICYmIHRoaXMuX2RhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIml0ZW1UZW1wbGF0ZSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZGF0YSBmcm9tIHRoZSBjb21wb25lbnQgc2V0dGluZ3NcIik7XG4gICAgICAgIGlmICh0aGlzLl90YWdUZW1wbGF0ZSAmJiB0aGlzLl9kYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YWdUZW1wbGF0ZSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZGF0YSBmcm9tIHRoZSBjb21wb25lbnQgc2V0dGluZ3NcIik7XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2RhdGEubGVuZ3RoID4gMCA/IHRoaXMuX2dldERhdGFGcm9tU2V0dGluZ3MoKSA6IHRoaXMuX2dldERhdGFGcm9tU2VsZWN0VGFnKCk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTXVsdGlzZWxlY3QoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyT3B0aW9uc0xpc3QoKTtcblxuICAgICAgICB0aGlzLl9kb21FbGVtZW50cyA9IHtcbiAgICAgICAgICBjbGVhcjogdGhpcy5fbXVsdGlzZWxlY3QucXVlcnlTZWxlY3RvcihgLm11bHRpc2VsZWN0X19jbGVhci1idG5gKSxcbiAgICAgICAgICBpbnB1dDogdGhpcy5fbXVsdGlzZWxlY3QucXVlcnlTZWxlY3RvcihgLm11bHRpc2VsZWN0X19pbnB1dGApLFxuICAgICAgICAgIG9wdGlvbnNDb250YWluZXI6IHRoaXMuX211bHRpc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoYC5tdWx0aXNlbGVjdF9fb3B0aW9uc2ApLFxuICAgICAgICAgIG9wdGlvbnNDb250YWluZXJMaXN0OiB0aGlzLl9tdWx0aXNlbGVjdC5xdWVyeVNlbGVjdG9yKGAubXVsdGlzZWxlY3RfX29wdGlvbnMgPiB1bGApLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpc3Q6IHRoaXMuX211bHRpc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoYC5tdWx0aXNlbGVjdF9fb3B0aW9ucyA+IHVsID4gbGlgKSxcbiAgICAgICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tGbihub2RlKSkgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb21lOiBmdW5jdGlvbiAoY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrRm4obm9kZSwgaSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9lbmFibGVFdmVudExpc3Rlbm5lcnMoKTtcbiAgICAgICAgdGhpcy5faW5pdFNlbGVjdGVkTGlzdCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzZWxlY3RvciAnJHt0aGlzLl9zZWxlY3R9JyBkaWQgbm90IHNlbGVjdCBhbnkgdmFsaWQgc2VsZWN0IHRhZy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBlbWl0dGVkIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggZW1pdHMgYSBjdXN0b20gZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9ldmVudCA9IGNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJhbWV0ZXIgaW4gdGhlIHN1YnNjcmliZSBtZXRob2QgaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb3B0aW9uIHRvIHRoZSBzZWxlY3Rpb24gbGlzdC5cbiAgICAgKiBAcGFyYW0geyBPYmplY3Q6IHsgdGV4dDogc3RyaW5nOyB2YWx1ZTogc3RyaW5nOyB9fSBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRPcHRpb25Ub0xpc3Qob3B0aW9uLCBpbmRleCkge1xuICAgICAgY29uc3QgaHRtbCA9IGA8c3BhbiBjbGFzcz1cIm11bHRpc2VsZWN0X19zZWxlY3RlZFwiIGRhdGEtdmFsdWU9XCIke29wdGlvbi52YWx1ZX1cIj4ke1xuICAgICAgICB0aGlzLl90YWdUZW1wbGF0ZSA/IHRoaXMuX3Byb2Nlc3NUZW1wbGF0ZSh0aGlzLl90YWdUZW1wbGF0ZSwgaW5kZXgpIDogb3B0aW9uLnRleHRcbiAgICAgIH08c3BhbiBjbGFzcz1cIm11bHRpc2VsZWN0X19yZW1vdmUtYnRuXCI+JHt0aGlzLl9jcm9zc308L3NwYW4+PC9zcGFuPmA7XG5cbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmlucHV0Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsIGh0bWwpO1xuXG4gICAgICBjb25zdCB7IGxhc3RFbGVtZW50Q2hpbGQ6IHJlbW92ZUJ0biB9ID0gdGhpcy5fbXVsdGlzZWxlY3QucXVlcnlTZWxlY3Rvcihgc3BhbltkYXRhLXZhbHVlPVwiJHtvcHRpb24udmFsdWV9XCJdYCk7XG4gICAgICByZW1vdmVCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZG9tRWxlbWVudHMub3B0aW9ucy5maW5kKChlbCkgPT4gZWwuZGF0YXNldC52YWx1ZSA9PSBvcHRpb24udmFsdWUpO1xuICAgICAgICB0aGlzLl9oYW5kbGVPcHRpb24odGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgc2VsZWN0ZWQgb3B0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhclNlbGVjdGlvbigpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2VsZWN0ZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuX3NlbGVjdGVkT3B0aW9uc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZG9tRWxlbWVudHMub3B0aW9ucy5maW5kKChlbCkgPT4gZWwuZGF0YXNldC52YWx1ZSA9PSBvcHRpb24udmFsdWUpO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShgbXVsdGlzZWxlY3RfX29wdGlvbnMtLXNlbGVjdGVkYCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZU9wdGlvbkZyb21MaXN0KHRhcmdldC5kYXRhc2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NlbGVjdGVkT3B0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5faGFuZGxlQ2xlYXJTZWxlY3Rpb25CdG4oKTtcbiAgICAgIHRoaXMuX2hhbmRsZVBsYWNlaG9sZGVyKCk7XG4gICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgYWN0aW9uOiBcIkNMRUFSX0FMTF9PUFRJT05TXCIsXG4gICAgICAgIHNlbGVjdGlvbjogdGhpcy5fc2VsZWN0ZWRPcHRpb25zLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIG9wdGlvbnMgY29udGFpbmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Nsb3NlTGlzdCgpIHtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnNDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcInZpc2libGVcIik7XG4gICAgICB0aGlzLl9maWx0ZXJPcHRpb25zKFwiXCIpO1xuICAgICAgdGhpcy5fcmVtb3ZlQWxsQXJyb3dTZWxlY3RlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgbmV3IGV2ZW50cy5cbiAgICAgKiBAcGFyYW0geyBvYmplY3QgOiB7IGFjdGlvbjogc3RyaW5nOyBzZWxlY3Rpb246IHsgb3B0aW9uOiBzdHJpbmc7IHRleHQ6IHN0cmluZzsgfVtdOyB2YWx1ZT86IHN0cmluZzsgfSB9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgdGhpcy5fZXZlbnQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYWxsIG1haW4gZXZlbnQgbGlzdGVubmVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9lbmFibGVFdmVudExpc3Rlbm5lcnMoKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX211bHRpc2VsZWN0LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLl9maWx0ZXJPcHRpb25zKFwiXCIpO1xuICAgICAgICAgIHRoaXMuX2Nsb3NlTGlzdCgpO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVBsYWNlaG9sZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kb21FbGVtZW50cy5jbGVhci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbigpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZG9tRWxlbWVudHMub3B0aW9ucy5saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnMubGlzdFtpXTtcbiAgICAgICAgb3B0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZU9wdGlvbih0YXJnZXQpO1xuICAgICAgICAgIHRoaXMuX2Nsb3NlTGlzdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG9tRWxlbWVudHMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZG9tRWxlbWVudHMub3B0aW9uc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzaWJsZVwiKTtcbiAgICAgICAgdGhpcy5fZG9tRWxlbWVudHMuaW5wdXQucGxhY2Vob2xkZXIgPSBcIlwiO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kb21FbGVtZW50cy5vcHRpb25zLmxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX2ZpbHRlck9wdGlvbnModmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZG9tRWxlbWVudHMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgdGhpcy5faGFuZGxlQXJyb3dzKGUpO1xuICAgICAgICB0aGlzLl9oYW5kbGVCYWNrc3BhY2UoZSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUVudGVyKGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVycyB1c2VyIGlucHV0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlsdGVyT3B0aW9ucyh2YWx1ZSkge1xuICAgICAgY29uc3QgaXNPcGVuID0gdGhpcy5fZG9tRWxlbWVudHMub3B0aW9uc0NvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJ2aXNpYmxlXCIpO1xuICAgICAgY29uc3QgdmFsdWVMb3dlckNhc2UgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoIWlzT3BlbiAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnNDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInZpc2libGVcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kb21FbGVtZW50cy5vcHRpb25zLmxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnMubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZG9tRWxlbWVudHMub3B0aW9ucy5saXN0W2ldO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9pdGVtVGVtcGxhdGUgPyB0aGlzLl9kYXRhW2ldW3RoaXMuX3RleHRGaWVsZF0gOiBlbC50ZXh0Q29udGVudDtcblxuICAgICAgICAgIGlmICh0ZXh0LnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIHZhbHVlTG93ZXJDYXNlLmxlbmd0aCkgPT09IHZhbHVlTG93ZXJDYXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9kb21FbGVtZW50cy5vcHRpb25zQ29udGFpbmVyTGlzdC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzUmVzdWx0cyA9IHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnMuc29tZShcbiAgICAgICAgICAoZWwsIGluZGV4KSA9PlxuICAgICAgICAgICAgKHRoaXMuX2l0ZW1UZW1wbGF0ZSA/IHRoaXMuX2RhdGFbaW5kZXhdW3RoaXMuX3RleHRGaWVsZF0gOiBlbC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCB2YWx1ZUxvd2VyQ2FzZS5sZW5ndGgpID09PSB2YWx1ZUxvd2VyQ2FzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9zaG93Tm9SZXN1bHRzKCFoYXNSZXN1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVJZChsZW5ndGgpIHtcbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgY29uc3QgY2hhcmFjdGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgICAgIGNvbnN0IGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBkYXRhIGZyb20gc2VsZWN0IHRhZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXREYXRhRnJvbVNlbGVjdFRhZygpIHtcbiAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLl9zZWxlY3RDb250YWluZXI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IG9wdGlvbnNbaV1cbiAgICAgICAgYXJyLnB1c2goe1xuICAgICAgICAgIHRleHQ6IGl0ZW0udGV4dCxcbiAgICAgICAgICB2YWx1ZTogaXRlbS52YWx1ZSxcbiAgICAgICAgICBzZWxlY3RlZDogaXRlbS5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgZGF0YSBmcm9tIHNldHRpbmdzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldERhdGFGcm9tU2V0dGluZ3MoKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPiAwICYmIHRoaXMuX3ZhbHVlRmllbGQgJiYgdGhpcy5fdGV4dEZpZWxkKSB7XG4gICAgICAgIGNvbnN0IGlzVmFsdWVGaWVsZFZhbGlkID0gdHlwZW9mIHRoaXMuX3ZhbHVlRmllbGQgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIGNvbnN0IGlzVGV4dEZpZWxkVmFsaWQgPSB0eXBlb2YgdGhpcy5fdGV4dEZpZWxkID09PSBcInN0cmluZ1wiO1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcblxuICAgICAgICBpZiAoIWlzVmFsdWVGaWVsZFZhbGlkIHx8ICFpc1RleHRGaWVsZFZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGV4dEZpZWxkIGFuZCB2YWx1ZUZpZWxkIG11c3QgYmUgb2YgdHlwZSBzdHJpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fZGF0YVtpXTtcbiAgICAgICAgICBhcnIucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogaXRlbVt0aGlzLl92YWx1ZUZpZWxkXSxcbiAgICAgICAgICAgIHRleHQ6IGl0ZW1bdGhpcy5fdGV4dEZpZWxkXSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiB0eXBlb2YgaXRlbS5zZWxlY3RlZCA9PT0gXCJib29sZWFuXCIgPyBpdGVtLnNlbGVjdGVkIDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBBcnJvdyB1cCAmIERvd24uIFNlbGVjdGlvbiBvZiBhbiBvcHRpb24gaXMgYWxzbyBwb3NzaWJsZSB3aXRoIHRoZXNlIGtleXMuXG4gICAgICogQHBhcmFtIHsgRXZlbnQgfSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZUFycm93cyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDQwIHx8IGV2ZW50LmtleUNvZGUgPT09IDM4KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGlzT3BlbiA9IHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnNDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwidmlzaWJsZVwiKTtcbiAgICAgICAgLy8gQW4gdXBkYXRlZCB2aWV3IG9mIHRoZSBjb250YWluZXIgaXMgbmVlZGVkIGJlY2F1c2Ugb2YgdGhlIGZpbHRlcmluZyBvcHRpb25cbiAgICAgICAgY29uc3Qgb3B0aW9uc0NvbnRhaW5lckxpc3QgPSB0aGlzLl9tdWx0aXNlbGVjdC5xdWVyeVNlbGVjdG9yKGAubXVsdGlzZWxlY3RfX29wdGlvbnMgPiB1bGApO1xuXG4gICAgICAgIGlmICghaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy5fZG9tRWxlbWVudHMub3B0aW9uc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzaWJsZVwiKTtcbiAgICAgICAgICBvcHRpb25zQ29udGFpbmVyTGlzdC5maXJzdEVsZW1lbnRDaGlsZC5jbGFzc0xpc3QuYWRkKFwiYXJyb3ctc2VsZWN0ZWRcIik7XG4gICAgICAgICAgb3B0aW9uc0NvbnRhaW5lckxpc3QuZmlyc3RFbGVtZW50Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX211bHRpc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoYC5tdWx0aXNlbGVjdF9fb3B0aW9ucyB1bCBsaS5hcnJvdy1zZWxlY3RlZGApO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgIEFycm93VXA6IFwicHJldmlvdXNcIixcbiAgICAgICAgICAgIFVwOiBcInByZXZpb3VzXCIsXG4gICAgICAgICAgICBBcnJvd0Rvd246IFwibmV4dFwiLFxuICAgICAgICAgICAgRG93bjogXCJuZXh0XCIsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnNDb250YWluZXJMaXN0LmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTGlzdC5hZGQoXCJhcnJvdy1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIG9wdGlvbnNDb250YWluZXJMaXN0LmZpcnN0RWxlbWVudENoaWxkLnNjcm9sbEludG9WaWV3KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKFwiYXJyb3ctc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkW2FjdGlvbltldmVudC5rZXldICsgXCJFbGVtZW50U2libGluZ1wiXTtcblxuICAgICAgICAgIC8vIEdvIHRvIHN0YXJ0IG9yIGVuZCBvZiB0aGUgcG9wdXAgbGlzdFxuICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID1cbiAgICAgICAgICAgICAgb3B0aW9uc0NvbnRhaW5lckxpc3QuY2hpbGRyZW5bYWN0aW9uW2V2ZW50LmtleV0gPT09IFwibmV4dFwiID8gMCA6IG9wdGlvbnNDb250YWluZXJMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgc2VsZWN0ZWQuY2xhc3NMaXN0LmFkZChcImFycm93LXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsSW50b1ZpZXcob3B0aW9uc0NvbnRhaW5lckxpc3QsIHNlbGVjdGVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QuYWRkKFwiYXJyb3ctc2VsZWN0ZWRcIik7XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsSW50b1ZpZXcob3B0aW9uc0NvbnRhaW5lckxpc3QsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGJhY2tzcGFjZSBrZXkgZXZlbnQgLSBEZWxldGVzIHRoZSBwcmVjZWRpbmcgb3B0aW9uIGluIHRoZSBzZWxlY3Rpb24gbGlzdC5cbiAgICAgKiBAcGFyYW0geyBFdmVudCB9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVCYWNrc3BhY2UoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gOCAmJiBlLnRhcmdldC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICBjb25zdCBsYXN0U2VsZWN0ZWRPcHRpb24gPVxuICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwID8gdGhpcy5fc2VsZWN0ZWRPcHRpb25zW3RoaXMuX3NlbGVjdGVkT3B0aW9ucy5sZW5ndGggLSAxXSA6IG51bGw7XG5cbiAgICAgICAgaWYgKGxhc3RTZWxlY3RlZE9wdGlvbikge1xuICAgICAgICAgIGNvbnN0IHRhcmdldExhc3RTZWxlY3RlZE9wdGlvbiA9IHRoaXMuX211bHRpc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBgbGlbZGF0YS12YWx1ZT1cIiR7bGFzdFNlbGVjdGVkT3B0aW9uLnZhbHVlfVwiXWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZU9wdGlvbih0YXJnZXRMYXN0U2VsZWN0ZWRPcHRpb24pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkT3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnNDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcInZpc2libGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgY2xlYXIgc2VsZWN0aW9uIGJ1dHRvbiBpZiBzb21lIG9wdGlvbnMgYXJlIHNlbGVjdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZUNsZWFyU2VsZWN0aW9uQnRuKCkge1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmNsZWFyLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmNsZWFyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBlbnRlciBrZXkgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRXZlbnQgfSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZUVudGVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLl9tdWx0aXNlbGVjdC5xdWVyeVNlbGVjdG9yKGAubXVsdGlzZWxlY3RfX29wdGlvbnMgdWwgbGkuYXJyb3ctc2VsZWN0ZWRgKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlT3B0aW9uKHNlbGVjdGVkKTtcbiAgICAgICAgICB0aGlzLl9jbG9zZUxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9oYW5kbGVPcHRpb24odGFyZ2V0LCBkaXNwYXRjaEV2ZW50ID0gdHJ1ZSkge1xuICAgICAgLy8gUmVtb3ZlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuX3NlbGVjdGVkT3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKGVsLnZhbHVlID09IHRhcmdldC5kYXRhc2V0LnZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoYG11bHRpc2VsZWN0X19vcHRpb25zLS1zZWxlY3RlZGApO1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT3B0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlT3B0aW9uRnJvbUxpc3QodGFyZ2V0LmRhdGFzZXQudmFsdWUpO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUNsZWFyU2VsZWN0aW9uQnRuKCk7XG4gICAgICAgICAgdGhpcy5faGFuZGxlUGxhY2Vob2xkZXIoKTtcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50ICYmXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBcIlJFTU9WRV9PUFRJT05cIixcbiAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldC5kYXRhc2V0LnZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuX3NlbGVjdGVkT3B0aW9ucyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLl9vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09IHRhcmdldC5kYXRhc2V0LnZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoYG11bHRpc2VsZWN0X19vcHRpb25zLS1zZWxlY3RlZGApO1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT3B0aW9ucyA9IFsuLi50aGlzLl9zZWxlY3RlZE9wdGlvbnMsIG9wdGlvbl07XG4gICAgICAgICAgdGhpcy5fYWRkT3B0aW9uVG9MaXN0KG9wdGlvbiwgaSk7XG4gICAgICAgICAgdGhpcy5faGFuZGxlQ2xlYXJTZWxlY3Rpb25CdG4oKTtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVQbGFjZWhvbGRlcigpO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBhY3Rpb246IFwiQUREX09QVElPTlwiLFxuICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0LmRhdGFzZXQudmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5fc2VsZWN0ZWRPcHRpb25zLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHBsYWNlaG9sZGVyIGlmIG5vIG9wdGlvbnMgYXJlIHNlbGVjdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVBsYWNlaG9sZGVyKCkge1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmlucHV0LnBsYWNlaG9sZGVyID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvbUVsZW1lbnRzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fcGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2luaXRTZWxlY3RlZExpc3QoKSB7XG4gICAgICBsZXQgaGFzSXRlbXNTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5fb3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgIGhhc0l0ZW1zU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2RvbUVsZW1lbnRzLm9wdGlvbnMuZmluZCgoZWwpID0+IGVsLmRhdGFzZXQudmFsdWUgPT0gb3B0aW9uLnZhbHVlKVxuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGBtdWx0aXNlbGVjdF9fb3B0aW9ucy0tc2VsZWN0ZWRgKTtcbiAgICAgICAgICB0aGlzLl9zZWxlY3RlZE9wdGlvbnMgPSBbLi4udGhpcy5fc2VsZWN0ZWRPcHRpb25zLCBvcHRpb25dO1xuICAgICAgICAgIHRoaXMuX2FkZE9wdGlvblRvTGlzdChvcHRpb24sIGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNJdGVtc1NlbGVjdGVkKVxuICAgICAgICB0aGlzLl9oYW5kbGVDbGVhclNlbGVjdGlvbkJ0bigpO1xuICAgICAgICB0aGlzLl9oYW5kbGVQbGFjZWhvbGRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGN1c3RvbSB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB0ZW1wbGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2Nlc3NUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5kZXgpIHtcbiAgICAgIGxldCBwcm9jZXNzZWRUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgY29uc3Qgb2JqQXR0ciA9IHRlbXBsYXRlLm1hdGNoKC9cXCRcXHsoXFx3KylcXH0vZykubWFwKChlKSA9PiBlLnJlcGxhY2UoL1xcJFxce3xcXH0vZywgXCJcIikpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iakF0dHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IG9iakF0dHJbaV07XG4gICAgICAgIHByb2Nlc3NlZFRlbXBsYXRlID0gcHJvY2Vzc2VkVGVtcGxhdGUucmVwbGFjZShgXFwkXFx7JHthdHRyfVxcfWAsIHRoaXMuX2RhdGFbaW5kZXhdW2F0dHJdID8/IFwiXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvY2Vzc2VkVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgX3JlbW92ZUFsbEFycm93U2VsZWN0ZWQoKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBcImFycm93LXNlbGVjdGVkXCI7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9kb21FbGVtZW50cy5vcHRpb25zLmZpbmQoKGVsKSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9wdGlvbiBmcm9tIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlT3B0aW9uRnJvbUxpc3QodmFsdWUpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkRvbSA9IHRoaXMuX211bHRpc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoYHNwYW5bZGF0YS12YWx1ZT1cIiR7dmFsdWV9XCJdYCk7XG4gICAgICBvcHRpb25Eb20gJiYgb3B0aW9uRG9tLnBhcmVudE5vZGUgJiYgb3B0aW9uRG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3B0aW9uRG9tKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBtdWx0aXNlbGVjdCBvcHRpb25zIGxpc3Qgdmlldy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPcHRpb25zTGlzdCgpIHtcbiAgICAgIGNvbnN0IGh0bWwgPSBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm11bHRpc2VsZWN0X19vcHRpb25zXCI+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2l0ZW1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgID8gdGhpcy5fb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIDxsaSBkYXRhLXZhbHVlPVwiJHtvcHRpb24udmFsdWV9XCI+JHtvcHRpb24udGV4dH08L2xpPlxuICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlwiKVxuICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmxlbmd0aCA+IDAgJiYgdGhpcy5faXRlbVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKG9wdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIDxsaSBkYXRhLXZhbHVlPVwiJHtvcHRpb24udmFsdWV9XCI+JHt0aGlzLl9wcm9jZXNzVGVtcGxhdGUodGhpcy5faXRlbVRlbXBsYXRlLCBpbmRleCl9PC9saT5cbiAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIilcbiAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7dGhpcy5fc2hvd05vRGF0YSh0aGlzLl9vcHRpb25zLmxlbmd0aCA9PT0gMCl9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICB0aGlzLl9tdWx0aXNlbGVjdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaHRtbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgbXVsdGlzZWxlY3Qgdmlldy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJNdWx0aXNlbGVjdCgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBjb25zdCBpZCA9IFwiaWNvbmljLVwiICsgdGhpcy5fZ2VuZXJhdGVJZCgyMCk7XG4gICAgICBjb25zdCBodG1sID0gYFxuICAgICAgICA8ZGl2IGlkPVwiJHtpZH1cIiBjbGFzcz1cIm11bHRpc2VsZWN0X19jb250YWluZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibXVsdGlzZWxlY3RfX3dyYXBwZXJcIj5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cIm11bHRpc2VsZWN0X19pbnB1dFwiIHBsYWNlaG9sZGVyPVwiJHt0aGlzLl9wbGFjZWhvbGRlcn1cIiAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxzcGFuIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIiBjbGFzcz1cIm11bHRpc2VsZWN0X19jbGVhci1idG5cIj4ke3RoaXMuX2Nyb3NzfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuXG4gICAgICB0aGlzLl9zZWxlY3RDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJlbmRcIiwgaHRtbCk7XG4gICAgICB0aGlzLl9tdWx0aXNlbGVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2lkfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbEludG9WaWV3IC0gVGhpcyBzbWFsbCB1dGlsaXR5IHJlcHJvZHVjZXMgdGhlIGJlaGF2aW9yIG9mIC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcIm5lYXJlc3RcIiwgaW5saW5lOiBcIm5lYXJlc3RcIiB9KVxuICAgICAqIFRoaXMgaXMgZm9yIElFIGNvbXBhdGliaWxpdHkgd2l0aG91dCBhIG5lZWQgb2YgYSBwb2x5ZmlsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Njcm9sbEludG9WaWV3KHBhcmVudCwgY2hpbGQpIHtcbiAgICAgIGNvbnN0IHJlY3RQYXJlbnQgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCByZWN0Q2hpbGQgPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgLy8gRGV0ZWN0IGlmIG5vdCB2aXNpYmxlIGF0IHRvcCBhbmQgdGhlbiBzY3JvbGwgdG8gdGhlIHRvcFxuICAgICAgaWYgKCEocmVjdFBhcmVudC50b3AgPCByZWN0Q2hpbGQuYm90dG9tIC0gY2hpbGQub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wID0gY2hpbGQuY2xpZW50SGVpZ2h0ICsgKGNoaWxkLm9mZnNldFRvcCAtIGNoaWxkLm9mZnNldEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVjdCBpZiBub3QgdmlzaWJsZSBhdCBib3R0b20gYW5kIHRoZW4gc2Nyb2xsIHRvIHRoZSBib3R0b21cbiAgICAgIGlmICghKHJlY3RQYXJlbnQuYm90dG9tID4gcmVjdENoaWxkLnRvcCArIGNoaWxkLm9mZnNldEhlaWdodCkpIHtcbiAgICAgICAgcGFyZW50LnNjcm9sbFRvcCA9XG4gICAgICAgICAgY2hpbGQuY2xpZW50SGVpZ2h0ICtcbiAgICAgICAgICAoY2hpbGQub2Zmc2V0VG9wIC0gY2hpbGQub2Zmc2V0SGVpZ2h0KSAtXG4gICAgICAgICAgKHBhcmVudC5vZmZzZXRIZWlnaHQgLSAoY2hpbGQub2Zmc2V0SGVpZ2h0ICsgKGNoaWxkLm9mZnNldEhlaWdodCAtIGNoaWxkLmNsaWVudEhlaWdodCkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIG5vIGRhdGEgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0geyBib29sZWFuIH0gY29uZGl0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd05vRGF0YShjb25kaXRpb24pIHtcbiAgICAgIHJldHVybiBjb25kaXRpb24gPyBgPHAgY2xhc3M9XCJtdWx0aXNlbGVjdF9fb3B0aW9ucy0tbm8tZGF0YVwiPiR7dGhpcy5fbm9EYXRhfTwvcD5gIDogXCJcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIG5vIHJlc3VsdHMgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0geyBib29sZWFuIH0gY29uZGl0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd05vUmVzdWx0cyhjb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IGRvbSA9IHRoaXMuX211bHRpc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoYC5tdWx0aXNlbGVjdF9fb3B0aW9ucy0tbm8tcmVzdWx0c2ApO1xuICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICBjb25zdCBodG1sID0gYDxwIGNsYXNzPVwibXVsdGlzZWxlY3RfX29wdGlvbnMtLW5vLXJlc3VsdHNcIj4ke3RoaXMuX25vUmVzdWx0c308L3A+YDtcbiAgICAgICAgIWRvbSAmJiB0aGlzLl9kb21FbGVtZW50cy5vcHRpb25zQ29udGFpbmVyTGlzdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20gJiYgZG9tLnBhcmVudE5vZGUgJiYgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzZXRNdWx0aVNlbGVjdCgpIHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jdXN0b20tbXVsdGktc2VsZWN0XCIpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBjb25zdCBpY29uaWNNdWx0aVNlbGVjdEVsZW1lbnQgPSBuZXcgSWNvbmljTXVsdGlTZWxlY3Qoe1xuICAgICAgICAgICAgICAgIHNlbGVjdDogXCIjXCIgKyBlbC5pZCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaWRuZXl3bS9pY29uaWMtbXVsdGlzZWxlY3QvaXNzdWVzLzEwXG4gICAgICAgICAgICBpY29uaWNNdWx0aVNlbGVjdEVsZW1lbnQuc3Vic2NyaWJlKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2dC5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ0FERF9PUFRJT04nOlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGljb25pY011bHRpU2VsZWN0RWxlbWVudC5fc2VsZWN0Q29udGFpbmVyLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaWNvbmljTXVsdGlTZWxlY3RFbGVtZW50Ll9zZWxlY3RDb250YWluZXIub3B0aW9uc1tpXS52YWx1ZSA9PSBldnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25pY011bHRpU2VsZWN0RWxlbWVudC5fc2VsZWN0Q29udGFpbmVyLm9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uaWNNdWx0aVNlbGVjdEVsZW1lbnQuX3NlbGVjdENvbnRhaW5lci5vcHRpb25zW2ldLnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX09QVElPTic6XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWNvbmljTXVsdGlTZWxlY3RFbGVtZW50Ll9zZWxlY3RDb250YWluZXIub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpY29uaWNNdWx0aVNlbGVjdEVsZW1lbnQuX3NlbGVjdENvbnRhaW5lci5vcHRpb25zW2ldLnZhbHVlID09IGV2dC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbmljTXVsdGlTZWxlY3RFbGVtZW50Ll9zZWxlY3RDb250YWluZXIub3B0aW9uc1tpXS5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uaWNNdWx0aVNlbGVjdEVsZW1lbnQuX3NlbGVjdENvbnRhaW5lci5vcHRpb25zW2ldLnJlbW92ZUF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpY29uaWNNdWx0aVNlbGVjdEVsZW1lbnQuaW5pdCgpO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICAvLyAgIERpc2FibGUgdGhlIEljb25pY011bHRpU2VsZWN0IGZvciBub3cuIFdlJ3JlIG5vdCBhbGx0IGhhdFxuXG4gICAgLy8gc2V0TXVsdGlTZWxlY3QoKVxuXG4gICAgLy8gaHRteC5vbihcImh0bXg6YWZ0ZXJTZXR0bGVcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgLy8gICAgIHNldE11bHRpU2VsZWN0KClcbiAgICAvLyB9KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/ui/multi_select.js\n");

/***/ }),

/***/ "./assets/js/ui/multiple.js":
/*!**********************************!*\
  !*** ./assets/js/ui/multiple.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n // Handles fields with multiple values\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var multiple = function multiple() {\n    // Delete a value from the field\n    var deleteFormValue = function deleteFormValue(e) {\n      var formField = e.target.closest(\"div.form-values\");\n      e.target.closest(\"div.form-value\").remove();\n      var length = Array.from(formField.children).length;\n\n      for (var i = 0; i < length; i++) {\n        var input = formField.children[i].querySelector(\".form-control\");\n        var name = input.getAttribute(\"name\");\n        name = name.replace(/\\[.*\\]/, \"\");\n        input.setAttribute(\"name\", name + \"[\" + i + \"]\");\n      }\n    }; // Add a new value to the field\n\n\n    var addFormValue = function addFormValue(e) {\n      var formField = e.target.closest(\"div.form-values\");\n      var formValue = formField.lastElementChild;\n      var length = Array.from(formField.children).length;\n      var node = formValue.cloneNode(true);\n      formValue.querySelector(\".form-control\").value = \"\";\n      var input = formValue.querySelector(\".form-control\");\n      var inputName = input.getAttribute(\"name\");\n      inputName = inputName.replace(/\\[.*\\]/, \"\");\n      input.setAttribute(\"name\", inputName + \"[\" + length + \"]\");\n      var classList = node.querySelector(\"button.form-value-add\").classList;\n      classList.remove(\"form-value-add\");\n      classList.remove(\"btn-outline-primary\");\n      classList.add(\"btn-link-muted\");\n      classList.add(\"form-value-delete\");\n      classList = node.querySelector(\"i.if-add\").classList;\n      classList.remove(\"if-add\");\n      classList.add(\"if-delete\");\n      node.querySelector(\"div.sr-only\").textContent = \"Delete\";\n      node.querySelector(\"button.form-value-delete\").addEventListener(\"click\", deleteFormValue);\n      var nodes = node.querySelectorAll(\".is-invalid\");\n      nodes.forEach(function (item) {\n        item.classList.remove(\"is-invalid\");\n      });\n      formValue.before(node);\n    };\n\n    document.querySelectorAll(\"button.form-value-delete\").forEach(function (el) {\n      return el.addEventListener(\"click\", deleteFormValue);\n    });\n    document.querySelectorAll(\"button.form-value-add\").forEach(function (el) {\n      return el.addEventListener(\"click\", addFormValue);\n    });\n  }; // Init event listeners whenever HTMX swaps in a card-collapsible having a form element.\n\n\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    var item = evt.detail.target.children.item(0);\n\n    if (item && item.nodeName && item.nodeName.toLowerCase() == \"form\") {\n      multiple();\n    }\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvbXVsdGlwbGUuanM/NzdhZCJdLCJuYW1lcyI6WyJtdWx0aXBsZSIsImRlbGV0ZUZvcm1WYWx1ZSIsImUiLCJmb3JtRmllbGQiLCJ0YXJnZXQiLCJjbG9zZXN0IiwicmVtb3ZlIiwibGVuZ3RoIiwiQXJyYXkiLCJmcm9tIiwiY2hpbGRyZW4iLCJpIiwiaW5wdXQiLCJxdWVyeVNlbGVjdG9yIiwibmFtZSIsImdldEF0dHJpYnV0ZSIsInJlcGxhY2UiLCJzZXRBdHRyaWJ1dGUiLCJhZGRGb3JtVmFsdWUiLCJmb3JtVmFsdWUiLCJsYXN0RWxlbWVudENoaWxkIiwibm9kZSIsImNsb25lTm9kZSIsInZhbHVlIiwiaW5wdXROYW1lIiwiY2xhc3NMaXN0IiwiYWRkIiwidGV4dENvbnRlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwibm9kZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsIml0ZW0iLCJiZWZvcmUiLCJkb2N1bWVudCIsImVsIiwiaHRteCIsImV2dCIsImRldGFpbCIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiXSwibWFwcGluZ3MiOiI7Ozs7OztDQUVBOztBQUNBLDZCQUFlLHNDQUFXO0FBQ3RCLE1BQU1BLFFBQVEsR0FBRyxTQUFYQSxRQUFXLEdBQU07QUFDbkI7QUFDQSxRQUFJQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQVVDLENBQVYsRUFBYTtBQUMvQixVQUFJQyxTQUFTLEdBQUdELENBQUMsQ0FBQ0UsTUFBRixDQUFTQyxPQUFULENBQWlCLGlCQUFqQixDQUFoQjtBQUNBSCxPQUFDLENBQUNFLE1BQUYsQ0FBU0MsT0FBVCxDQUFpQixnQkFBakIsRUFBbUNDLE1BQW5DO0FBQ0EsVUFBSUMsTUFBTSxHQUFHQyxLQUFLLENBQUNDLElBQU4sQ0FBV04sU0FBUyxDQUFDTyxRQUFyQixFQUErQkgsTUFBNUM7O0FBRUEsV0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFH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LFVBQUFJLEVBQUU7QUFBQSxhQUMxREEsRUFBRSxDQUFDUCxnQkFBSCxDQUFvQixPQUFwQixFQUE2QlYsWUFBN0IsQ0FEMEQ7QUFBQSxLQUE5RDtBQUdILEdBL0RELENBRHNCLENBa0V0Qjs7O0FBQ0FrQixvREFBQSxDQUFRLGtCQUFSLEVBQTRCLFVBQVNDLEdBQVQsRUFBYztBQUN0QyxRQUFJTCxJQUFJLEdBQUdLLEdBQUcsQ0FBQ0MsTUFBSixDQUFXbEMsTUFBWCxDQUFrQk0sUUFBbEIsQ0FBMkJzQixJQUEzQixDQUFnQyxDQUFoQyxDQUFYOztBQUNBLFFBQUlBLElBQUksSUFBSUEsSUFBSSxDQUFDTyxRQUFiLElBQTBCUCxJQUFJLENBQUNPLFFBQUwsQ0FBY0MsV0FBZCxNQUErQixNQUE3RCxFQUFzRTtBQUNsRXhDLGNBQVE7QUFDWDtBQUNKLEdBTEQ7QUFNSCIsImZpbGUiOiIuL2Fzc2V0cy9qcy91aS9tdWx0aXBsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodG14IGZyb20gJ2h0bXgub3JnJztcblxuLy8gSGFuZGxlcyBmaWVsZHMgd2l0aCBtdWx0aXBsZSB2YWx1ZXNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG11bHRpcGxlID0gKCkgPT4ge1xuICAgICAgICAvLyBEZWxldGUgYSB2YWx1ZSBmcm9tIHRoZSBmaWVsZFxuICAgICAgICBsZXQgZGVsZXRlRm9ybVZhbHVlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxldCBmb3JtRmllbGQgPSBlLnRhcmdldC5jbG9zZXN0KFwiZGl2LmZvcm0tdmFsdWVzXCIpXG4gICAgICAgICAgICBlLnRhcmdldC5jbG9zZXN0KFwiZGl2LmZvcm0tdmFsdWVcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gQXJyYXkuZnJvbShmb3JtRmllbGQuY2hpbGRyZW4pLmxlbmd0aFxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0ID0gZm9ybUZpZWxkLmNoaWxkcmVuW2ldLnF1ZXJ5U2VsZWN0b3IoXCIuZm9ybS1jb250cm9sXCIpXG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxbLipcXF0vLCBcIlwiKVxuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSArIFwiW1wiICsgaSArIFwiXVwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGEgbmV3IHZhbHVlIHRvIHRoZSBmaWVsZFxuICAgICAgICBsZXQgYWRkRm9ybVZhbHVlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxldCBmb3JtRmllbGQgPSBlLnRhcmdldC5jbG9zZXN0KFwiZGl2LmZvcm0tdmFsdWVzXCIpXG4gICAgICAgICAgICBsZXQgZm9ybVZhbHVlID0gZm9ybUZpZWxkLmxhc3RFbGVtZW50Q2hpbGRcblxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IEFycmF5LmZyb20oZm9ybUZpZWxkLmNoaWxkcmVuKS5sZW5ndGhcblxuICAgICAgICAgICAgbGV0IG5vZGUgPSBmb3JtVmFsdWUuY2xvbmVOb2RlKHRydWUpXG5cbiAgICAgICAgICAgIGZvcm1WYWx1ZS5xdWVyeVNlbGVjdG9yKFwiLmZvcm0tY29udHJvbFwiKVxuICAgICAgICAgICAgICAgICAgICAudmFsdWUgPSBcIlwiXG5cbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm1WYWx1ZS5xdWVyeVNlbGVjdG9yKFwiLmZvcm0tY29udHJvbFwiKVxuICAgICAgICAgICAgbGV0IGlucHV0TmFtZSA9IGlucHV0LmdldEF0dHJpYnV0ZShcIm5hbWVcIilcbiAgICAgICAgICAgIGlucHV0TmFtZSA9IGlucHV0TmFtZS5yZXBsYWNlKC9cXFsuKlxcXS8sIFwiXCIpXG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGlucHV0TmFtZSArIFwiW1wiICsgbGVuZ3RoICsgXCJdXCIpXG5cbiAgICAgICAgICAgIGxldCBjbGFzc0xpc3QgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uZm9ybS12YWx1ZS1hZGRcIikuY2xhc3NMaXN0XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKFwiZm9ybS12YWx1ZS1hZGRcIilcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoXCJidG4tb3V0bGluZS1wcmltYXJ5XCIpXG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKFwiYnRuLWxpbmstbXV0ZWRcIilcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoXCJmb3JtLXZhbHVlLWRlbGV0ZVwiKVxuXG4gICAgICAgICAgICBjbGFzc0xpc3QgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJpLmlmLWFkZFwiKS5jbGFzc0xpc3RcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoXCJpZi1hZGRcIilcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoXCJpZi1kZWxldGVcIilcblxuICAgICAgICAgICAgbm9kZS5xdWVyeVNlbGVjdG9yKFwiZGl2LnNyLW9ubHlcIikudGV4dENvbnRlbnQgPSBcIkRlbGV0ZVwiXG5cbiAgICAgICAgICAgIG5vZGUucXVlcnlTZWxlY3RvcihcImJ1dHRvbi5mb3JtLXZhbHVlLWRlbGV0ZVwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZGVsZXRlRm9ybVZhbHVlKVxuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuaXMtaW52YWxpZFwiKVxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtaW52YWxpZFwiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgZm9ybVZhbHVlLmJlZm9yZShub2RlKVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJ1dHRvbi5mb3JtLXZhbHVlLWRlbGV0ZVwiKS5mb3JFYWNoKCBlbCA9PlxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGRlbGV0ZUZvcm1WYWx1ZSlcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJidXR0b24uZm9ybS12YWx1ZS1hZGRcIikuZm9yRWFjaCggZWwgPT5cbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhZGRGb3JtVmFsdWUpXG4gICAgICAgIClcbiAgICB9O1xuXG4gICAgLy8gSW5pdCBldmVudCBsaXN0ZW5lcnMgd2hlbmV2ZXIgSFRNWCBzd2FwcyBpbiBhIGNhcmQtY29sbGFwc2libGUgaGF2aW5nIGEgZm9ybSBlbGVtZW50LlxuICAgIGh0bXgub24oXCJodG14OmFmdGVyU2V0dGxlXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBsZXQgaXRlbSA9IGV2dC5kZXRhaWwudGFyZ2V0LmNoaWxkcmVuLml0ZW0oMClcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5ub2RlTmFtZSAmJiAoaXRlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgbXVsdGlwbGUoKVxuICAgICAgICB9XG4gICAgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/ui/multiple.js\n");

/***/ }),

/***/ "./assets/js/ui/radio_card.js":
/*!************************************!*\
  !*** ./assets/js/ui/radio_card.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var toggleSelected = function toggleSelected(evt) {\n    var group = evt.currentTarget.closest('.radio-card-group');\n    var cards = group.querySelectorAll('.c-radio-card');\n    cards.forEach(function (card) {\n      card.setAttribute('aria-selected', 'false');\n      card.classList.remove('c-radio-card--selected');\n    });\n    evt.currentTarget.setAttribute('aria-selected', 'true');\n    evt.currentTarget.classList.add('c-radio-card--selected');\n  };\n\n  var addEvents = function addEvents() {\n    document.querySelectorAll('.radio-card-group .c-radio-card').forEach(function (card) {\n      return card.addEventListener('click', toggleSelected);\n    });\n  };\n\n  addEvents(); // TODO don't use afterSettle\n\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    addEvents();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvcmFkaW9fY2FyZC5qcz83MTc5Il0sIm5hbWVzIjpbInRvZ2dsZVNlbGVjdGVkIiwiZXZ0IiwiZ3JvdXAiLCJjdXJyZW50VGFyZ2V0IiwiY2xvc2VzdCIsImNhcmRzIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJjYXJkIiwic2V0QXR0cmlidXRlIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiYWRkIiwiYWRkRXZlbnRzIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaHRteCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQSw2QkFBZSxzQ0FBWTtBQUN2QixNQUFJQSxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQVNDLEdBQVQsRUFBYztBQUMvQixRQUFJQyxLQUFLLEdBQUdELEdBQUcsQ0FBQ0UsYUFBSixDQUFrQkMsT0FBbEIsQ0FBMEIsbUJBQTFCLENBQVo7QUFDQSxRQUFJQyxLQUFLLEdBQUdILEtBQUssQ0FBQ0ksZ0JBQU4sQ0FBdUIsZUFBdkIsQ0FBWjtBQUNBRCxTQUFLLENBQUNFLE9BQU4sQ0FBYyxVQUFTQyxJQUFULEVBQWU7QUFDekJBLFVBQUksQ0FBQ0MsWUFBTCxDQUFrQixlQUFsQixFQUFtQyxPQUFuQztBQUNBRCxVQUFJLENBQUNFLFNBQUwsQ0FBZUMsTUFBZixDQUFzQix3QkFBdEI7QUFDSCxLQUhEO0FBSUFWLE9BQUcsQ0FBQ0UsYUFBSixDQUFrQk0sWUFBbEIsQ0FBK0IsZUFBL0IsRUFBZ0QsTUFBaEQ7QUFDQVIsT0FBRyxDQUFDRSxhQUFKLENBQWtCTyxTQUFsQixDQUE0QkUsR0FBNUIsQ0FBZ0Msd0JBQWhDO0FBQ0gsR0FURDs7QUFXQSxNQUFJQyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxHQUFXO0FBQ3ZCQyxZQUFRLENBQUNSLGdCQUFULENBQTBCLGlDQUExQixFQUE2REMsT0FBN0QsQ0FBcUUsVUFBQUMsSUFBSTtBQUFBLGFBQ3JFQSxJQUFJLENBQUNPLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCZixjQUEvQixDQURxRTtBQUFBLEtBQXpFO0FBR0gsR0FKRDs7QUFNQWEsV0FBUyxHQWxCYyxDQW9CdkI7O0FBQ0FHLG9EQUFBLENBQVEsa0JBQVIsRUFBNEIsVUFBU2YsR0FBVCxFQUFjO0FBQ3RDWSxhQUFTO0FBQ1osR0FGRDtBQUdIIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL3JhZGlvX2NhcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHRteCBmcm9tICdodG14Lm9yZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgdG9nZ2xlU2VsZWN0ZWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbGV0IGdyb3VwID0gZXZ0LmN1cnJlbnRUYXJnZXQuY2xvc2VzdCgnLnJhZGlvLWNhcmQtZ3JvdXAnKVxuICAgICAgICBsZXQgY2FyZHMgPSBncm91cC5xdWVyeVNlbGVjdG9yQWxsKCcuYy1yYWRpby1jYXJkJylcbiAgICAgICAgY2FyZHMuZm9yRWFjaChmdW5jdGlvbihjYXJkKSB7XG4gICAgICAgICAgICBjYXJkLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgY2FyZC5jbGFzc0xpc3QucmVtb3ZlKCdjLXJhZGlvLWNhcmQtLXNlbGVjdGVkJyk7XG4gICAgICAgIH0pXG4gICAgICAgIGV2dC5jdXJyZW50VGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgIGV2dC5jdXJyZW50VGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2MtcmFkaW8tY2FyZC0tc2VsZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBsZXQgYWRkRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYWRpby1jYXJkLWdyb3VwIC5jLXJhZGlvLWNhcmQnKS5mb3JFYWNoKGNhcmQgPT5cbiAgICAgICAgICAgIGNhcmQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0b2dnbGVTZWxlY3RlZClcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGFkZEV2ZW50cygpXG5cbiAgICAvLyBUT0RPIGRvbid0IHVzZSBhZnRlclNldHRsZVxuICAgIGh0bXgub24oXCJodG14OmFmdGVyU2V0dGxlXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBhZGRFdmVudHMoKVxuICAgIH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/js/ui/radio_card.js\n");

/***/ }),

/***/ "./assets/js/ui/tabs.js":
/*!******************************!*\
  !*** ./assets/js/ui/tabs.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var tabs = document.querySelectorAll(\".bc-toolbar ul a\"); // Set the anchor in the browser nav to the active tab.\n\n  Array.from(tabs).forEach(function (link) {\n    link.addEventListener('show.bs.tab', function (evt) {\n      window.location.hash = evt.target.hash;\n    });\n  }); // Read the hash from browser nav and show the active tab.\n\n  var hash = location.hash.replace(/^#/, \"\");\n\n  if (hash) {\n    var activeTab = document.querySelector('a[href=\"#' + hash + '\"]');\n    activeTab.Tab.show();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvdGFicy5qcz8yZDRmIl0sIm5hbWVzIjpbInRhYnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJBcnJheSIsImZyb20iLCJmb3JFYWNoIiwibGluayIsImFkZEV2ZW50TGlzdGVuZXIiLCJldnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhhc2giLCJ0YXJnZXQiLCJyZXBsYWNlIiwiYWN0aXZlVGFiIiwicXVlcnlTZWxlY3RvciIsIlRhYiIsInNob3ciXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2QkFBZSxzQ0FBWTtBQUN2QixNQUFJQSxJQUFJLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsa0JBQTFCLENBQVgsQ0FEdUIsQ0FHdkI7O0FBQ0FDLE9BQUssQ0FBQ0MsSUFBTixDQUFXSixJQUFYLEVBQWlCSyxPQUFqQixDQUF5QixVQUFVQyxJQUFWLEVBQWdCO0FBQ3JDQSxRQUFJLENBQUNDLGdCQUFMLENBQXNCLGFBQXRCLEVBQXFDLFVBQVVDLEdBQVYsRUFBZTtBQUNoREMsWUFBTSxDQUFDQyxRQUFQLENBQWdCQyxJQUFoQixHQUF1QkgsR0FBRyxDQUFDSSxNQUFKLENBQVdELElBQWxDO0FBQ0gsS0FGRDtBQUdILEdBSkQsRUFKdUIsQ0FVdkI7O0FBQ0EsTUFBSUEsSUFBSSxHQUFHRCxRQUFRLENBQUNDLElBQVQsQ0FBY0UsT0FBZCxDQUFzQixJQUF0QixFQUE0QixFQUE1QixDQUFYOztBQUNBLE1BQUlGLElBQUosRUFBVTtBQUNOLFFBQUlHLFNBQVMsR0FBSWIsUUFBUSxDQUFDYyxhQUFULENBQXVCLGNBQWNKLElBQWQsR0FBcUIsSUFBNUMsQ0FBakI7QUFDQUcsYUFBUyxDQUFDRSxHQUFWLENBQWNDLElBQWQ7QUFDSDtBQUNKIiwiZmlsZSI6Ii4vYXNzZXRzL2pzL3VpL3RhYnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHRhYnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmJjLXRvb2xiYXIgdWwgYVwiKVxuXG4gICAgLy8gU2V0IHRoZSBhbmNob3IgaW4gdGhlIGJyb3dzZXIgbmF2IHRvIHRoZSBhY3RpdmUgdGFiLlxuICAgIEFycmF5LmZyb20odGFicykuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ3Nob3cuYnMudGFiJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBldnQudGFyZ2V0Lmhhc2g7XG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIFJlYWQgdGhlIGhhc2ggZnJvbSBicm93c2VyIG5hdiBhbmQgc2hvdyB0aGUgYWN0aXZlIHRhYi5cbiAgICBsZXQgaGFzaCA9IGxvY2F0aW9uLmhhc2gucmVwbGFjZSgvXiMvLCBcIlwiKVxuICAgIGlmIChoYXNoKSB7XG4gICAgICAgIGxldCBhY3RpdmVUYWIgPSAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYVtocmVmPVwiIycgKyBoYXNoICsgJ1wiXScpO1xuICAgICAgICBhY3RpdmVUYWIuVGFiLnNob3coKTtcbiAgICB9XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/ui/tabs.js\n");

/***/ }),

/***/ "./assets/js/ui/toast.js":
/*!*******************************!*\
  !*** ./assets/js/ui/toast.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! htmx.org */ \"./node_modules/htmx.org/dist/htmx.min.js\");\n/* harmony import */ var htmx_org__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(htmx_org__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  var dismissToast = function dismissToast(evt) {\n    evt.currentTarget.closest('.bc-toast').classList.add('d-none');\n  };\n\n  var addEvents = function addEvents() {\n    document.querySelectorAll('.bc-toast .toast-dismiss').forEach(function (btn) {\n      return btn.addEventListener('click', dismissToast);\n    });\n  };\n\n  addEvents(); // TODO don't use afterSettle\n\n  htmx_org__WEBPACK_IMPORTED_MODULE_0___default().on(\"htmx:afterSettle\", function (evt) {\n    addEvents();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdWkvdG9hc3QuanM/MDY0YiJdLCJuYW1lcyI6WyJkaXNtaXNzVG9hc3QiLCJldnQiLCJjdXJyZW50VGFyZ2V0IiwiY2xvc2VzdCIsImNsYXNzTGlzdCIsImFkZCIsImFkZEV2ZW50cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJidG4iLCJhZGRFdmVudExpc3RlbmVyIiwiaHRteCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQSw2QkFBZSxzQ0FBWTtBQUN2QixNQUFJQSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFTQyxHQUFULEVBQWM7QUFDN0JBLE9BQUcsQ0FBQ0MsYUFBSixDQUFrQkMsT0FBbEIsQ0FBMEIsV0FBMUIsRUFBdUNDLFNBQXZDLENBQWlEQyxHQUFqRCxDQUFxRCxRQUFyRDtBQUNILEdBRkQ7O0FBSUEsTUFBSUMsU0FBUyxHQUFHLFNBQVpBLFNBQVksR0FBVztBQUN2QkMsWUFBUSxDQUFDQyxnQkFBVCxDQUEwQiwwQkFBMUIsRUFBc0RDLE9BQXRELENBQThELFVBQUFDLEdBQUc7QUFBQSxhQUM3REEsR0FBRyxDQUFDQyxnQkFBSixDQUFxQixPQUFyQixFQUE4QlgsWUFBOUIsQ0FENkQ7QUFBQSxLQUFqRTtBQUdILEdBSkQ7O0FBTUFNLFdBQVMsR0FYYyxDQWF2Qjs7QUFDQU0sb0RBQUEsQ0FBUSxrQkFBUixFQUE0QixVQUFTWCxHQUFULEVBQWM7QUFDdENLLGFBQVM7QUFDWixHQUZEO0FBR0giLCJmaWxlIjoiLi9hc3NldHMvanMvdWkvdG9hc3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHRteCBmcm9tICdodG14Lm9yZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgZGlzbWlzc1RvYXN0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGV2dC5jdXJyZW50VGFyZ2V0LmNsb3Nlc3QoJy5iYy10b2FzdCcpLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpXG4gICAgfVxuXG4gICAgbGV0IGFkZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYmMtdG9hc3QgLnRvYXN0LWRpc21pc3MnKS5mb3JFYWNoKGJ0biA9PlxuICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZGlzbWlzc1RvYXN0KVxuICAgICAgICApXG4gICAgfVxuXG4gICAgYWRkRXZlbnRzKClcblxuICAgIC8vIFRPRE8gZG9uJ3QgdXNlIGFmdGVyU2V0dGxlXG4gICAgaHRteC5vbihcImh0bXg6YWZ0ZXJTZXR0bGVcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGFkZEV2ZW50cygpXG4gICAgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/js/ui/toast.js\n");

/***/ }),

/***/ "./node_modules/bootstrap.native/dist/bootstrap-native-v4.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native-v4.js ***!
  \*******************************************************************/
/***/ (function(module) {

eval("/*!\n  * Native JavaScript for Bootstrap v4.0.6 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2021  dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  var transitionEndEvent = 'webkitTransition' in document.head.style ? 'webkitTransitionEnd' : 'transitionend';\n\n  var supportTransition = 'webkitTransition' in document.head.style || 'transition' in document.head.style;\n\n  var transitionDuration = 'webkitTransition' in document.head.style ? 'webkitTransitionDuration' : 'transitionDuration';\n\n  var transitionProperty = 'webkitTransition' in document.head.style ? 'webkitTransitionProperty' : 'transitionProperty';\n\n  function getElementTransitionDuration(element) {\n    var computedStyle = getComputedStyle(element);\n    var propertyValue = computedStyle[transitionProperty];\n    var durationValue = computedStyle[transitionDuration];\n    var durationScale = durationValue.includes('ms') ? 1 : 1000;\n    var duration = supportTransition && propertyValue && propertyValue !== 'none'\n      ? parseFloat(durationValue) * durationScale : 0;\n\n    return !Number.isNaN(duration) ? duration : 0;\n  }\n\n  function emulateTransitionEnd(element, handler) {\n    var called = 0;\n    var endEvent = new Event(transitionEndEvent);\n    var duration = getElementTransitionDuration(element);\n\n    if (duration) {\n      element.addEventListener(transitionEndEvent, function transitionEndWrapper(e) {\n        if (e.target === element) {\n          handler.apply(element, [e]);\n          element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n          called = 1;\n        }\n      });\n      setTimeout(function () {\n        if (!called) { element.dispatchEvent(endEvent); }\n      }, duration + 17);\n    } else {\n      handler.apply(element, [endEvent]);\n    }\n  }\n\n  function queryElement(selector, parent) {\n    var lookUp = parent && parent instanceof Element ? parent : document;\n    return selector instanceof Element ? selector : lookUp.querySelector(selector);\n  }\n\n  function bootstrapCustomEvent(eventType, componentName, eventProperties) {\n    var OriginalCustomEvent = new CustomEvent((eventType + \".bs.\" + componentName), { cancelable: true });\n\n    if (typeof eventProperties !== 'undefined') {\n      Object.keys(eventProperties).forEach(function (key) {\n        Object.defineProperty(OriginalCustomEvent, key, {\n          value: eventProperties[key],\n        });\n      });\n    }\n    return OriginalCustomEvent;\n  }\n\n  function dispatchCustomEvent(customEvent) {\n    if (this) { this.dispatchEvent(customEvent); }\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Alert\n  -------------------------------------------- */\n\n  // ALERT DEFINITION\n  // ================\n\n  function Alert(elem) {\n    var element;\n\n    // bind\n    var self = this;\n\n    // the target alert\n    var alert;\n\n    // custom events\n    var closeCustomEvent = bootstrapCustomEvent('close', 'alert');\n    var closedCustomEvent = bootstrapCustomEvent('closed', 'alert');\n\n    // private methods\n    function triggerHandler() {\n      if (alert.classList.contains('fade')) { emulateTransitionEnd(alert, transitionEndHandler); }\n      else { transitionEndHandler(); }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action]('click', clickHandler, false);\n    }\n\n    // event handlers\n    function clickHandler(e) {\n      alert = e && e.target.closest('.alert');\n      element = queryElement('[data-dismiss=\"alert\"]', alert);\n      if (element && alert && (element === e.target || element.contains(e.target))) { self.close(); }\n    }\n    function transitionEndHandler() {\n      toggleEvents();\n      alert.parentNode.removeChild(alert);\n      dispatchCustomEvent.call(alert, closedCustomEvent);\n    }\n\n    // PUBLIC METHODS\n    self.close = function () {\n      if (alert && element && alert.classList.contains('show')) {\n        dispatchCustomEvent.call(alert, closeCustomEvent);\n        if (closeCustomEvent.defaultPrevented) { return; }\n        self.dispose();\n        alert.classList.remove('show');\n        triggerHandler();\n      }\n    };\n\n    self.dispose = function () {\n      toggleEvents();\n      delete element.Alert;\n    };\n\n    // INIT\n    // initialization element\n    element = queryElement(elem);\n\n    // find the target alert\n    alert = element.closest('.alert');\n\n    // reset on re-init\n    if (element.Alert) { element.Alert.dispose(); }\n\n    // prevent adding event handlers twice\n    if (!element.Alert) { toggleEvents(1); }\n\n    // store init object within target element\n    self.element = element;\n    element.Alert = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Button\n  ---------------------------------------------*/\n\n  // BUTTON DEFINITION\n  // =================\n\n  function Button(elem) {\n    var element;\n\n    // bind and labels\n    var self = this;\n    var labels;\n\n    // changeEvent\n    var changeCustomEvent = bootstrapCustomEvent('change', 'button');\n\n    // private methods\n    function toggle(e) {\n      var eTarget = e.target;\n      var parentLabel = eTarget.closest('LABEL'); // the .btn label\n      var label = null;\n\n      if (eTarget.tagName === 'LABEL') {\n        label = eTarget;\n      } else if (parentLabel) {\n        label = parentLabel;\n      }\n\n      // current input\n      var input = label && label.getElementsByTagName('INPUT')[0];\n\n      // invalidate if no input\n      if (!input) { return; }\n\n      dispatchCustomEvent.call(input, changeCustomEvent); // trigger the change for the input\n      dispatchCustomEvent.call(element, changeCustomEvent); // trigger the change for the btn-group\n\n      // manage the dom manipulation\n      if (input.type === 'checkbox') { // checkboxes\n        if (changeCustomEvent.defaultPrevented) { return; } // discontinue when defaultPrevented is true\n\n        if (!input.checked) {\n          label.classList.add('active');\n          input.getAttribute('checked');\n          input.setAttribute('checked', 'checked');\n          input.checked = true;\n        } else {\n          label.classList.remove('active');\n          input.getAttribute('checked');\n          input.removeAttribute('checked');\n          input.checked = false;\n        }\n\n        if (!element.toggled) { // prevent triggering the event twice\n          element.toggled = true;\n        }\n      }\n\n      if (input.type === 'radio' && !element.toggled) { // radio buttons\n        if (changeCustomEvent.defaultPrevented) { return; }\n        // don't trigger if already active\n        // (the OR condition is a hack to check if the buttons were selected\n        // with key press and NOT mouse click)\n        if (!input.checked || (e.screenX === 0 && e.screenY === 0)) {\n          label.classList.add('active');\n          label.classList.add('focus');\n          input.setAttribute('checked', 'checked');\n          input.checked = true;\n\n          element.toggled = true;\n          Array.from(labels).forEach(function (otherLabel) {\n            var otherInput = otherLabel.getElementsByTagName('INPUT')[0];\n            if (otherLabel !== label && otherLabel.classList.contains('active')) {\n              dispatchCustomEvent.call(otherInput, changeCustomEvent); // trigger the change\n              otherLabel.classList.remove('active');\n              otherInput.removeAttribute('checked');\n              otherInput.checked = false;\n            }\n          });\n        }\n      }\n      setTimeout(function () { element.toggled = false; }, 50);\n    }\n\n    // handlers\n    function keyHandler(e) {\n      var key = e.which || e.keyCode;\n      if (key === 32 && e.target === document.activeElement) { toggle(e); }\n    }\n    function preventScroll(e) {\n      var key = e.which || e.keyCode;\n      if (key === 32) { e.preventDefault(); }\n    }\n    function focusToggle(e) {\n      if (e.target.tagName === 'INPUT') {\n        var action = e.type === 'focusin' ? 'add' : 'remove';\n        e.target.closest('.btn').classList[action]('focus');\n      }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action]('click', toggle, false);\n      element[action]('keyup', keyHandler, false);\n      element[action]('keydown', preventScroll, false);\n      element[action]('focusin', focusToggle, false);\n      element[action]('focusout', focusToggle, false);\n    }\n\n    // public method\n    self.dispose = function () {\n      toggleEvents();\n      delete element.Button;\n    };\n\n    // init\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Button) { element.Button.dispose(); }\n\n    labels = element.getElementsByClassName('btn');\n\n    // invalidate\n    if (!labels.length) { return; }\n\n    // prevent adding event handlers twice\n    if (!element.Button) { toggleEvents(1); }\n\n    // set initial toggled state\n    // toggled makes sure to prevent triggering twice the change.bs.button events\n    element.toggled = false;\n\n    // associate target with init object\n    element.Button = self;\n\n    // activate items on load\n    Array.from(labels).forEach(function (btn) {\n      var hasChecked = queryElement('input:checked', btn);\n      if (!btn.classList.contains('active') && hasChecked) {\n        btn.classList.add('active');\n      }\n      if (btn.classList.contains('active') && !hasChecked) {\n        btn.classList.remove('active');\n      }\n    });\n  }\n\n  var mouseHoverEvents = ('onmouseleave' in document) ? ['mouseenter', 'mouseleave'] : ['mouseover', 'mouseout'];\n\n  var addEventListener = 'addEventListener';\n\n  var removeEventListener = 'removeEventListener';\n\n  var supportPassive = (function () {\n    var result = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          result = true;\n          return result;\n        },\n      });\n      document[addEventListener]('DOMContentLoaded', function wrap() {\n        document[removeEventListener]('DOMContentLoaded', wrap, opts);\n      }, opts);\n    } catch (e) {\n      throw Error('Passive events are not supported');\n    }\n\n    return result;\n  })();\n\n  // general event options\n\n  var passiveHandler = supportPassive ? { passive: true } : false;\n\n  function isElementInScrollRange(element) {\n    var bcr = element.getBoundingClientRect();\n    var viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n    return bcr.top <= viewportHeight && bcr.bottom >= 0; // bottom && top\n  }\n\n  function reflow(element) {\n    return element.offsetHeight;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Carousel\n  ----------------------------------------------- */\n\n  // CAROUSEL DEFINITION\n  // ===================\n\n  function Carousel(elem, opsInput) {\n    var assign, assign$1, assign$2;\n\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // internal variables\n    var vars;\n    var ops;\n\n    // custom events\n    var slideCustomEvent;\n    var slidCustomEvent;\n\n    // carousel elements\n    var slides;\n    var leftArrow;\n    var rightArrow;\n    var indicator;\n    var indicators;\n\n    // handlers\n    function pauseHandler() {\n      if (ops.interval !== false && !element.classList.contains('paused')) {\n        element.classList.add('paused');\n        if (!vars.isSliding) {\n          clearInterval(vars.timer);\n          vars.timer = null;\n        }\n      }\n    }\n    function resumeHandler() {\n      if (ops.interval !== false && element.classList.contains('paused')) {\n        element.classList.remove('paused');\n        if (!vars.isSliding) {\n          clearInterval(vars.timer);\n          vars.timer = null;\n          self.cycle();\n        }\n      }\n    }\n    function indicatorHandler(e) {\n      e.preventDefault();\n      if (vars.isSliding) { return; }\n\n      var eventTarget = e.target; // event target | the current active item\n\n      if (eventTarget && !eventTarget.classList.contains('active') && eventTarget.getAttribute('data-slide-to')) {\n        vars.index = +(eventTarget.getAttribute('data-slide-to'));\n      } else { return; }\n\n      self.slideTo(vars.index); // Do the slide\n    }\n    function controlsHandler(e) {\n      e.preventDefault();\n      if (vars.isSliding) { return; }\n\n      var eventTarget = e.currentTarget || e.srcElement;\n\n      if (eventTarget === rightArrow) {\n        vars.index += 1;\n      } else if (eventTarget === leftArrow) {\n        vars.index -= 1;\n      }\n\n      self.slideTo(vars.index); // Do the slide\n    }\n    function keyHandler(ref) {\n      var which = ref.which;\n\n      if (vars.isSliding) { return; }\n      switch (which) {\n        case 39:\n          vars.index += 1;\n          break;\n        case 37:\n          vars.index -= 1;\n          break;\n        default: return;\n      }\n      self.slideTo(vars.index); // Do the slide\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      if (ops.pause && ops.interval) {\n        element[action](mouseHoverEvents[0], pauseHandler, false);\n        element[action](mouseHoverEvents[1], resumeHandler, false);\n        element[action]('touchstart', pauseHandler, passiveHandler);\n        element[action]('touchend', resumeHandler, passiveHandler);\n      }\n\n      if (ops.touch && slides.length > 1) { element[action]('touchstart', touchDownHandler, passiveHandler); }\n\n      if (rightArrow) { rightArrow[action]('click', controlsHandler, false); }\n      if (leftArrow) { leftArrow[action]('click', controlsHandler, false); }\n\n      if (indicator) { indicator[action]('click', indicatorHandler, false); }\n      if (ops.keyboard) { window[action]('keydown', keyHandler, false); }\n    }\n    // touch events\n    function toggleTouchEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action]('touchmove', touchMoveHandler, passiveHandler);\n      element[action]('touchend', touchEndHandler, passiveHandler);\n    }\n    function touchDownHandler(e) {\n      if (vars.isTouch) { return; }\n\n      vars.touchPosition.startX = e.changedTouches[0].pageX;\n\n      if (element.contains(e.target)) {\n        vars.isTouch = true;\n        toggleTouchEvents(1);\n      }\n    }\n    function touchMoveHandler(e) {\n      if (!vars.isTouch) { e.preventDefault(); return; }\n\n      vars.touchPosition.currentX = e.changedTouches[0].pageX;\n\n      // cancel touch if more than one changedTouches detected\n      if (e.type === 'touchmove' && e.changedTouches.length > 1) {\n        e.preventDefault();\n      }\n    }\n    function touchEndHandler(e) {\n      if (!vars.isTouch || vars.isSliding) { return; }\n\n      vars.touchPosition.endX = vars.touchPosition.currentX || e.changedTouches[0].pageX;\n\n      if (vars.isTouch) {\n        if ((!element.contains(e.target) || !element.contains(e.relatedTarget))\n            && Math.abs(vars.touchPosition.startX - vars.touchPosition.endX) < 75) {\n          return;\n        }\n        if (vars.touchPosition.currentX < vars.touchPosition.startX) {\n          vars.index += 1;\n        } else if (vars.touchPosition.currentX > vars.touchPosition.startX) {\n          vars.index -= 1;\n        }\n        vars.isTouch = false;\n        self.slideTo(vars.index);\n\n        toggleTouchEvents(); // remove\n      }\n    }\n    // private methods\n    function setActivePage(pageIndex) { // indicators\n      Array.from(indicators).forEach(function (x) { return x.classList.remove('active'); });\n      if (indicators[pageIndex]) { indicators[pageIndex].classList.add('active'); }\n    }\n    function transitionEndHandler(e) {\n      if (vars.touchPosition) {\n        var next = vars.index;\n        var timeout = e && e.target !== slides[next] ? e.elapsedTime * 1000 + 100 : 20;\n        var activeItem = self.getActiveIndex();\n        var orientation = vars.direction === 'left' ? 'next' : 'prev';\n\n        if (vars.isSliding) {\n          setTimeout(function () {\n            if (vars.touchPosition) {\n              vars.isSliding = false;\n\n              slides[next].classList.add('active');\n              slides[activeItem].classList.remove('active');\n\n              slides[next].classList.remove((\"carousel-item-\" + orientation));\n              slides[next].classList.remove((\"carousel-item-\" + (vars.direction)));\n              slides[activeItem].classList.remove((\"carousel-item-\" + (vars.direction)));\n\n              dispatchCustomEvent.call(element, slidCustomEvent);\n              // check for element, might have been disposed\n              if (!document.hidden && ops.interval && !element.classList.contains('paused')) {\n                self.cycle();\n              }\n            }\n          }, timeout);\n        }\n      }\n    }\n\n    // public methods\n    self.cycle = function () {\n      if (vars.timer) {\n        clearInterval(vars.timer);\n        vars.timer = null;\n      }\n\n      vars.timer = setInterval(function () {\n        var idx = vars.index || self.getActiveIndex();\n        if (isElementInScrollRange(element)) {\n          idx += 1;\n          self.slideTo(idx);\n        }\n      }, ops.interval);\n    };\n    self.slideTo = function (idx) {\n      if (vars.isSliding) { return; } // when controled via methods, make sure to check again\n\n      // the current active, orientation, event eventProperties\n      var activeItem = self.getActiveIndex();\n      var next = idx;\n\n      // first return if we're on the same item #227\n      if (activeItem === next) {\n        return;\n      // or determine slide direction\n      } if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n        vars.direction = 'left'; // next\n      } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n        vars.direction = 'right'; // prev\n      }\n\n      // find the right next index\n      if (next < 0) { next = slides.length - 1; }\n      else if (next >= slides.length) { next = 0; }\n\n      var orientation = vars.direction === 'left' ? 'next' : 'prev'; // determine type\n\n      var eventProperties = {\n        relatedTarget: slides[next], direction: vars.direction, from: activeItem, to: next,\n      };\n      slideCustomEvent = bootstrapCustomEvent('slide', 'carousel', eventProperties);\n      slidCustomEvent = bootstrapCustomEvent('slid', 'carousel', eventProperties);\n      dispatchCustomEvent.call(element, slideCustomEvent); // here we go with the slide\n      if (slideCustomEvent.defaultPrevented) { return; } // discontinue when prevented\n\n      // update index\n      vars.index = next;\n\n      vars.isSliding = true;\n      clearInterval(vars.timer);\n      vars.timer = null;\n      setActivePage(next);\n\n      if (getElementTransitionDuration(slides[next]) && element.classList.contains('slide')) {\n        slides[next].classList.add((\"carousel-item-\" + orientation));\n        reflow(slides[next]);\n        slides[next].classList.add((\"carousel-item-\" + (vars.direction)));\n        slides[activeItem].classList.add((\"carousel-item-\" + (vars.direction)));\n\n        emulateTransitionEnd(slides[next], transitionEndHandler);\n      } else {\n        slides[next].classList.add('active');\n        reflow(slides[next]);\n        slides[activeItem].classList.remove('active');\n        setTimeout(function () {\n          vars.isSliding = false;\n          // check for element, might have been disposed\n          if (ops.interval && element && !element.classList.contains('paused')) {\n            self.cycle();\n          }\n          dispatchCustomEvent.call(element, slidCustomEvent);\n        }, 100);\n      }\n    };\n\n    self.getActiveIndex = function () { return Array.from(slides).indexOf(element.getElementsByClassName('carousel-item active')[0]) || 0; };\n\n    self.dispose = function () {\n      var itemClasses = ['left', 'right', 'prev', 'next'];\n\n      Array.from(slides).forEach(function (slide, idx) {\n        if (slide.classList.contains('active')) { setActivePage(idx); }\n        itemClasses.forEach(function (cls) { return slide.classList.remove((\"carousel-item-\" + cls)); });\n      });\n      clearInterval(vars.timer);\n\n      toggleEvents();\n      vars = {};\n      ops = {};\n      delete element.Carousel;\n    };\n\n    // init\n\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Carousel) { element.Carousel.dispose(); }\n\n    // carousel elements\n    slides = element.getElementsByClassName('carousel-item');\n    (assign = element.getElementsByClassName('carousel-control-prev'), leftArrow = assign[0]);\n    (assign$1 = element.getElementsByClassName('carousel-control-next'), rightArrow = assign$1[0]);\n    (assign$2 = element.getElementsByClassName('carousel-indicators'), indicator = assign$2[0]);\n    indicators = (indicator && indicator.getElementsByTagName('LI')) || [];\n\n    // invalidate when not enough items\n    if (slides.length < 2) { return; }\n\n    // check options\n    // DATA API\n    var intervalAttribute = element.getAttribute('data-interval');\n    var intervalData = intervalAttribute === 'false' ? 0 : +(intervalAttribute);\n    var touchData = element.getAttribute('data-touch') === 'false' ? 0 : 1;\n    var pauseData = element.getAttribute('data-pause') === 'hover' || false;\n    var keyboardData = element.getAttribute('data-keyboard') === 'true' || false;\n\n    // JS options\n    var intervalOption = options.interval;\n    var touchOption = options.touch;\n\n    // set instance options\n    ops = {};\n    ops.keyboard = options.keyboard === true || keyboardData;\n    ops.pause = (options.pause === 'hover' || pauseData) ? 'hover' : false; // false / hover\n    ops.touch = touchOption || touchData;\n\n    ops.interval = 5000; // bootstrap carousel default interval\n\n    if (typeof intervalOption === 'number') { ops.interval = intervalOption; }\n    else if (intervalOption === false || intervalData === 0 || intervalData === false) {\n      ops.interval = 0;\n    } else if (!Number.isNaN(intervalData)) { ops.interval = intervalData; }\n\n    // set first slide active if none\n    if (self.getActiveIndex() < 0) {\n      if (slides.length) { slides[0].classList.add('active'); }\n      if (indicators.length) { setActivePage(0); }\n    }\n\n    // set initial state\n    vars = {};\n    vars.direction = 'left';\n    vars.index = 0;\n    vars.timer = null;\n    vars.isSliding = false;\n    vars.isTouch = false;\n    vars.touchPosition = {\n      startX: 0,\n      currentX: 0,\n      endX: 0,\n    };\n\n    // attach event handlers\n    toggleEvents(1);\n\n    // start to cycle if interval is set\n    if (ops.interval) { self.cycle(); }\n\n    // associate init object to target\n    element.Carousel = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Collapse\n  ----------------------------------------------- */\n\n  // COLLAPSE DEFINITION\n  // ===================\n\n  function Collapse(elem, opsInput) {\n    var element;\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // target practice\n    var accordion = null;\n    var collapse = null;\n    var activeCollapse;\n    var activeElement;\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    // private methods\n    function openAction(collapseElement, toggle) {\n      dispatchCustomEvent.call(collapseElement, showCustomEvent);\n      if (showCustomEvent.defaultPrevented) { return; }\n      collapseElement.isAnimating = true;\n      collapseElement.classList.add('collapsing');\n      collapseElement.classList.remove('collapse');\n      collapseElement.style.height = (collapseElement.scrollHeight) + \"px\";\n\n      emulateTransitionEnd(collapseElement, function () {\n        collapseElement.isAnimating = false;\n        collapseElement.setAttribute('aria-expanded', 'true');\n        toggle.setAttribute('aria-expanded', 'true');\n        collapseElement.classList.remove('collapsing');\n        collapseElement.classList.add('collapse');\n        collapseElement.classList.add('show');\n        collapseElement.style.height = '';\n        dispatchCustomEvent.call(collapseElement, shownCustomEvent);\n      });\n    }\n    function closeAction(collapseElement, toggle) {\n      dispatchCustomEvent.call(collapseElement, hideCustomEvent);\n      if (hideCustomEvent.defaultPrevented) { return; }\n      collapseElement.isAnimating = true;\n      collapseElement.style.height = (collapseElement.scrollHeight) + \"px\"; // set height first\n      collapseElement.classList.remove('collapse');\n      collapseElement.classList.remove('show');\n      collapseElement.classList.add('collapsing');\n      reflow(collapseElement); // force reflow to enable transition\n      collapseElement.style.height = '0px';\n\n      emulateTransitionEnd(collapseElement, function () {\n        collapseElement.isAnimating = false;\n        collapseElement.setAttribute('aria-expanded', 'false');\n        toggle.setAttribute('aria-expanded', 'false');\n        collapseElement.classList.remove('collapsing');\n        collapseElement.classList.add('collapse');\n        collapseElement.style.height = '';\n        dispatchCustomEvent.call(collapseElement, hiddenCustomEvent);\n      });\n    }\n\n    // public methods\n    self.toggle = function (e) {\n      if ((e && e.target.tagName === 'A') || element.tagName === 'A') { e.preventDefault(); }\n      if (element.contains(e.target) || e.target === element) {\n        if (!collapse.classList.contains('show')) { self.show(); }\n        else { self.hide(); }\n      }\n    };\n    self.hide = function () {\n      if (collapse.isAnimating) { return; }\n      closeAction(collapse, element);\n      element.classList.add('collapsed');\n    };\n    self.show = function () {\n      var assign;\n\n      if (accordion) {\n        (assign = accordion.getElementsByClassName('collapse show'), activeCollapse = assign[0]);\n        activeElement = activeCollapse && (queryElement((\"[data-target=\\\"#\" + (activeCollapse.id) + \"\\\"]\"), accordion)\n                      || queryElement((\"[href=\\\"#\" + (activeCollapse.id) + \"\\\"]\"), accordion));\n      }\n\n      if (!collapse.isAnimating) {\n        if (activeElement && activeCollapse !== collapse) {\n          closeAction(activeCollapse, activeElement);\n          activeElement.classList.add('collapsed');\n        }\n        openAction(collapse, element);\n        element.classList.remove('collapsed');\n      }\n    };\n    self.dispose = function () {\n      element.removeEventListener('click', self.toggle, false);\n      delete element.Collapse;\n    };\n\n    // init\n\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Collapse) { element.Collapse.dispose(); }\n\n    // DATA API\n    var accordionData = element.getAttribute('data-parent');\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'collapse');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'collapse');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'collapse');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'collapse');\n\n    // determine targets\n    collapse = queryElement(options.target || element.getAttribute('data-target') || element.getAttribute('href'));\n\n    if (collapse !== null) { collapse.isAnimating = false; }\n    var accordionSelector = options.parent || accordionData;\n    if (accordionSelector) {\n      accordion = element.closest(accordionSelector);\n    } else {\n      accordion = null;\n    }\n\n    // prevent adding event handlers twice\n    if (!element.Collapse) {\n      element.addEventListener('click', self.toggle, false);\n    }\n\n    // associate target to init object\n    element.Collapse = self;\n  }\n\n  function setFocus(element) {\n    element.focus();\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Dropdown\n  ----------------------------------------------- */\n\n  // DROPDOWN DEFINITION\n  // ===================\n\n  function Dropdown(elem, option) {\n    var element;\n\n    // bind\n    var self = this;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n    // targets\n    var relatedTarget = null;\n    var parent; var menu; var menuItems = [];\n    // option\n    var persist;\n\n    // preventDefault on empty anchor links\n    function preventEmptyAnchor(anchor) {\n      if ((anchor.href && anchor.href.slice(-1) === '#') || (anchor.parentNode && anchor.parentNode.href\n        && anchor.parentNode.href.slice(-1) === '#')) { this.preventDefault(); }\n    }\n    // toggle dismissible events\n    function toggleDismiss() {\n      var action = element.open ? 'addEventListener' : 'removeEventListener';\n      document[action]('click', dismissHandler, false);\n      document[action]('keydown', preventScroll, false);\n      document[action]('keyup', keyHandler, false);\n      document[action]('focus', dismissHandler, false);\n    }\n    // handlers\n    function dismissHandler(e) {\n      var eventTarget = e.target;\n      if (!eventTarget.getAttribute) { return; } // some weird FF bug #409\n      var hasData = ((eventTarget && (eventTarget.getAttribute('data-toggle')))\n                                  || (eventTarget.parentNode && eventTarget.parentNode.getAttribute\n                                  && eventTarget.parentNode.getAttribute('data-toggle')));\n      if (e.type === 'focus' && (eventTarget === element || eventTarget === menu || menu.contains(eventTarget))) {\n        return;\n      }\n      if ((eventTarget === menu || menu.contains(eventTarget)) && (persist || hasData)) { return; }\n\n      relatedTarget = eventTarget === element || element.contains(eventTarget) ? element : null;\n      self.hide();\n\n      preventEmptyAnchor.call(e, eventTarget);\n    }\n    function clickHandler(e) {\n      relatedTarget = element;\n      self.show();\n      preventEmptyAnchor.call(e, e.target);\n    }\n    function preventScroll(e) {\n      var key = e.which || e.keyCode;\n      if (key === 38 || key === 40) { e.preventDefault(); }\n    }\n    function keyHandler(e) {\n      var key = e.which || e.keyCode;\n      var activeItem = document.activeElement;\n      var isSameElement = activeItem === element;\n      var isInsideMenu = menu.contains(activeItem);\n      var isMenuItem = activeItem.parentNode === menu || activeItem.parentNode.parentNode === menu;\n      var idx = menuItems.indexOf(activeItem);\n\n      if (isMenuItem) { // navigate up | down\n        if (isSameElement) {\n          idx = 0;\n        } else if (key === 38) {\n          idx = idx > 1 ? idx - 1 : 0;\n        } else if (key === 40) {\n          idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n        }\n\n        if (menuItems[idx]) { setFocus(menuItems[idx]); }\n      }\n      if (((menuItems.length && isMenuItem) // menu has items\n            || (!menuItems.length && (isInsideMenu || isSameElement)) // menu might be a form\n            || !isInsideMenu) // or the focused element is not in the menu at all\n            && element.open && key === 27 // menu must be open\n      ) {\n        self.toggle();\n        relatedTarget = null;\n      }\n    }\n\n    // public methods\n    self.show = function () {\n      showCustomEvent = bootstrapCustomEvent('show', 'dropdown', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(parent, showCustomEvent);\n      if (showCustomEvent.defaultPrevented) { return; }\n\n      menu.classList.add('show');\n      parent.classList.add('show');\n      element.setAttribute('aria-expanded', true);\n      element.open = true;\n      element.removeEventListener('click', clickHandler, false);\n      setTimeout(function () {\n        setFocus(menu.getElementsByTagName('INPUT')[0] || element); // focus the first input item | element\n        toggleDismiss();\n        shownCustomEvent = bootstrapCustomEvent('shown', 'dropdown', { relatedTarget: relatedTarget });\n        dispatchCustomEvent.call(parent, shownCustomEvent);\n      }, 1);\n    };\n    self.hide = function () {\n      hideCustomEvent = bootstrapCustomEvent('hide', 'dropdown', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(parent, hideCustomEvent);\n      if (hideCustomEvent.defaultPrevented) { return; }\n\n      menu.classList.remove('show');\n      parent.classList.remove('show');\n      element.setAttribute('aria-expanded', false);\n      element.open = false;\n      toggleDismiss();\n      setFocus(element);\n      setTimeout(function () {\n        // only re-attach handler if the init is not disposed\n        if (element.Dropdown) { element.addEventListener('click', clickHandler, false); }\n      }, 1);\n\n      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'dropdown', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(parent, hiddenCustomEvent);\n    };\n    self.toggle = function () {\n      if (parent.classList.contains('show') && element.open) { self.hide(); } else { self.show(); }\n    };\n    self.dispose = function () {\n      if (parent.classList.contains('show') && element.open) { self.hide(); }\n      element.removeEventListener('click', clickHandler, false);\n      delete element.Dropdown;\n    };\n\n    // init\n\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Dropdown) { element.Dropdown.dispose(); }\n\n    // set  targets\n    parent = element.parentNode;\n    menu = queryElement('.dropdown-menu', parent);\n\n    Array.from(menu.children).forEach(function (child) {\n      if (child.children.length && child.children[0].tagName === 'A') {\n        menuItems.push(child.children[0]);\n      }\n      if (child.tagName === 'A') { menuItems.push(child); }\n    });\n\n    // prevent adding event handlers twice\n    if (!element.Dropdown) {\n      if (!('tabindex' in menu)) { menu.setAttribute('tabindex', '0'); } // Fix onblur on Chrome | Safari\n      element.addEventListener('click', clickHandler, false);\n    }\n\n    // set option\n    persist = option === true || element.getAttribute('data-persist') === 'true' || false;\n\n    // set initial state to closed\n    element.open = false;\n\n    // associate element with init object\n    element.Dropdown = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Modal\n  -------------------------------------------- */\n\n  // MODAL DEFINITION\n  // ================\n\n  function Modal(elem, opsInput) { // element can be the modal/triggering button\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind, modal\n    var self = this;\n    var modal;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n    // event targets and other\n    var relatedTarget = null;\n    var scrollBarWidth;\n    var overlay;\n    var overlayDelay;\n\n    // also find fixed-top / fixed-bottom items\n    var fixedItems;\n    var ops = {};\n\n    // private methods\n    function setScrollbar() {\n      var bodyClassList = document.body.classList;\n      var openModal = bodyClassList.contains('modal-open');\n      var bodyPad = parseInt(getComputedStyle(document.body).paddingRight, 10);\n      var docClientHeight = document.documentElement.clientHeight;\n      var docScrollHeight = document.documentElement.scrollHeight;\n      var bodyClientHeight = document.body.clientHeight;\n      var bodyScrollHeight = document.body.scrollHeight;\n      var bodyOverflow = docClientHeight !== docScrollHeight\n                      || bodyClientHeight !== bodyScrollHeight;\n      var modalOverflow = modal.clientHeight !== modal.scrollHeight;\n\n      scrollBarWidth = measureScrollbar();\n\n      modal.style.paddingRight = !modalOverflow && scrollBarWidth ? (scrollBarWidth + \"px\") : '';\n      document.body.style.paddingRight = modalOverflow || bodyOverflow\n        ? ((bodyPad + (openModal ? 0 : scrollBarWidth)) + \"px\") : '';\n\n      if (fixedItems.length) {\n        fixedItems.forEach(function (fixed) {\n          var itemPad = getComputedStyle(fixed).paddingRight;\n          fixed.style.paddingRight = modalOverflow || bodyOverflow\n            ? ((parseInt(itemPad, 10) + (openModal ? 0 : scrollBarWidth)) + \"px\")\n            : ((parseInt(itemPad, 10)) + \"px\");\n        });\n      }\n    }\n    function resetScrollbar() {\n      document.body.style.paddingRight = '';\n      modal.style.paddingRight = '';\n      if (fixedItems.length) {\n        fixedItems.forEach(function (fixed) {\n          fixed.style.paddingRight = '';\n        });\n      }\n    }\n    function measureScrollbar() {\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = 'modal-scrollbar-measure'; // this is here to stay\n      document.body.appendChild(scrollDiv);\n      var widthValue = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return widthValue;\n    }\n    function createOverlay() {\n      var newOverlay = document.createElement('div');\n      overlay = queryElement('.modal-backdrop');\n\n      if (overlay === null) {\n        newOverlay.setAttribute('class', (\"modal-backdrop\" + (ops.animation ? ' fade' : '')));\n        overlay = newOverlay;\n        document.body.appendChild(overlay);\n      }\n      return overlay;\n    }\n    function removeOverlay() {\n      overlay = queryElement('.modal-backdrop');\n      if (overlay && !document.getElementsByClassName('modal show')[0]) {\n        document.body.removeChild(overlay); overlay = null;\n      }\n      if (overlay === null) {\n        document.body.classList.remove('modal-open');\n        resetScrollbar();\n      }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      window[action]('resize', self.update, passiveHandler);\n      modal[action]('click', dismissHandler, false);\n      document[action]('keydown', keyHandler, false);\n    }\n    // triggers\n    function beforeShow() {\n      modal.style.display = 'block';\n\n      setScrollbar();\n      if (!document.getElementsByClassName('modal show')[0]) { document.body.classList.add('modal-open'); }\n\n      modal.classList.add('show');\n      modal.setAttribute('aria-hidden', false);\n\n      if (modal.classList.contains('fade')) { emulateTransitionEnd(modal, triggerShow); }\n      else { triggerShow(); }\n    }\n    function triggerShow() {\n      setFocus(modal);\n      modal.isAnimating = false;\n\n      toggleEvents(1);\n\n      shownCustomEvent = bootstrapCustomEvent('shown', 'modal', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(modal, shownCustomEvent);\n    }\n    function triggerHide(force) {\n      modal.style.display = '';\n      if (element) { setFocus(element); }\n\n      overlay = queryElement('.modal-backdrop');\n\n      // force can also be the transitionEvent object, we wanna make sure it's not\n      if (force !== 1 && overlay && overlay.classList.contains('show') && !document.getElementsByClassName('modal show')[0]) {\n        overlay.classList.remove('show');\n        emulateTransitionEnd(overlay, removeOverlay);\n      } else {\n        removeOverlay();\n      }\n\n      toggleEvents();\n\n      modal.isAnimating = false;\n\n      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'modal');\n      dispatchCustomEvent.call(modal, hiddenCustomEvent);\n    }\n    // handlers\n    function clickHandler(e) {\n      if (modal.isAnimating) { return; }\n      var clickTarget = e.target;\n      var modalID = \"#\" + (modal.getAttribute('id'));\n      var targetAttrValue = clickTarget.getAttribute('data-target') || clickTarget.getAttribute('href');\n      var elemAttrValue = element.getAttribute('data-target') || element.getAttribute('href');\n\n      if (!modal.classList.contains('show')\n          && ((clickTarget === element && targetAttrValue === modalID)\n          || (element.contains(clickTarget) && elemAttrValue === modalID))) {\n        modal.modalTrigger = element;\n        relatedTarget = element;\n        self.show();\n        e.preventDefault();\n      }\n    }\n    function keyHandler(ref) {\n      var which = ref.which;\n\n      if (!modal.isAnimating && ops.keyboard && which === 27 && modal.classList.contains('show')) {\n        self.hide();\n      }\n    }\n    function dismissHandler(e) {\n      if (modal.isAnimating) { return; }\n      var clickTarget = e.target;\n      var hasData = clickTarget.getAttribute('data-dismiss') === 'modal';\n      var parentWithData = clickTarget.closest('[data-dismiss=\"modal\"]');\n\n      if (modal.classList.contains('show') && (parentWithData || hasData\n          || (clickTarget === modal && ops.backdrop !== 'static'))) {\n        self.hide(); relatedTarget = null;\n        e.preventDefault();\n      }\n    }\n\n    // public methods\n    self.toggle = function () {\n      if (modal.classList.contains('show')) { self.hide(); } else { self.show(); }\n    };\n    self.show = function () {\n      if (modal.classList.contains('show') && !!modal.isAnimating) { return; }\n\n      showCustomEvent = bootstrapCustomEvent('show', 'modal', { relatedTarget: relatedTarget });\n      dispatchCustomEvent.call(modal, showCustomEvent);\n\n      if (showCustomEvent.defaultPrevented) { return; }\n\n      modal.isAnimating = true;\n\n      // we elegantly hide any opened modal\n      var currentOpen = document.getElementsByClassName('modal show')[0];\n      if (currentOpen && currentOpen !== modal) {\n        if (currentOpen.modalTrigger) { currentOpen.modalTrigger.Modal.hide(); }\n        if (currentOpen.Modal) { currentOpen.Modal.hide(); }\n      }\n\n      if (ops.backdrop) { overlay = createOverlay(); }\n\n      if (overlay && !currentOpen && !overlay.classList.contains('show')) {\n        reflow(overlay);\n        overlayDelay = getElementTransitionDuration(overlay);\n        overlay.classList.add('show');\n      }\n\n      if (!currentOpen) { setTimeout(beforeShow, overlay && overlayDelay ? overlayDelay : 0); }\n      else { beforeShow(); }\n    };\n    self.hide = function (force) {\n      if (!modal.classList.contains('show')) { return; }\n\n      hideCustomEvent = bootstrapCustomEvent('hide', 'modal');\n      dispatchCustomEvent.call(modal, hideCustomEvent);\n      if (hideCustomEvent.defaultPrevented) { return; }\n\n      modal.isAnimating = true;\n\n      modal.classList.remove('show');\n      modal.setAttribute('aria-hidden', true);\n\n      if (modal.classList.contains('fade') && force !== 1) { emulateTransitionEnd(modal, triggerHide); }\n      else { triggerHide(); }\n    };\n    self.setContent = function (content) {\n      queryElement('.modal-content', modal).innerHTML = content;\n    };\n    self.update = function () {\n      if (modal.classList.contains('show')) {\n        setScrollbar();\n      }\n    };\n    self.dispose = function () {\n      self.hide(1);\n      if (element) { element.removeEventListener('click', clickHandler, false); delete element.Modal; } else { delete modal.Modal; }\n    };\n\n    // init\n\n    // the modal (both JavaScript / DATA API init) / triggering button element (DATA API)\n    element = queryElement(elem);\n\n    // determine modal, triggering element\n    var checkModal = queryElement(element.getAttribute('data-target') || element.getAttribute('href'));\n    modal = element.classList.contains('modal') ? element : checkModal;\n\n    // set fixed items\n    fixedItems = Array.from(document.getElementsByClassName('fixed-top'))\n      .concat(Array.from(document.getElementsByClassName('fixed-bottom')));\n\n    if (element.classList.contains('modal')) { element = null; } // modal is now independent of it's triggering element\n\n    // reset on re-init\n    if (element && element.Modal) { element.Modal.dispose(); }\n    if (modal && modal.Modal) { modal.Modal.dispose(); }\n\n    // set options\n    ops.keyboard = !(options.keyboard === false || modal.getAttribute('data-keyboard') === 'false');\n    ops.backdrop = options.backdrop === 'static' || modal.getAttribute('data-backdrop') === 'static' ? 'static' : true;\n    ops.backdrop = options.backdrop === false || modal.getAttribute('data-backdrop') === 'false' ? false : ops.backdrop;\n    ops.animation = !!modal.classList.contains('fade');\n    ops.content = options.content; // JavaScript only\n\n    // set an initial state of the modal\n    modal.isAnimating = false;\n\n    // prevent adding event handlers over and over\n    // modal is independent of a triggering element\n    if (element && !element.Modal) {\n      element.addEventListener('click', clickHandler, false);\n    }\n\n    if (ops.content) {\n      self.setContent(ops.content.trim());\n    }\n\n    // set associations\n    if (element) {\n      modal.modalTrigger = element;\n      element.Modal = self;\n    } else {\n      modal.Modal = self;\n    }\n  }\n\n  var mouseClickEvents = { down: 'mousedown', up: 'mouseup' };\n\n  // Popover, Tooltip & ScrollSpy\n  function getScroll() {\n    return {\n      y: window.pageYOffset || document.documentElement.scrollTop,\n      x: window.pageXOffset || document.documentElement.scrollLeft,\n    };\n  }\n\n  // both popovers and tooltips (target,tooltip,placement,elementToAppendTo)\n  function styleTip(link, element, originalPosition, parent) {\n    var tipPositions = /\\b(top|bottom|left|right)+/;\n    var elementDimensions = { w: element.offsetWidth, h: element.offsetHeight };\n    var windowWidth = (document.documentElement.clientWidth || document.body.clientWidth);\n    var windowHeight = (document.documentElement.clientHeight || document.body.clientHeight);\n    var rect = link.getBoundingClientRect();\n    var scroll = parent === document.body\n      ? getScroll()\n      : { x: parent.offsetLeft + parent.scrollLeft, y: parent.offsetTop + parent.scrollTop };\n    var linkDimensions = { w: rect.right - rect.left, h: rect.bottom - rect.top };\n    var isPopover = element.classList.contains('popover');\n    var arrow = element.getElementsByClassName('arrow')[0];\n    var halfTopExceed = rect.top + linkDimensions.h / 2 - elementDimensions.h / 2 < 0;\n    var halfLeftExceed = rect.left + linkDimensions.w / 2 - elementDimensions.w / 2 < 0;\n    var halfRightExceed = rect.left + elementDimensions.w / 2\n      + linkDimensions.w / 2 >= windowWidth;\n    var halfBottomExceed = rect.top + elementDimensions.h / 2\n      + linkDimensions.h / 2 >= windowHeight;\n    var topExceed = rect.top - elementDimensions.h < 0;\n    var leftExceed = rect.left - elementDimensions.w < 0;\n    var bottomExceed = rect.top + elementDimensions.h + linkDimensions.h >= windowHeight;\n    var rightExceed = rect.left + elementDimensions.w + linkDimensions.w >= windowWidth;\n    var position = originalPosition;\n\n    // recompute position\n    // first, when both left and right limits are exceeded, we fall back to top|bottom\n    position = (position === 'left' || position === 'right') && leftExceed && rightExceed ? 'top' : position;\n    position = position === 'top' && topExceed ? 'bottom' : position;\n    position = position === 'bottom' && bottomExceed ? 'top' : position;\n    position = position === 'left' && leftExceed ? 'right' : position;\n    position = position === 'right' && rightExceed ? 'left' : position;\n\n    var topPosition;\n    var leftPosition;\n    var arrowTop;\n    var arrowLeft;\n\n    // update tooltip/popover class\n    if (element.className.indexOf(position) === -1) {\n      element.className = element.className.replace(tipPositions, position);\n    }\n\n    // we check the computed width & height and update here\n    var arrowWidth = arrow.offsetWidth;\n    var arrowHeight = arrow.offsetHeight;\n\n    // apply styling to tooltip or popover\n    // secondary|side positions\n    if (position === 'left' || position === 'right') {\n      if (position === 'left') { // LEFT\n        leftPosition = rect.left + scroll.x - elementDimensions.w - (isPopover ? arrowWidth : 0);\n      } else { // RIGHT\n        leftPosition = rect.left + scroll.x + linkDimensions.w;\n      }\n\n      // adjust top and arrow\n      if (halfTopExceed) {\n        topPosition = rect.top + scroll.y;\n        arrowTop = linkDimensions.h / 2 - arrowWidth;\n      } else if (halfBottomExceed) {\n        topPosition = rect.top + scroll.y - elementDimensions.h + linkDimensions.h;\n        arrowTop = elementDimensions.h - linkDimensions.h / 2 - arrowWidth;\n      } else {\n        topPosition = rect.top + scroll.y - elementDimensions.h / 2 + linkDimensions.h / 2;\n        arrowTop = elementDimensions.h / 2 - (isPopover ? arrowHeight * 0.9 : arrowHeight / 2);\n      }\n    // primary|vertical positions\n    } else if (position === 'top' || position === 'bottom') {\n      if (position === 'top') { // TOP\n        topPosition = rect.top + scroll.y - elementDimensions.h - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = rect.top + scroll.y + linkDimensions.h;\n      }\n      // adjust left | right and also the arrow\n      if (halfLeftExceed) {\n        leftPosition = 0;\n        arrowLeft = rect.left + linkDimensions.w / 2 - arrowWidth;\n      } else if (halfRightExceed) {\n        leftPosition = windowWidth - elementDimensions.w * 1.01;\n        arrowLeft = elementDimensions.w - (windowWidth - rect.left)\n          + linkDimensions.w / 2 - arrowWidth / 2;\n      } else {\n        leftPosition = rect.left + scroll.x - elementDimensions.w / 2 + linkDimensions.w / 2;\n        arrowLeft = elementDimensions.w / 2 - (isPopover ? arrowWidth : arrowWidth / 2);\n      }\n    }\n\n    // apply style to tooltip/popover and its arrow\n    element.style.top = topPosition + \"px\";\n    element.style.left = leftPosition + \"px\";\n\n    if (arrowTop) { arrow.style.top = arrowTop + \"px\"; }\n    if (arrowLeft) { arrow.style.left = arrowLeft + \"px\"; }\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Popover\n  ---------------------------------------------- */\n\n  // POPOVER DEFINITION\n  // ==================\n\n  function Popover(elem, opsInput) {\n    var element;\n    // set instance options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // popover and timer\n    var popover = null;\n    var timer = 0;\n    var isIphone = /(iPhone|iPod|iPad)/.test(navigator.userAgent);\n    // title and content\n    var titleString;\n    var contentString;\n    var placementClass;\n\n    // options\n    var ops = {};\n\n    // close btn for dissmissible popover\n    var closeBtn;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    // handlers\n    function dismissibleHandler(e) {\n      if (popover !== null && e.target === queryElement('.close', popover)) {\n        self.hide();\n      }\n    }\n    // private methods\n    function getAttr(att) {\n      return options[att] || element.dataset[att] || null;\n    }\n    function getTitle() {\n      return getAttr('title');\n    }\n    function getContent() {\n      return getAttr('content');\n    }\n    function removePopover() {\n      ops.container.removeChild(popover);\n      timer = null; popover = null;\n    }\n\n    function createPopover() {\n      titleString = getTitle();\n      contentString = getContent();\n      // fixing https://github.com/thednp/bootstrap.native/issues/233\n      contentString = contentString ? contentString.trim() : null;\n\n      popover = document.createElement('div');\n\n      // popover arrow\n      var popoverArrow = document.createElement('div');\n      popoverArrow.classList.add('arrow');\n      popover.appendChild(popoverArrow);\n\n      // create the popover from data attributes\n      if (contentString !== null && ops.template === null) {\n        popover.setAttribute('role', 'tooltip');\n\n        if (titleString !== null) {\n          var popoverTitle = document.createElement('h3');\n          popoverTitle.classList.add('popover-header');\n          popoverTitle.innerHTML = ops.dismissible ? titleString + closeBtn : titleString;\n          popover.appendChild(popoverTitle);\n        }\n\n        // set popover content\n        var popoverBodyMarkup = document.createElement('div');\n        popoverBodyMarkup.classList.add('popover-body');\n        popoverBodyMarkup.innerHTML = ops.dismissible && titleString === null\n          ? contentString + closeBtn\n          : contentString;\n        popover.appendChild(popoverBodyMarkup);\n      } else { // or create the popover from template\n        var popoverTemplate = document.createElement('div');\n        popoverTemplate.innerHTML = ops.template.trim();\n        popover.className = popoverTemplate.firstChild.className;\n        popover.innerHTML = popoverTemplate.firstChild.innerHTML;\n\n        var popoverHeader = queryElement('.popover-header', popover);\n        var popoverBody = queryElement('.popover-body', popover);\n\n        // fill the template with content from data attributes\n        if (titleString && popoverHeader) { popoverHeader.innerHTML = titleString.trim(); }\n        if (contentString && popoverBody) { popoverBody.innerHTML = contentString.trim(); }\n      }\n\n      // append to the container\n      ops.container.appendChild(popover);\n      popover.style.display = 'block';\n      if (!popover.classList.contains('popover')) { popover.classList.add('popover'); }\n      if (!popover.classList.contains(ops.animation)) { popover.classList.add(ops.animation); }\n      if (!popover.classList.contains(placementClass)) { popover.classList.add(placementClass); }\n    }\n    function showPopover() {\n      if (!popover.classList.contains('show')) { popover.classList.add('show'); }\n    }\n    function updatePopover() {\n      styleTip(element, popover, ops.placement, ops.container);\n    }\n    function forceFocus() {\n      if (popover === null) { element.focus(); }\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      if (ops.trigger === 'hover') {\n        element[action](mouseClickEvents.down, self.show);\n        element[action](mouseHoverEvents[0], self.show);\n        // mouseHover = ('onmouseleave' in document)\n        //   ? [ 'mouseenter', 'mouseleave']\n        //   : [ 'mouseover', 'mouseout' ]\n        if (!ops.dismissible) { element[action](mouseHoverEvents[1], self.hide); }\n      } else if (ops.trigger === 'click') {\n        element[action](ops.trigger, self.toggle);\n      } else if (ops.trigger === 'focus') {\n        if (isIphone) { element[action]('click', forceFocus, false); }\n        element[action](ops.trigger, self.toggle);\n      }\n    }\n    function touchHandler(e) {\n      if ((popover && popover.contains(e.target))\n        || e.target === element || element.contains(e.target)) ; else {\n        self.hide();\n      }\n    }\n    // event toggle\n    function dismissHandlerToggle(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      if (ops.dismissible) {\n        document[action]('click', dismissibleHandler, false);\n      } else {\n        if (ops.trigger === 'focus') { element[action]('blur', self.hide); }\n        if (ops.trigger === 'hover') { document[action]('touchstart', touchHandler, passiveHandler); }\n      }\n      window[action]('resize', self.hide, passiveHandler);\n    }\n    // triggers\n    function showTrigger() {\n      dismissHandlerToggle(1);\n      dispatchCustomEvent.call(element, shownCustomEvent);\n    }\n    function hideTrigger() {\n      dismissHandlerToggle();\n      removePopover();\n      dispatchCustomEvent.call(element, hiddenCustomEvent);\n    }\n\n    // public methods / handlers\n    self.toggle = function () {\n      if (popover === null) { self.show(); }\n      else { self.hide(); }\n    };\n    self.show = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (popover === null) {\n          dispatchCustomEvent.call(element, showCustomEvent);\n          if (showCustomEvent.defaultPrevented) { return; }\n\n          createPopover();\n          updatePopover();\n          showPopover();\n          if (ops.animation) { emulateTransitionEnd(popover, showTrigger); }\n          else { showTrigger(); }\n        }\n      }, 20);\n    };\n    self.hide = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (popover && popover !== null && popover.classList.contains('show')) {\n          dispatchCustomEvent.call(element, hideCustomEvent);\n          if (hideCustomEvent.defaultPrevented) { return; }\n          popover.classList.remove('show');\n          if (ops.animation) { emulateTransitionEnd(popover, hideTrigger); }\n          else { hideTrigger(); }\n        }\n      }, ops.delay);\n    };\n    self.dispose = function () {\n      self.hide();\n      toggleEvents();\n      delete element.Popover;\n    };\n\n    // INIT\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Popover) { element.Popover.dispose(); }\n\n    // DATA API\n    var triggerData = element.getAttribute('data-trigger'); // click / hover / focus\n    var animationData = element.getAttribute('data-animation'); // true / false\n\n    var placementData = element.getAttribute('data-placement');\n    var dismissibleData = element.getAttribute('data-dismissible');\n    var delayData = element.getAttribute('data-delay');\n    var containerData = element.getAttribute('data-container');\n\n    // close btn for dissmissible popover\n    closeBtn = '<button type=\"button\" class=\"close\"></button>';\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'popover');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'popover');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'popover');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'popover');\n\n    // check container\n    var containerElement = queryElement(options.container);\n    var containerDataElement = queryElement(containerData);\n\n    // maybe the element is inside a modal\n    var modal = element.closest('.modal');\n\n    // maybe the element is inside a fixed navbar\n    var navbarFixedTop = element.closest('.fixed-top');\n    var navbarFixedBottom = element.closest('.fixed-bottom');\n\n    // set instance options\n    ops.template = options.template ? options.template : null; // JavaScript only\n    ops.trigger = options.trigger ? options.trigger : triggerData || 'hover';\n    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';\n    ops.placement = options.placement ? options.placement : placementData || 'top';\n    ops.delay = parseInt((options.delay || delayData), 10) || 200;\n    ops.dismissible = !!(options.dismissible || dismissibleData === 'true');\n    ops.container = containerElement\n      || (containerDataElement\n        || (navbarFixedTop || (navbarFixedBottom || (modal || document.body))));\n\n    placementClass = \"bs-popover-\" + (ops.placement);\n\n    // invalidate\n    titleString = getTitle();\n    contentString = getContent();\n\n    if (!contentString && !ops.template) { return; }\n\n    // init\n    if (!element.Popover) { // prevent adding event handlers twice\n      toggleEvents(1);\n    }\n\n    // associate target to init object\n    element.Popover = self;\n  }\n\n  /* Native JavaScript for Bootstrap 5 | ScrollSpy\n  ------------------------------------------------ */\n\n  // SCROLLSPY DEFINITION\n  // ====================\n\n  function ScrollSpy(elem, opsInput) {\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // GC internals\n    var vars;\n    var links;\n\n    // targets\n    var spyTarget;\n    // determine which is the real scrollTarget\n    var scrollTarget;\n    // options\n    var ops = {};\n\n    // private methods\n    // populate items and targets\n    function updateTargets() {\n      links = spyTarget.getElementsByTagName('A');\n\n      vars.scrollTop = vars.isWindow ? getScroll().y : element.scrollTop;\n\n      // only update vars once or with each mutation\n      if (vars.length !== links.length || getScrollHeight() !== vars.scrollHeight) {\n        var href;\n        var targetItem;\n        var rect;\n\n        // reset arrays & update\n        vars.items = [];\n        vars.offsets = [];\n        vars.scrollHeight = getScrollHeight();\n        vars.maxScroll = vars.scrollHeight - getOffsetHeight();\n\n        Array.from(links).forEach(function (link) {\n          href = link.getAttribute('href');\n          targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);\n\n          if (targetItem) {\n            vars.items.push(link);\n            rect = targetItem.getBoundingClientRect();\n            vars.offsets.push((vars.isWindow\n              ? rect.top + vars.scrollTop\n              : targetItem.offsetTop) - ops.offset);\n          }\n        });\n        vars.length = vars.items.length;\n      }\n    }\n    // item update\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      scrollTarget[action]('scroll', self.refresh, passiveHandler);\n      window[action]('resize', self.refresh, passiveHandler);\n    }\n    function getScrollHeight() {\n      return scrollTarget.scrollHeight || Math.max(\n        document.body.scrollHeight,\n        document.documentElement.scrollHeight\n      );\n    }\n    function getOffsetHeight() {\n      return !vars.isWindow ? element.getBoundingClientRect().height : window.innerHeight;\n    }\n    function clear() {\n      Array.from(links).map(function (item) { return item.classList.contains('active') && item.classList.remove('active'); });\n    }\n    function activate(input) {\n      var item = input;\n      var itemClassList;\n      clear();\n      vars.activeItem = item;\n      item.classList.add('active');\n\n      // activate all parents\n      var parents = [];\n      while (item.parentNode !== document.body) {\n        item = item.parentNode;\n        itemClassList = item.classList;\n\n        if (itemClassList.contains('dropdown-menu') || itemClassList.contains('nav')) { parents.push(item); }\n      }\n\n      parents.forEach(function (menuItem) {\n        var parentLink = menuItem.previousElementSibling;\n\n        if (parentLink && !parentLink.classList.contains('active')) {\n          parentLink.classList.add('active');\n        }\n      });\n\n      dispatchCustomEvent.call(element, bootstrapCustomEvent('activate', 'scrollspy', { relatedTarget: vars.activeItem }));\n    }\n\n    // public method\n    self.refresh = function () {\n      updateTargets();\n\n      if (vars.scrollTop >= vars.maxScroll) {\n        var newActiveItem = vars.items[vars.length - 1];\n\n        if (vars.activeItem !== newActiveItem) {\n          activate(newActiveItem);\n        }\n\n        return;\n      }\n\n      if (vars.activeItem && vars.scrollTop < vars.offsets[0] && vars.offsets[0] > 0) {\n        vars.activeItem = null;\n        clear();\n        return;\n      }\n\n      var i = vars.length;\n      while (i > -1) {\n        if (vars.activeItem !== vars.items[i] && vars.scrollTop >= vars.offsets[i]\n          && (typeof vars.offsets[i + 1] === 'undefined' || vars.scrollTop < vars.offsets[i + 1])) {\n          activate(vars.items[i]);\n        }\n        i -= 1;\n      }\n    };\n    self.dispose = function () {\n      toggleEvents();\n      delete element.ScrollSpy;\n    };\n\n    // init\n    // initialization element, the element we spy on\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.ScrollSpy) { element.ScrollSpy.dispose(); }\n\n    // event targets, constants\n    // DATA API\n    var targetData = element.getAttribute('data-target');\n    var offsetData = element.getAttribute('data-offset');\n\n    // targets\n    spyTarget = queryElement(options.target || targetData);\n\n    // determine which is the real scrollTarget\n    scrollTarget = element.clientHeight < element.scrollHeight ? element : window;\n\n    if (!spyTarget) { return; }\n\n    // set instance option\n    ops.offset = +(options.offset || offsetData) || 10;\n\n    // set instance priority variables\n    vars = {};\n    vars.length = 0;\n    vars.items = [];\n    vars.offsets = [];\n    vars.isWindow = scrollTarget === window;\n    vars.activeItem = null;\n    vars.scrollHeight = 0;\n    vars.maxScroll = 0;\n\n    // prevent adding event handlers twice\n    if (!element.ScrollSpy) { toggleEvents(1); }\n\n    self.refresh();\n\n    // associate target with init object\n    element.ScrollSpy = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Tab\n  ------------------------------------------ */\n\n  // TAB DEFINITION\n  // ==============\n\n  function Tab(elem, opsInput) {\n    var element;\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // event targets\n    var tabs;\n    var dropdown;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    // more GC material\n    var next;\n    var tabsContentContainer = false;\n    var activeTab;\n    var activeContent;\n    var nextContent;\n    var containerHeight;\n    var equalContents;\n    var nextHeight;\n\n    // triggers\n    function triggerEnd() {\n      tabsContentContainer.style.height = '';\n      tabsContentContainer.classList.remove('collapsing');\n      tabs.isAnimating = false;\n    }\n    function triggerShow() {\n      if (tabsContentContainer) { // height animation\n        if (equalContents) {\n          triggerEnd();\n        } else {\n          setTimeout(function () { // enables height animation\n            tabsContentContainer.style.height = nextHeight + \"px\"; // height animation\n            reflow(tabsContentContainer);\n            emulateTransitionEnd(tabsContentContainer, triggerEnd);\n          }, 50);\n        }\n      } else {\n        tabs.isAnimating = false;\n      }\n      shownCustomEvent = bootstrapCustomEvent('shown', 'tab', { relatedTarget: activeTab });\n      dispatchCustomEvent.call(next, shownCustomEvent);\n    }\n    function triggerHide() {\n      if (tabsContentContainer) {\n        activeContent.style.float = 'left';\n        nextContent.style.float = 'left';\n        containerHeight = activeContent.scrollHeight;\n      }\n\n      showCustomEvent = bootstrapCustomEvent('show', 'tab', { relatedTarget: activeTab });\n      hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tab', { relatedTarget: next });\n\n      dispatchCustomEvent.call(next, showCustomEvent);\n      if (showCustomEvent.defaultPrevented) { return; }\n\n      nextContent.classList.add('active');\n\n      activeContent.classList.remove('active');\n\n      if (tabsContentContainer) {\n        nextHeight = nextContent.scrollHeight;\n        equalContents = nextHeight === containerHeight;\n        tabsContentContainer.classList.add('collapsing');\n        tabsContentContainer.style.height = containerHeight + \"px\"; // height animation\n        reflow(tabsContentContainer);\n        activeContent.style.float = '';\n        nextContent.style.float = '';\n      }\n\n      if (nextContent.classList.contains('fade')) {\n        setTimeout(function () {\n          nextContent.classList.add('show');\n          emulateTransitionEnd(nextContent, triggerShow);\n        }, 20);\n      } else { triggerShow(); }\n\n      dispatchCustomEvent.call(activeTab, hiddenCustomEvent);\n    }\n    // private methods\n    function getActiveTab() {\n      var assign;\n\n      var activeTabs = tabs.getElementsByClassName('active');\n\n      if (activeTabs.length === 1 && !activeTabs[0].parentNode.classList.contains('dropdown')) {\n        (assign = activeTabs, activeTab = assign[0]);\n      } else if (activeTabs.length > 1) {\n        activeTab = activeTabs[activeTabs.length - 1];\n      }\n      return activeTab;\n    }\n    function getActiveContent() { return queryElement(getActiveTab().getAttribute('href')); }\n    // handler\n    function clickHandler(e) {\n      e.preventDefault();\n      next = e.currentTarget;\n      if (!tabs.isAnimating) { self.show(); }\n    }\n\n    // public method\n    self.show = function () { // the tab we clicked is now the next tab\n      next = next || element;\n\n      if (!next.classList.contains('active')) {\n        nextContent = queryElement(next.getAttribute('href')); // this is the actual object, the next tab content to activate\n        activeTab = getActiveTab();\n        activeContent = getActiveContent();\n\n        hideCustomEvent = bootstrapCustomEvent('hide', 'tab', { relatedTarget: next });\n        dispatchCustomEvent.call(activeTab, hideCustomEvent);\n        if (hideCustomEvent.defaultPrevented) { return; }\n\n        tabs.isAnimating = true;\n        activeTab.classList.remove('active');\n        activeTab.setAttribute('aria-selected', 'false');\n        next.classList.add('active');\n        next.setAttribute('aria-selected', 'true');\n\n        if (dropdown) {\n          if (!element.parentNode.classList.contains('dropdown-menu')) {\n            if (dropdown.classList.contains('active')) { dropdown.classList.remove('active'); }\n          } else if (!dropdown.classList.contains('active')) { dropdown.classList.add('active'); }\n        }\n\n        if (activeContent.classList.contains('fade')) {\n          activeContent.classList.remove('show');\n          emulateTransitionEnd(activeContent, triggerHide);\n        } else { triggerHide(); }\n      }\n    };\n    self.dispose = function () {\n      element.removeEventListener('click', clickHandler, false);\n      delete element.Tab;\n    };\n\n    // INIT\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Tab) { element.Tab.dispose(); }\n\n    // DATA API\n    var heightData = element.getAttribute('data-height');\n    // event targets\n    tabs = element.closest('.nav');\n    dropdown = tabs && queryElement('.dropdown-toggle', tabs);\n\n    // instance options\n    var animateHeight = !(!supportTransition || (options.height === false || heightData === 'false'));\n\n    // set default animation state\n    tabs.isAnimating = false;\n\n    // init\n    if (!element.Tab) { // prevent adding event handlers twice\n      element.addEventListener('click', clickHandler, false);\n    }\n\n    if (animateHeight) { tabsContentContainer = getActiveContent().parentNode; }\n\n    // associate target with init object\n    element.Tab = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Toast\n  -------------------------------------------- */\n\n  // TOAST DEFINITION\n  // ==================\n\n  function Toast(elem, opsInput) {\n    var element;\n\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // toast, timer\n    var toast;\n    var timer = 0;\n\n    // custom events\n    var showCustomEvent;\n    var hideCustomEvent;\n    var shownCustomEvent;\n    var hiddenCustomEvent;\n    var ops = {};\n\n    // private methods\n    function showComplete() {\n      toast.classList.remove('showing');\n      toast.classList.add('show');\n      dispatchCustomEvent.call(toast, shownCustomEvent);\n      if (ops.autohide) { self.hide(); }\n    }\n    function hideComplete() {\n      toast.classList.add('hide');\n      dispatchCustomEvent.call(toast, hiddenCustomEvent);\n    }\n    function close() {\n      toast.classList.remove('show');\n      if (ops.animation) { emulateTransitionEnd(toast, hideComplete); }\n      else { hideComplete(); }\n    }\n    function disposeComplete() {\n      clearTimeout(timer);\n      element.removeEventListener('click', self.hide, false);\n\n      delete element.Toast;\n    }\n\n    // public methods\n    self.show = function () {\n      if (toast && !toast.classList.contains('show')) {\n        dispatchCustomEvent.call(toast, showCustomEvent);\n        if (showCustomEvent.defaultPrevented) { return; }\n        if (ops.animation) { toast.classList.add('fade'); }\n        toast.classList.remove('hide');\n        reflow(toast); // force reflow\n        toast.classList.add('showing');\n\n        if (ops.animation) { emulateTransitionEnd(toast, showComplete); }\n        else { showComplete(); }\n      }\n    };\n    self.hide = function (noTimer) {\n      if (toast && toast.classList.contains('show')) {\n        dispatchCustomEvent.call(toast, hideCustomEvent);\n        if (hideCustomEvent.defaultPrevented) { return; }\n\n        if (noTimer) { close(); }\n        else { timer = setTimeout(close, ops.delay); }\n      }\n    };\n    self.dispose = function () {\n      if (ops.animation) { emulateTransitionEnd(toast, disposeComplete); }\n      else { disposeComplete(); }\n    };\n\n    // init\n\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Toast) { element.Toast.dispose(); }\n\n    // toast, timer\n    toast = element.closest('.toast');\n\n    // DATA API\n    var animationData = element.getAttribute('data-animation');\n    var autohideData = element.getAttribute('data-autohide');\n    var delayData = element.getAttribute('data-delay');\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'toast');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'toast');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'toast');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'toast');\n\n    // set instance options\n    ops.animation = options.animation === false || animationData === 'false' ? 0 : 1; // true by default\n    ops.autohide = options.autohide === false || autohideData === 'false' ? 0 : 1; // true by default\n    ops.delay = parseInt((options.delay || delayData), 10) || 500; // 500ms default\n\n    if (!element.Toast) { // prevent adding event handlers twice\n      element.addEventListener('click', self.hide, false);\n    }\n\n    // associate targets to init object\n    element.Toast = self;\n  }\n\n  /* Native JavaScript for Bootstrap 4 | Tooltip\n  ---------------------------------------------- */\n\n  // TOOLTIP DEFINITION\n  // ==================\n\n  function Tooltip(elem, opsInput) {\n    var element;\n    // set options\n    var options = opsInput || {};\n\n    // bind\n    var self = this;\n\n    // tooltip, timer, and title\n    var tooltip = null;\n    var timer = 0;\n    var titleString;\n    var placementClass;\n\n    // custom events\n    var showCustomEvent;\n    var shownCustomEvent;\n    var hideCustomEvent;\n    var hiddenCustomEvent;\n\n    var ops = {};\n\n    // private methods\n    function getTitle() {\n      return element.getAttribute('title')\n          || element.getAttribute('data-title')\n          || element.getAttribute('data-original-title');\n    }\n    function removeToolTip() {\n      ops.container.removeChild(tooltip);\n      tooltip = null; timer = null;\n    }\n    function createToolTip() {\n      titleString = getTitle(); // read the title again\n      if (titleString) { // invalidate, maybe markup changed\n        // create tooltip\n        tooltip = document.createElement('div');\n\n        // set markup\n        if (ops.template) {\n          var tooltipMarkup = document.createElement('div');\n          tooltipMarkup.innerHTML = ops.template.trim();\n\n          tooltip.className = tooltipMarkup.firstChild.className;\n          tooltip.innerHTML = tooltipMarkup.firstChild.innerHTML;\n\n          queryElement('.tooltip-inner', tooltip).innerHTML = titleString.trim();\n        } else {\n          // tooltip arrow\n          var tooltipArrow = document.createElement('div');\n          tooltipArrow.classList.add('arrow');\n          tooltip.appendChild(tooltipArrow);\n          // tooltip inner\n          var tooltipInner = document.createElement('div');\n          tooltipInner.classList.add('tooltip-inner');\n          tooltip.appendChild(tooltipInner);\n          tooltipInner.innerHTML = titleString;\n        }\n        // reset position\n        tooltip.style.left = '0';\n        tooltip.style.top = '0';\n        // set class and role attribute\n        tooltip.setAttribute('role', 'tooltip');\n        if (!tooltip.classList.contains('tooltip')) { tooltip.classList.add('tooltip'); }\n        if (!tooltip.classList.contains(ops.animation)) { tooltip.classList.add(ops.animation); }\n        if (!tooltip.classList.contains(placementClass)) { tooltip.classList.add(placementClass); }\n        // append to container\n        ops.container.appendChild(tooltip);\n      }\n    }\n    function updateTooltip() {\n      styleTip(element, tooltip, ops.placement, ops.container);\n    }\n    function showTooltip() {\n      if (!tooltip.classList.contains('show')) { tooltip.classList.add('show'); }\n    }\n    function touchHandler(e) {\n      if ((tooltip && tooltip.contains(e.target))\n        || e.target === element || element.contains(e.target)) ; else {\n        self.hide();\n      }\n    }\n    // triggers\n    function toggleAction(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      document[action]('touchstart', touchHandler, passiveHandler);\n      window[action]('resize', self.hide, passiveHandler);\n    }\n    function showAction() {\n      toggleAction(1);\n      dispatchCustomEvent.call(element, shownCustomEvent);\n    }\n    function hideAction() {\n      toggleAction();\n      removeToolTip();\n      dispatchCustomEvent.call(element, hiddenCustomEvent);\n    }\n    function toggleEvents(add) {\n      var action = add ? 'addEventListener' : 'removeEventListener';\n      element[action](mouseClickEvents.down, self.show, false);\n      element[action](mouseHoverEvents[0], self.show, false);\n      element[action](mouseHoverEvents[1], self.hide, false);\n    }\n\n    // public methods\n    self.show = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (tooltip === null) {\n          dispatchCustomEvent.call(element, showCustomEvent);\n          if (showCustomEvent.defaultPrevented) { return; }\n          // if(createToolTip() == false) return;\n          if (createToolTip() !== false) {\n            updateTooltip();\n            showTooltip();\n            if (ops.animation) { emulateTransitionEnd(tooltip, showAction); }\n            else { showAction(); }\n          }\n        }\n      }, 20);\n    };\n    self.hide = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (tooltip && tooltip.classList.contains('show')) {\n          dispatchCustomEvent.call(element, hideCustomEvent);\n          if (hideCustomEvent.defaultPrevented) { return; }\n          tooltip.classList.remove('show');\n          if (ops.animation) { emulateTransitionEnd(tooltip, hideAction); }\n          else { hideAction(); }\n        }\n      }, ops.delay);\n    };\n    self.toggle = function () {\n      if (!tooltip) { self.show(); }\n      else { self.hide(); }\n    };\n    self.dispose = function () {\n      toggleEvents();\n      self.hide();\n      element.setAttribute('title', element.getAttribute('data-original-title'));\n      element.removeAttribute('data-original-title');\n      delete element.Tooltip;\n    };\n\n    // init\n    // initialization element\n    element = queryElement(elem);\n\n    // reset on re-init\n    if (element.Tooltip) { element.Tooltip.dispose(); }\n\n    // DATA API\n    var animationData = element.getAttribute('data-animation');\n    var placementData = element.getAttribute('data-placement');\n    var delayData = element.getAttribute('data-delay');\n    var containerData = element.getAttribute('data-container');\n\n    // check container\n    var containerElement = queryElement(options.container);\n    var containerDataElement = queryElement(containerData);\n\n    // maybe the element is inside a modal\n    var modal = element.closest('.modal');\n\n    // custom events\n    showCustomEvent = bootstrapCustomEvent('show', 'tooltip');\n    shownCustomEvent = bootstrapCustomEvent('shown', 'tooltip');\n    hideCustomEvent = bootstrapCustomEvent('hide', 'tooltip');\n    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tooltip');\n\n    // maybe the element is inside a fixed navbar\n    var navbarFixedTop = element.closest('.fixed-top');\n    var navbarFixedBottom = element.closest('.fixed-bottom');\n\n    // set instance options\n    ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';\n    ops.placement = options.placement ? options.placement : placementData || 'top';\n    ops.template = options.template ? options.template : null; // JavaScript only\n    ops.delay = parseInt((options.delay || delayData), 10) || 200;\n    ops.container = containerElement\n      || (containerDataElement\n        || (navbarFixedTop || (navbarFixedBottom || (modal || document.body))));\n\n    // set placement class\n    placementClass = \"bs-tooltip-\" + (ops.placement);\n\n    // set tooltip content\n    titleString = getTitle();\n\n    // invalidate\n    if (!titleString) { return; }\n\n    // prevent adding event handlers twice\n    if (!element.Tooltip) {\n      element.setAttribute('data-original-title', titleString);\n      element.removeAttribute('title');\n      toggleEvents(1);\n    }\n\n    // associate target to init object\n    element.Tooltip = self;\n  }\n\n  var componentsInit = {};\n\n  /* Native JavaScript for Bootstrap | Initialize Data API\n  -------------------------------------------------------- */\n  function initializeDataAPI(Constructor, collection) {\n    Array.from(collection).map(function (x) { return new Constructor(x); });\n  }\n  function initCallback(context) {\n    var lookUp = context instanceof Element ? context : document;\n    Object.keys(componentsInit).forEach(function (component) {\n      initializeDataAPI(componentsInit[component][0],\n        lookUp.querySelectorAll(componentsInit[component][1]));\n    });\n  }\n\n  componentsInit.Alert = [Alert, '[data-dismiss=\"alert\"]'];\n  componentsInit.Button = [Button, '[data-toggle=\"buttons\"]'];\n  componentsInit.Carousel = [Carousel, '[data-ride=\"carousel\"]'];\n  componentsInit.Collapse = [Collapse, '[data-toggle=\"collapse\"]'];\n  componentsInit.Dropdown = [Dropdown, '[data-toggle=\"dropdown\"]'];\n  componentsInit.Modal = [Modal, '[data-toggle=\"modal\"]'];\n  componentsInit.Popover = [Popover, '[data-toggle=\"popover\"],[data-tip=\"popover\"]'];\n  componentsInit.ScrollSpy = [ScrollSpy, '[data-spy=\"scroll\"]'];\n  componentsInit.Tab = [Tab, '[data-toggle=\"tab\"]'];\n  componentsInit.Toast = [Toast, '[data-dismiss=\"toast\"]'];\n  componentsInit.Tooltip = [Tooltip, '[data-toggle=\"tooltip\"],[data-tip=\"tooltip\"]'];\n\n  // bulk initialize all components\n  if (document.body) { initCallback(); }\n  else {\n    document.addEventListener('DOMContentLoaded', function initWrapper() {\n      initCallback();\n      document.removeEventListener('DOMContentLoaded', initWrapper, false);\n    }, false);\n  }\n\n  /* Native JavaScript for Bootstrap | Remove Data API\n  ---------------------------------------------------- */\n  function removeElementDataAPI(ConstructorName, collection) {\n    Array.from(collection).map(function (x) { return x[ConstructorName].dispose(); });\n  }\n  function removeDataAPI(context) {\n    var lookUp = context instanceof Element ? context : document;\n    Object.keys(componentsInit).forEach(function (component) {\n      removeElementDataAPI(component, lookUp.querySelectorAll(componentsInit[component][1]));\n    });\n  }\n\n  var version = \"4.0.6\";\n\n  var indexV4 = {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip,\n\n    initCallback: initCallback,\n    removeDataAPI: removeDataAPI,\n    componentsInit: componentsInit,\n    Version: version,\n  };\n\n  return indexV4;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQuanM/MzE4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDa0c7QUFDcEcsQ0FBQyxxQkFBcUI7O0FBRXRCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZELE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGLG1CQUFtQjs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxtREFBbUQ7QUFDaEcsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixjQUFjO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IseUJBQXlCOztBQUVqRDtBQUNB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQ0FBcUMsRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIHY0LjAuNiAoaHR0cHM6Ly90aGVkbnAuZ2l0aHViLmlvL2Jvb3RzdHJhcC5uYXRpdmUvKVxuICAqIENvcHlyaWdodCAyMDE1LTIwMjEgwqkgZG5wX3RoZW1lXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdGhlZG5wL2Jvb3RzdHJhcC5uYXRpdmUvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkJTTiA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG5cbiAgdmFyIHN1cHBvcnRUcmFuc2l0aW9uID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgfHwgJ3RyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGU7XG5cbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25EdXJhdGlvbicgOiAndHJhbnNpdGlvbkR1cmF0aW9uJztcblxuICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvblByb3BlcnR5JyA6ICd0cmFuc2l0aW9uUHJvcGVydHknO1xuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oZWxlbWVudCkge1xuICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IGNvbXB1dGVkU3R5bGVbdHJhbnNpdGlvblByb3BlcnR5XTtcbiAgICB2YXIgZHVyYXRpb25WYWx1ZSA9IGNvbXB1dGVkU3R5bGVbdHJhbnNpdGlvbkR1cmF0aW9uXTtcbiAgICB2YXIgZHVyYXRpb25TY2FsZSA9IGR1cmF0aW9uVmFsdWUuaW5jbHVkZXMoJ21zJykgPyAxIDogMTAwMDtcbiAgICB2YXIgZHVyYXRpb24gPSBzdXBwb3J0VHJhbnNpdGlvbiAmJiBwcm9wZXJ0eVZhbHVlICYmIHByb3BlcnR5VmFsdWUgIT09ICdub25lJ1xuICAgICAgPyBwYXJzZUZsb2F0KGR1cmF0aW9uVmFsdWUpICogZHVyYXRpb25TY2FsZSA6IDA7XG5cbiAgICByZXR1cm4gIU51bWJlci5pc05hTihkdXJhdGlvbikgPyBkdXJhdGlvbiA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBlbXVsYXRlVHJhbnNpdGlvbkVuZChlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIGVuZEV2ZW50ID0gbmV3IEV2ZW50KHRyYW5zaXRpb25FbmRFdmVudCk7XG4gICAgdmFyIGR1cmF0aW9uID0gZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihlbGVtZW50KTtcblxuICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZFdyYXBwZXIoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KGVsZW1lbnQsIFtlXSk7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgdHJhbnNpdGlvbkVuZFdyYXBwZXIpO1xuICAgICAgICAgIGNhbGxlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7IGVsZW1lbnQuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7IH1cbiAgICAgIH0sIGR1cmF0aW9uICsgMTcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyLmFwcGx5KGVsZW1lbnQsIFtlbmRFdmVudF0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHF1ZXJ5RWxlbWVudChzZWxlY3RvciwgcGFyZW50KSB7XG4gICAgdmFyIGxvb2tVcCA9IHBhcmVudCAmJiBwYXJlbnQgaW5zdGFuY2VvZiBFbGVtZW50ID8gcGFyZW50IDogZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCA/IHNlbGVjdG9yIDogbG9va1VwLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoZXZlbnRUeXBlLCBjb21wb25lbnROYW1lLCBldmVudFByb3BlcnRpZXMpIHtcbiAgICB2YXIgT3JpZ2luYWxDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudCgoZXZlbnRUeXBlICsgXCIuYnMuXCIgKyBjb21wb25lbnROYW1lKSwgeyBjYW5jZWxhYmxlOiB0cnVlIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBldmVudFByb3BlcnRpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBPYmplY3Qua2V5cyhldmVudFByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3JpZ2luYWxDdXN0b21FdmVudCwga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50UHJvcGVydGllc1trZXldLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gT3JpZ2luYWxDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnQpIHtcbiAgICBpZiAodGhpcykgeyB0aGlzLmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpOyB9XG4gIH1cblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBBbGVydFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8vIEFMRVJUIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIEFsZXJ0KGVsZW0pIHtcbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyB0aGUgdGFyZ2V0IGFsZXJ0XG4gICAgdmFyIGFsZXJ0O1xuXG4gICAgLy8gY3VzdG9tIGV2ZW50c1xuICAgIHZhciBjbG9zZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2Nsb3NlJywgJ2FsZXJ0Jyk7XG4gICAgdmFyIGNsb3NlZEN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2Nsb3NlZCcsICdhbGVydCcpO1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgZnVuY3Rpb24gdHJpZ2dlckhhbmRsZXIoKSB7XG4gICAgICBpZiAoYWxlcnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykpIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQoYWxlcnQsIHRyYW5zaXRpb25FbmRIYW5kbGVyKTsgfVxuICAgICAgZWxzZSB7IHRyYW5zaXRpb25FbmRIYW5kbGVyKCk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFkZCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGFkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgnY2xpY2snLCBjbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICBhbGVydCA9IGUgJiYgZS50YXJnZXQuY2xvc2VzdCgnLmFsZXJ0Jyk7XG4gICAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KCdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nLCBhbGVydCk7XG4gICAgICBpZiAoZWxlbWVudCAmJiBhbGVydCAmJiAoZWxlbWVudCA9PT0gZS50YXJnZXQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpKSB7IHNlbGYuY2xvc2UoKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcigpIHtcbiAgICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgICAgYWxlcnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhbGVydCk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlZEN1c3RvbUV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBQVUJMSUMgTUVUSE9EU1xuICAgIHNlbGYuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYWxlcnQgJiYgZWxlbWVudCAmJiBhbGVydC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlQ3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoY2xvc2VDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgICBzZWxmLmRpc3Bvc2UoKTtcbiAgICAgICAgYWxlcnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICB0cmlnZ2VySGFuZGxlcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LkFsZXJ0O1xuICAgIH07XG5cbiAgICAvLyBJTklUXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbSk7XG5cbiAgICAvLyBmaW5kIHRoZSB0YXJnZXQgYWxlcnRcbiAgICBhbGVydCA9IGVsZW1lbnQuY2xvc2VzdCgnLmFsZXJ0Jyk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuQWxlcnQpIHsgZWxlbWVudC5BbGVydC5kaXNwb3NlKCk7IH1cblxuICAgIC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgaWYgKCFlbGVtZW50LkFsZXJ0KSB7IHRvZ2dsZUV2ZW50cygxKTsgfVxuXG4gICAgLy8gc3RvcmUgaW5pdCBvYmplY3Qgd2l0aGluIHRhcmdldCBlbGVtZW50XG4gICAgc2VsZi5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBlbGVtZW50LkFsZXJ0ID0gc2VsZjtcbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEJ1dHRvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEJVVFRPTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gQnV0dG9uKGVsZW0pIHtcbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIGJpbmQgYW5kIGxhYmVsc1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGFiZWxzO1xuXG4gICAgLy8gY2hhbmdlRXZlbnRcbiAgICB2YXIgY2hhbmdlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnY2hhbmdlJywgJ2J1dHRvbicpO1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICAgIHZhciBlVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICB2YXIgcGFyZW50TGFiZWwgPSBlVGFyZ2V0LmNsb3Nlc3QoJ0xBQkVMJyk7IC8vIHRoZSAuYnRuIGxhYmVsXG4gICAgICB2YXIgbGFiZWwgPSBudWxsO1xuXG4gICAgICBpZiAoZVRhcmdldC50YWdOYW1lID09PSAnTEFCRUwnKSB7XG4gICAgICAgIGxhYmVsID0gZVRhcmdldDtcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50TGFiZWwpIHtcbiAgICAgICAgbGFiZWwgPSBwYXJlbnRMYWJlbDtcbiAgICAgIH1cblxuICAgICAgLy8gY3VycmVudCBpbnB1dFxuICAgICAgdmFyIGlucHV0ID0gbGFiZWwgJiYgbGFiZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF07XG5cbiAgICAgIC8vIGludmFsaWRhdGUgaWYgbm8gaW5wdXRcbiAgICAgIGlmICghaW5wdXQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChpbnB1dCwgY2hhbmdlQ3VzdG9tRXZlbnQpOyAvLyB0cmlnZ2VyIHRoZSBjaGFuZ2UgZm9yIHRoZSBpbnB1dFxuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGNoYW5nZUN1c3RvbUV2ZW50KTsgLy8gdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgYnRuLWdyb3VwXG5cbiAgICAgIC8vIG1hbmFnZSB0aGUgZG9tIG1hbmlwdWxhdGlvblxuICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHsgLy8gY2hlY2tib3hlc1xuICAgICAgICBpZiAoY2hhbmdlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH0gLy8gZGlzY29udGludWUgd2hlbiBkZWZhdWx0UHJldmVudGVkIGlzIHRydWVcblxuICAgICAgICBpZiAoIWlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgIGlucHV0LmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZWxlbWVudC50b2dnbGVkKSB7IC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgZXZlbnQgdHdpY2VcbiAgICAgICAgICBlbGVtZW50LnRvZ2dsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nICYmICFlbGVtZW50LnRvZ2dsZWQpIHsgLy8gcmFkaW8gYnV0dG9uc1xuICAgICAgICBpZiAoY2hhbmdlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiBhbHJlYWR5IGFjdGl2ZVxuICAgICAgICAvLyAodGhlIE9SIGNvbmRpdGlvbiBpcyBhIGhhY2sgdG8gY2hlY2sgaWYgdGhlIGJ1dHRvbnMgd2VyZSBzZWxlY3RlZFxuICAgICAgICAvLyB3aXRoIGtleSBwcmVzcyBhbmQgTk9UIG1vdXNlIGNsaWNrKVxuICAgICAgICBpZiAoIWlucHV0LmNoZWNrZWQgfHwgKGUuc2NyZWVuWCA9PT0gMCAmJiBlLnNjcmVlblkgPT09IDApKSB7XG4gICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnZm9jdXMnKTtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZWxlbWVudC50b2dnbGVkID0gdHJ1ZTtcbiAgICAgICAgICBBcnJheS5mcm9tKGxhYmVscykuZm9yRWFjaChmdW5jdGlvbiAob3RoZXJMYWJlbCkge1xuICAgICAgICAgICAgdmFyIG90aGVySW5wdXQgPSBvdGhlckxhYmVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdO1xuICAgICAgICAgICAgaWYgKG90aGVyTGFiZWwgIT09IGxhYmVsICYmIG90aGVyTGFiZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwob3RoZXJJbnB1dCwgY2hhbmdlQ3VzdG9tRXZlbnQpOyAvLyB0cmlnZ2VyIHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgb3RoZXJMYWJlbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgb3RoZXJJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgb3RoZXJJbnB1dC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBlbGVtZW50LnRvZ2dsZWQgPSBmYWxzZTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZXJzXG4gICAgZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICBpZiAoa2V5ID09PSAzMiAmJiBlLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgeyB0b2dnbGUoZSk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJldmVudFNjcm9sbChlKSB7XG4gICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICBpZiAoa2V5ID09PSAzMikgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZm9jdXNUb2dnbGUoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IGUudHlwZSA9PT0gJ2ZvY3VzaW4nID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgICAgICAgZS50YXJnZXQuY2xvc2VzdCgnLmJ0bicpLmNsYXNzTGlzdFthY3Rpb25dKCdmb2N1cycpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCdjbGljaycsIHRvZ2dsZSwgZmFsc2UpO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCdrZXl1cCcsIGtleUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgna2V5ZG93bicsIHByZXZlbnRTY3JvbGwsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgnZm9jdXNpbicsIGZvY3VzVG9nZ2xlLCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oJ2ZvY3Vzb3V0JywgZm9jdXNUb2dnbGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgICBkZWxldGUgZWxlbWVudC5CdXR0b247XG4gICAgfTtcblxuICAgIC8vIGluaXRcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5CdXR0b24pIHsgZWxlbWVudC5CdXR0b24uZGlzcG9zZSgpOyB9XG5cbiAgICBsYWJlbHMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2J0bicpO1xuXG4gICAgLy8gaW52YWxpZGF0ZVxuICAgIGlmICghbGFiZWxzLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICAgIC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgaWYgKCFlbGVtZW50LkJ1dHRvbikgeyB0b2dnbGVFdmVudHMoMSk7IH1cblxuICAgIC8vIHNldCBpbml0aWFsIHRvZ2dsZWQgc3RhdGVcbiAgICAvLyB0b2dnbGVkIG1ha2VzIHN1cmUgdG8gcHJldmVudCB0cmlnZ2VyaW5nIHR3aWNlIHRoZSBjaGFuZ2UuYnMuYnV0dG9uIGV2ZW50c1xuICAgIGVsZW1lbnQudG9nZ2xlZCA9IGZhbHNlO1xuXG4gICAgLy8gYXNzb2NpYXRlIHRhcmdldCB3aXRoIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5CdXR0b24gPSBzZWxmO1xuXG4gICAgLy8gYWN0aXZhdGUgaXRlbXMgb24gbG9hZFxuICAgIEFycmF5LmZyb20obGFiZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChidG4pIHtcbiAgICAgIHZhciBoYXNDaGVja2VkID0gcXVlcnlFbGVtZW50KCdpbnB1dDpjaGVja2VkJywgYnRuKTtcbiAgICAgIGlmICghYnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgaGFzQ2hlY2tlZCkge1xuICAgICAgICBidG4uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgIWhhc0NoZWNrZWQpIHtcbiAgICAgICAgYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1vdXNlSG92ZXJFdmVudHMgPSAoJ29ubW91c2VsZWF2ZScgaW4gZG9jdW1lbnQpID8gWydtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnXSA6IFsnbW91c2VvdmVyJywgJ21vdXNlb3V0J107XG5cbiAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSAnYWRkRXZlbnRMaXN0ZW5lcic7XG5cbiAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG5cbiAgdmFyIHN1cHBvcnRQYXNzaXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBkb2N1bWVudFthZGRFdmVudExpc3RlbmVyXSgnRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgICAgIGRvY3VtZW50W3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdET01Db250ZW50TG9hZGVkJywgd3JhcCwgb3B0cyk7XG4gICAgICB9LCBvcHRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBFcnJvcignUGFzc2l2ZSBldmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xuXG4gIC8vIGdlbmVyYWwgZXZlbnQgb3B0aW9uc1xuXG4gIHZhciBwYXNzaXZlSGFuZGxlciA9IHN1cHBvcnRQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZTtcblxuICBmdW5jdGlvbiBpc0VsZW1lbnRJblNjcm9sbFJhbmdlKGVsZW1lbnQpIHtcbiAgICB2YXIgYmNyID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICByZXR1cm4gYmNyLnRvcCA8PSB2aWV3cG9ydEhlaWdodCAmJiBiY3IuYm90dG9tID49IDA7IC8vIGJvdHRvbSAmJiB0b3BcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgQ2Fyb3VzZWxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBDQVJPVVNFTCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtLCBvcHNJbnB1dCkge1xuICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxLCBhc3NpZ24kMjtcblxuICAgIHZhciBlbGVtZW50O1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGludGVybmFsIHZhcmlhYmxlc1xuICAgIHZhciB2YXJzO1xuICAgIHZhciBvcHM7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNsaWRlQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIHNsaWRDdXN0b21FdmVudDtcblxuICAgIC8vIGNhcm91c2VsIGVsZW1lbnRzXG4gICAgdmFyIHNsaWRlcztcbiAgICB2YXIgbGVmdEFycm93O1xuICAgIHZhciByaWdodEFycm93O1xuICAgIHZhciBpbmRpY2F0b3I7XG4gICAgdmFyIGluZGljYXRvcnM7XG5cbiAgICAvLyBoYW5kbGVyc1xuICAgIGZ1bmN0aW9uIHBhdXNlSGFuZGxlcigpIHtcbiAgICAgIGlmIChvcHMuaW50ZXJ2YWwgIT09IGZhbHNlICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGF1c2VkJykpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdwYXVzZWQnKTtcbiAgICAgICAgaWYgKCF2YXJzLmlzU2xpZGluZykge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG4gICAgICAgICAgdmFycy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdW1lSGFuZGxlcigpIHtcbiAgICAgIGlmIChvcHMuaW50ZXJ2YWwgIT09IGZhbHNlICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3BhdXNlZCcpO1xuICAgICAgICBpZiAoIXZhcnMuaXNTbGlkaW5nKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgICAgICB2YXJzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgICBzZWxmLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kaWNhdG9ySGFuZGxlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBldmVudFRhcmdldCA9IGUudGFyZ2V0OyAvLyBldmVudCB0YXJnZXQgfCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuXG4gICAgICBpZiAoZXZlbnRUYXJnZXQgJiYgIWV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJykpIHtcbiAgICAgICAgdmFycy5pbmRleCA9ICsoZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJykpO1xuICAgICAgfSBlbHNlIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuc2xpZGVUbyh2YXJzLmluZGV4KTsgLy8gRG8gdGhlIHNsaWRlXG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRyb2xzSGFuZGxlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBldmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgICAgIGlmIChldmVudFRhcmdldCA9PT0gcmlnaHRBcnJvdykge1xuICAgICAgICB2YXJzLmluZGV4ICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VGFyZ2V0ID09PSBsZWZ0QXJyb3cpIHtcbiAgICAgICAgdmFycy5pbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnNsaWRlVG8odmFycy5pbmRleCk7IC8vIERvIHRoZSBzbGlkZVxuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlIYW5kbGVyKHJlZikge1xuICAgICAgdmFyIHdoaWNoID0gcmVmLndoaWNoO1xuXG4gICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgICBzd2l0Y2ggKHdoaWNoKSB7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgdmFycy5pbmRleCArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIHZhcnMuaW5kZXggLT0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZi5zbGlkZVRvKHZhcnMuaW5kZXgpOyAvLyBEbyB0aGUgc2xpZGVcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFkZCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGFkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICAgIGlmIChvcHMucGF1c2UgJiYgb3BzLmludGVydmFsKSB7XG4gICAgICAgIGVsZW1lbnRbYWN0aW9uXShtb3VzZUhvdmVyRXZlbnRzWzBdLCBwYXVzZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlSG92ZXJFdmVudHNbMV0sIHJlc3VtZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKCd0b3VjaHN0YXJ0JywgcGF1c2VIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICAgIGVsZW1lbnRbYWN0aW9uXSgndG91Y2hlbmQnLCByZXN1bWVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHMudG91Y2ggJiYgc2xpZGVzLmxlbmd0aCA+IDEpIHsgZWxlbWVudFthY3Rpb25dKCd0b3VjaHN0YXJ0JywgdG91Y2hEb3duSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpOyB9XG5cbiAgICAgIGlmIChyaWdodEFycm93KSB7IHJpZ2h0QXJyb3dbYWN0aW9uXSgnY2xpY2snLCBjb250cm9sc0hhbmRsZXIsIGZhbHNlKTsgfVxuICAgICAgaWYgKGxlZnRBcnJvdykgeyBsZWZ0QXJyb3dbYWN0aW9uXSgnY2xpY2snLCBjb250cm9sc0hhbmRsZXIsIGZhbHNlKTsgfVxuXG4gICAgICBpZiAoaW5kaWNhdG9yKSB7IGluZGljYXRvclthY3Rpb25dKCdjbGljaycsIGluZGljYXRvckhhbmRsZXIsIGZhbHNlKTsgfVxuICAgICAgaWYgKG9wcy5rZXlib2FyZCkgeyB3aW5kb3dbYWN0aW9uXSgna2V5ZG93bicsIGtleUhhbmRsZXIsIGZhbHNlKTsgfVxuICAgIH1cbiAgICAvLyB0b3VjaCBldmVudHNcbiAgICBmdW5jdGlvbiB0b2dnbGVUb3VjaEV2ZW50cyhhZGQpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oJ3RvdWNobW92ZScsIHRvdWNoTW92ZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSgndG91Y2hlbmQnLCB0b3VjaEVuZEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG91Y2hEb3duSGFuZGxlcihlKSB7XG4gICAgICBpZiAodmFycy5pc1RvdWNoKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblxuICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgIHZhcnMuaXNUb3VjaCA9IHRydWU7XG4gICAgICAgIHRvZ2dsZVRvdWNoRXZlbnRzKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaE1vdmVIYW5kbGVyKGUpIHtcbiAgICAgIGlmICghdmFycy5pc1RvdWNoKSB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuOyB9XG5cbiAgICAgIHZhcnMudG91Y2hQb3NpdGlvbi5jdXJyZW50WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG5cbiAgICAgIC8vIGNhbmNlbCB0b3VjaCBpZiBtb3JlIHRoYW4gb25lIGNoYW5nZWRUb3VjaGVzIGRldGVjdGVkXG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaEVuZEhhbmRsZXIoZSkge1xuICAgICAgaWYgKCF2YXJzLmlzVG91Y2ggfHwgdmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhcnMudG91Y2hQb3NpdGlvbi5lbmRYID0gdmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG5cbiAgICAgIGlmICh2YXJzLmlzVG91Y2gpIHtcbiAgICAgICAgaWYgKCghZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgfHwgIWVsZW1lbnQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICYmIE1hdGguYWJzKHZhcnMudG91Y2hQb3NpdGlvbi5zdGFydFggLSB2YXJzLnRvdWNoUG9zaXRpb24uZW5kWCkgPCA3NSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYIDwgdmFycy50b3VjaFBvc2l0aW9uLnN0YXJ0WCkge1xuICAgICAgICAgIHZhcnMuaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh2YXJzLnRvdWNoUG9zaXRpb24uY3VycmVudFggPiB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYKSB7XG4gICAgICAgICAgdmFycy5pbmRleCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhcnMuaXNUb3VjaCA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNsaWRlVG8odmFycy5pbmRleCk7XG5cbiAgICAgICAgdG9nZ2xlVG91Y2hFdmVudHMoKTsgLy8gcmVtb3ZlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIHNldEFjdGl2ZVBhZ2UocGFnZUluZGV4KSB7IC8vIGluZGljYXRvcnNcbiAgICAgIEFycmF5LmZyb20oaW5kaWNhdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgfSk7XG4gICAgICBpZiAoaW5kaWNhdG9yc1twYWdlSW5kZXhdKSB7IGluZGljYXRvcnNbcGFnZUluZGV4XS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcihlKSB7XG4gICAgICBpZiAodmFycy50b3VjaFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdmFycy5pbmRleDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBlICYmIGUudGFyZ2V0ICE9PSBzbGlkZXNbbmV4dF0gPyBlLmVsYXBzZWRUaW1lICogMTAwMCArIDEwMCA6IDIwO1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKTtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gdmFycy5kaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcblxuICAgICAgICBpZiAodmFycy5pc1NsaWRpbmcpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh2YXJzLnRvdWNoUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgdmFycy5pc1NsaWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblxuICAgICAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LnJlbW92ZSgoXCJjYXJvdXNlbC1pdGVtLVwiICsgb3JpZW50YXRpb24pKTtcbiAgICAgICAgICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcbiAgICAgICAgICAgICAgc2xpZGVzW2FjdGl2ZUl0ZW1dLmNsYXNzTGlzdC5yZW1vdmUoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcblxuICAgICAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2xpZEN1c3RvbUV2ZW50KTtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVsZW1lbnQsIG1pZ2h0IGhhdmUgYmVlbiBkaXNwb3NlZFxuICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBvcHMuaW50ZXJ2YWwgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBzZWxmLmN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZhcnMudGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgICAgdmFycy50aW1lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhcnMudGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB2YXJzLmluZGV4IHx8IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudEluU2Nyb2xsUmFuZ2UoZWxlbWVudCkpIHtcbiAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICBzZWxmLnNsaWRlVG8oaWR4KTtcbiAgICAgICAgfVxuICAgICAgfSwgb3BzLmludGVydmFsKTtcbiAgICB9O1xuICAgIHNlbGYuc2xpZGVUbyA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIGlmICh2YXJzLmlzU2xpZGluZykgeyByZXR1cm47IH0gLy8gd2hlbiBjb250cm9sZWQgdmlhIG1ldGhvZHMsIG1ha2Ugc3VyZSB0byBjaGVjayBhZ2FpblxuXG4gICAgICAvLyB0aGUgY3VycmVudCBhY3RpdmUsIG9yaWVudGF0aW9uLCBldmVudCBldmVudFByb3BlcnRpZXNcbiAgICAgIHZhciBhY3RpdmVJdGVtID0gc2VsZi5nZXRBY3RpdmVJbmRleCgpO1xuICAgICAgdmFyIG5leHQgPSBpZHg7XG5cbiAgICAgIC8vIGZpcnN0IHJldHVybiBpZiB3ZSdyZSBvbiB0aGUgc2FtZSBpdGVtICMyMjdcbiAgICAgIGlmIChhY3RpdmVJdGVtID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIC8vIG9yIGRldGVybWluZSBzbGlkZSBkaXJlY3Rpb25cbiAgICAgIH0gaWYgKChhY3RpdmVJdGVtIDwgbmV4dCkgfHwgKGFjdGl2ZUl0ZW0gPT09IDAgJiYgbmV4dCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgIHZhcnMuZGlyZWN0aW9uID0gJ2xlZnQnOyAvLyBuZXh0XG4gICAgICB9IGVsc2UgaWYgKChhY3RpdmVJdGVtID4gbmV4dCkgfHwgKGFjdGl2ZUl0ZW0gPT09IHNsaWRlcy5sZW5ndGggLSAxICYmIG5leHQgPT09IDApKSB7XG4gICAgICAgIHZhcnMuZGlyZWN0aW9uID0gJ3JpZ2h0JzsgLy8gcHJldlxuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIHRoZSByaWdodCBuZXh0IGluZGV4XG4gICAgICBpZiAobmV4dCA8IDApIHsgbmV4dCA9IHNsaWRlcy5sZW5ndGggLSAxOyB9XG4gICAgICBlbHNlIGlmIChuZXh0ID49IHNsaWRlcy5sZW5ndGgpIHsgbmV4dCA9IDA7IH1cblxuICAgICAgdmFyIG9yaWVudGF0aW9uID0gdmFycy5kaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JzsgLy8gZGV0ZXJtaW5lIHR5cGVcblxuICAgICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogc2xpZGVzW25leHRdLCBkaXJlY3Rpb246IHZhcnMuZGlyZWN0aW9uLCBmcm9tOiBhY3RpdmVJdGVtLCB0bzogbmV4dCxcbiAgICAgIH07XG4gICAgICBzbGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3NsaWRlJywgJ2Nhcm91c2VsJywgZXZlbnRQcm9wZXJ0aWVzKTtcbiAgICAgIHNsaWRDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzbGlkJywgJ2Nhcm91c2VsJywgZXZlbnRQcm9wZXJ0aWVzKTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkZUN1c3RvbUV2ZW50KTsgLy8gaGVyZSB3ZSBnbyB3aXRoIHRoZSBzbGlkZVxuICAgICAgaWYgKHNsaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH0gLy8gZGlzY29udGludWUgd2hlbiBwcmV2ZW50ZWRcblxuICAgICAgLy8gdXBkYXRlIGluZGV4XG4gICAgICB2YXJzLmluZGV4ID0gbmV4dDtcblxuICAgICAgdmFycy5pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKTtcbiAgICAgIHZhcnMudGltZXIgPSBudWxsO1xuICAgICAgc2V0QWN0aXZlUGFnZShuZXh0KTtcblxuICAgICAgaWYgKGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oc2xpZGVzW25leHRdKSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2xpZGUnKSkge1xuICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgoXCJjYXJvdXNlbC1pdGVtLVwiICsgb3JpZW50YXRpb24pKTtcbiAgICAgICAgcmVmbG93KHNsaWRlc1tuZXh0XSk7XG4gICAgICAgIHNsaWRlc1tuZXh0XS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG4gICAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QuYWRkKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG5cbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoc2xpZGVzW25leHRdLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHJlZmxvdyhzbGlkZXNbbmV4dF0pO1xuICAgICAgICBzbGlkZXNbYWN0aXZlSXRlbV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhcnMuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGVsZW1lbnQsIG1pZ2h0IGhhdmUgYmVlbiBkaXNwb3NlZFxuICAgICAgICAgIGlmIChvcHMuaW50ZXJ2YWwgJiYgZWxlbWVudCAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhdXNlZCcpKSB7XG4gICAgICAgICAgICBzZWxmLmN5Y2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkQ3VzdG9tRXZlbnQpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldEFjdGl2ZUluZGV4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbShzbGlkZXMpLmluZGV4T2YoZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pdGVtIGFjdGl2ZScpWzBdKSB8fCAwOyB9O1xuXG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGl0ZW1DbGFzc2VzID0gWydsZWZ0JywgJ3JpZ2h0JywgJ3ByZXYnLCAnbmV4dCddO1xuXG4gICAgICBBcnJheS5mcm9tKHNsaWRlcykuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUsIGlkeCkge1xuICAgICAgICBpZiAoc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgeyBzZXRBY3RpdmVQYWdlKGlkeCk7IH1cbiAgICAgICAgaXRlbUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJldHVybiBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKChcImNhcm91c2VsLWl0ZW0tXCIgKyBjbHMpKTsgfSk7XG4gICAgICB9KTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG5cbiAgICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgICAgdmFycyA9IHt9O1xuICAgICAgb3BzID0ge307XG4gICAgICBkZWxldGUgZWxlbWVudC5DYXJvdXNlbDtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbSk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuQ2Fyb3VzZWwpIHsgZWxlbWVudC5DYXJvdXNlbC5kaXNwb3NlKCk7IH1cblxuICAgIC8vIGNhcm91c2VsIGVsZW1lbnRzXG4gICAgc2xpZGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pdGVtJyk7XG4gICAgKGFzc2lnbiA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtY29udHJvbC1wcmV2JyksIGxlZnRBcnJvdyA9IGFzc2lnblswXSk7XG4gICAgKGFzc2lnbiQxID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1jb250cm9sLW5leHQnKSwgcmlnaHRBcnJvdyA9IGFzc2lnbiQxWzBdKTtcbiAgICAoYXNzaWduJDIgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWluZGljYXRvcnMnKSwgaW5kaWNhdG9yID0gYXNzaWduJDJbMF0pO1xuICAgIGluZGljYXRvcnMgPSAoaW5kaWNhdG9yICYmIGluZGljYXRvci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnTEknKSkgfHwgW107XG5cbiAgICAvLyBpbnZhbGlkYXRlIHdoZW4gbm90IGVub3VnaCBpdGVtc1xuICAgIGlmIChzbGlkZXMubGVuZ3RoIDwgMikgeyByZXR1cm47IH1cblxuICAgIC8vIGNoZWNrIG9wdGlvbnNcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBpbnRlcnZhbEF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWludGVydmFsJyk7XG4gICAgdmFyIGludGVydmFsRGF0YSA9IGludGVydmFsQXR0cmlidXRlID09PSAnZmFsc2UnID8gMCA6ICsoaW50ZXJ2YWxBdHRyaWJ1dGUpO1xuICAgIHZhciB0b3VjaERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10b3VjaCcpID09PSAnZmFsc2UnID8gMCA6IDE7XG4gICAgdmFyIHBhdXNlRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhdXNlJykgPT09ICdob3ZlcicgfHwgZmFsc2U7XG4gICAgdmFyIGtleWJvYXJkRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWtleWJvYXJkJykgPT09ICd0cnVlJyB8fCBmYWxzZTtcblxuICAgIC8vIEpTIG9wdGlvbnNcbiAgICB2YXIgaW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLmludGVydmFsO1xuICAgIHZhciB0b3VjaE9wdGlvbiA9IG9wdGlvbnMudG91Y2g7XG5cbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIG9wcyA9IHt9O1xuICAgIG9wcy5rZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgPT09IHRydWUgfHwga2V5Ym9hcmREYXRhO1xuICAgIG9wcy5wYXVzZSA9IChvcHRpb25zLnBhdXNlID09PSAnaG92ZXInIHx8IHBhdXNlRGF0YSkgPyAnaG92ZXInIDogZmFsc2U7IC8vIGZhbHNlIC8gaG92ZXJcbiAgICBvcHMudG91Y2ggPSB0b3VjaE9wdGlvbiB8fCB0b3VjaERhdGE7XG5cbiAgICBvcHMuaW50ZXJ2YWwgPSA1MDAwOyAvLyBib290c3RyYXAgY2Fyb3VzZWwgZGVmYXVsdCBpbnRlcnZhbFxuXG4gICAgaWYgKHR5cGVvZiBpbnRlcnZhbE9wdGlvbiA9PT0gJ251bWJlcicpIHsgb3BzLmludGVydmFsID0gaW50ZXJ2YWxPcHRpb247IH1cbiAgICBlbHNlIGlmIChpbnRlcnZhbE9wdGlvbiA9PT0gZmFsc2UgfHwgaW50ZXJ2YWxEYXRhID09PSAwIHx8IGludGVydmFsRGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgIG9wcy5pbnRlcnZhbCA9IDA7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzTmFOKGludGVydmFsRGF0YSkpIHsgb3BzLmludGVydmFsID0gaW50ZXJ2YWxEYXRhOyB9XG5cbiAgICAvLyBzZXQgZmlyc3Qgc2xpZGUgYWN0aXZlIGlmIG5vbmVcbiAgICBpZiAoc2VsZi5nZXRBY3RpdmVJbmRleCgpIDwgMCkge1xuICAgICAgaWYgKHNsaWRlcy5sZW5ndGgpIHsgc2xpZGVzWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpOyB9XG4gICAgICBpZiAoaW5kaWNhdG9ycy5sZW5ndGgpIHsgc2V0QWN0aXZlUGFnZSgwKTsgfVxuICAgIH1cblxuICAgIC8vIHNldCBpbml0aWFsIHN0YXRlXG4gICAgdmFycyA9IHt9O1xuICAgIHZhcnMuZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgIHZhcnMuaW5kZXggPSAwO1xuICAgIHZhcnMudGltZXIgPSBudWxsO1xuICAgIHZhcnMuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgdmFycy5pc1RvdWNoID0gZmFsc2U7XG4gICAgdmFycy50b3VjaFBvc2l0aW9uID0ge1xuICAgICAgc3RhcnRYOiAwLFxuICAgICAgY3VycmVudFg6IDAsXG4gICAgICBlbmRYOiAwLFxuICAgIH07XG5cbiAgICAvLyBhdHRhY2ggZXZlbnQgaGFuZGxlcnNcbiAgICB0b2dnbGVFdmVudHMoMSk7XG5cbiAgICAvLyBzdGFydCB0byBjeWNsZSBpZiBpbnRlcnZhbCBpcyBzZXRcbiAgICBpZiAob3BzLmludGVydmFsKSB7IHNlbGYuY3ljbGUoKTsgfVxuXG4gICAgLy8gYXNzb2NpYXRlIGluaXQgb2JqZWN0IHRvIHRhcmdldFxuICAgIGVsZW1lbnQuQ2Fyb3VzZWwgPSBzZWxmO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgQ29sbGFwc2VcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBDT0xMQVBTRSBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBDb2xsYXBzZShlbGVtLCBvcHNJbnB1dCkge1xuICAgIHZhciBlbGVtZW50O1xuICAgIC8vIHNldCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBvcHNJbnB1dCB8fCB7fTtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyB0YXJnZXQgcHJhY3RpY2VcbiAgICB2YXIgYWNjb3JkaW9uID0gbnVsbDtcbiAgICB2YXIgY29sbGFwc2UgPSBudWxsO1xuICAgIHZhciBhY3RpdmVDb2xsYXBzZTtcbiAgICB2YXIgYWN0aXZlRWxlbWVudDtcbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIG9wZW5BY3Rpb24oY29sbGFwc2VFbGVtZW50LCB0b2dnbGUpIHtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNpbmcnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZScpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9IChjb2xsYXBzZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0KSArIFwicHhcIjtcblxuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoY29sbGFwc2VFbGVtZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgdG9nZ2xlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZScpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlQWN0aW9uKGNvbGxhcHNlRWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoY29sbGFwc2VFbGVtZW50LnNjcm9sbEhlaWdodCkgKyBcInB4XCI7IC8vIHNldCBoZWlnaHQgZmlyc3RcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZScpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgICByZWZsb3coY29sbGFwc2VFbGVtZW50KTsgLy8gZm9yY2UgcmVmbG93IHRvIGVuYWJsZSB0cmFuc2l0aW9uXG4gICAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG5cbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGNvbGxhcHNlRWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICB0b2dnbGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZScpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKChlICYmIGUudGFyZ2V0LnRhZ05hbWUgPT09ICdBJykgfHwgZWxlbWVudC50YWdOYW1lID09PSAnQScpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICBpZiAoZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFjb2xsYXBzZS5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkgeyBzZWxmLnNob3coKTsgfVxuICAgICAgICBlbHNlIHsgc2VsZi5oaWRlKCk7IH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb2xsYXBzZS5pc0FuaW1hdGluZykgeyByZXR1cm47IH1cbiAgICAgIGNsb3NlQWN0aW9uKGNvbGxhcHNlLCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2VkJyk7XG4gICAgfTtcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXNzaWduO1xuXG4gICAgICBpZiAoYWNjb3JkaW9uKSB7XG4gICAgICAgIChhc3NpZ24gPSBhY2NvcmRpb24uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29sbGFwc2Ugc2hvdycpLCBhY3RpdmVDb2xsYXBzZSA9IGFzc2lnblswXSk7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVDb2xsYXBzZSAmJiAocXVlcnlFbGVtZW50KChcIltkYXRhLXRhcmdldD1cXFwiI1wiICsgKGFjdGl2ZUNvbGxhcHNlLmlkKSArIFwiXFxcIl1cIiksIGFjY29yZGlvbilcbiAgICAgICAgICAgICAgICAgICAgICB8fCBxdWVyeUVsZW1lbnQoKFwiW2hyZWY9XFxcIiNcIiArIChhY3RpdmVDb2xsYXBzZS5pZCkgKyBcIlxcXCJdXCIpLCBhY2NvcmRpb24pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb2xsYXBzZS5pc0FuaW1hdGluZykge1xuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVDb2xsYXBzZSAhPT0gY29sbGFwc2UpIHtcbiAgICAgICAgICBjbG9zZUFjdGlvbihhY3RpdmVDb2xsYXBzZSwgYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuQWN0aW9uKGNvbGxhcHNlLCBlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLnRvZ2dsZSwgZmFsc2UpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuQ29sbGFwc2U7XG4gICAgfTtcblxuICAgIC8vIGluaXRcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW0pO1xuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50LkNvbGxhcHNlKSB7IGVsZW1lbnQuQ29sbGFwc2UuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBhY2NvcmRpb25EYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFyZW50Jyk7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAnY29sbGFwc2UnKTtcbiAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ2NvbGxhcHNlJyk7XG4gICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAnY29sbGFwc2UnKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAnY29sbGFwc2UnKTtcblxuICAgIC8vIGRldGVybWluZSB0YXJnZXRzXG4gICAgY29sbGFwc2UgPSBxdWVyeUVsZW1lbnQob3B0aW9ucy50YXJnZXQgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG5cbiAgICBpZiAoY29sbGFwc2UgIT09IG51bGwpIHsgY29sbGFwc2UuaXNBbmltYXRpbmcgPSBmYWxzZTsgfVxuICAgIHZhciBhY2NvcmRpb25TZWxlY3RvciA9IG9wdGlvbnMucGFyZW50IHx8IGFjY29yZGlvbkRhdGE7XG4gICAgaWYgKGFjY29yZGlvblNlbGVjdG9yKSB7XG4gICAgICBhY2NvcmRpb24gPSBlbGVtZW50LmNsb3Nlc3QoYWNjb3JkaW9uU2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NvcmRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgaWYgKCFlbGVtZW50LkNvbGxhcHNlKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi50b2dnbGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhc3NvY2lhdGUgdGFyZ2V0IHRvIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5Db2xsYXBzZSA9IHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGb2N1cyhlbGVtZW50KSB7XG4gICAgZWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgRHJvcGRvd25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBEUk9QRE9XTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBEcm9wZG93bihlbGVtLCBvcHRpb24pIHtcbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcbiAgICAvLyB0YXJnZXRzXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIHZhciBwYXJlbnQ7IHZhciBtZW51OyB2YXIgbWVudUl0ZW1zID0gW107XG4gICAgLy8gb3B0aW9uXG4gICAgdmFyIHBlcnNpc3Q7XG5cbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbiBlbXB0eSBhbmNob3IgbGlua3NcbiAgICBmdW5jdGlvbiBwcmV2ZW50RW1wdHlBbmNob3IoYW5jaG9yKSB7XG4gICAgICBpZiAoKGFuY2hvci5ocmVmICYmIGFuY2hvci5ocmVmLnNsaWNlKC0xKSA9PT0gJyMnKSB8fCAoYW5jaG9yLnBhcmVudE5vZGUgJiYgYW5jaG9yLnBhcmVudE5vZGUuaHJlZlxuICAgICAgICAmJiBhbmNob3IucGFyZW50Tm9kZS5ocmVmLnNsaWNlKC0xKSA9PT0gJyMnKSkgeyB0aGlzLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICB9XG4gICAgLy8gdG9nZ2xlIGRpc21pc3NpYmxlIGV2ZW50c1xuICAgIGZ1bmN0aW9uIHRvZ2dsZURpc21pc3MoKSB7XG4gICAgICB2YXIgYWN0aW9uID0gZWxlbWVudC5vcGVuID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgnY2xpY2snLCBkaXNtaXNzSGFuZGxlciwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgna2V5ZG93bicsIHByZXZlbnRTY3JvbGwsIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50W2FjdGlvbl0oJ2tleXVwJywga2V5SGFuZGxlciwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgnZm9jdXMnLCBkaXNtaXNzSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBoYW5kbGVyc1xuICAgIGZ1bmN0aW9uIGRpc21pc3NIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBldmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgaWYgKCFldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHsgcmV0dXJuOyB9IC8vIHNvbWUgd2VpcmQgRkYgYnVnICM0MDlcbiAgICAgIHZhciBoYXNEYXRhID0gKChldmVudFRhcmdldCAmJiAoZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoZXZlbnRUYXJnZXQucGFyZW50Tm9kZSAmJiBldmVudFRhcmdldC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpKSk7XG4gICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnICYmIChldmVudFRhcmdldCA9PT0gZWxlbWVudCB8fCBldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSkgJiYgKHBlcnNpc3QgfHwgaGFzRGF0YSkpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBldmVudFRhcmdldCA9PT0gZWxlbWVudCB8fCBlbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSA/IGVsZW1lbnQgOiBudWxsO1xuICAgICAgc2VsZi5oaWRlKCk7XG5cbiAgICAgIHByZXZlbnRFbXB0eUFuY2hvci5jYWxsKGUsIGV2ZW50VGFyZ2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBlbGVtZW50O1xuICAgICAgc2VsZi5zaG93KCk7XG4gICAgICBwcmV2ZW50RW1wdHlBbmNob3IuY2FsbChlLCBlLnRhcmdldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXZlbnRTY3JvbGwoZSkge1xuICAgICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgICAgaWYgKGtleSA9PT0gMzggfHwga2V5ID09PSA0MCkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICB2YXIgYWN0aXZlSXRlbSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB2YXIgaXNTYW1lRWxlbWVudCA9IGFjdGl2ZUl0ZW0gPT09IGVsZW1lbnQ7XG4gICAgICB2YXIgaXNJbnNpZGVNZW51ID0gbWVudS5jb250YWlucyhhY3RpdmVJdGVtKTtcbiAgICAgIHZhciBpc01lbnVJdGVtID0gYWN0aXZlSXRlbS5wYXJlbnROb2RlID09PSBtZW51IHx8IGFjdGl2ZUl0ZW0ucGFyZW50Tm9kZS5wYXJlbnROb2RlID09PSBtZW51O1xuICAgICAgdmFyIGlkeCA9IG1lbnVJdGVtcy5pbmRleE9mKGFjdGl2ZUl0ZW0pO1xuXG4gICAgICBpZiAoaXNNZW51SXRlbSkgeyAvLyBuYXZpZ2F0ZSB1cCB8IGRvd25cbiAgICAgICAgaWYgKGlzU2FtZUVsZW1lbnQpIHtcbiAgICAgICAgICBpZHggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gMzgpIHtcbiAgICAgICAgICBpZHggPSBpZHggPiAxID8gaWR4IC0gMSA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSA0MCkge1xuICAgICAgICAgIGlkeCA9IGlkeCA8IG1lbnVJdGVtcy5sZW5ndGggLSAxID8gaWR4ICsgMSA6IGlkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZW51SXRlbXNbaWR4XSkgeyBzZXRGb2N1cyhtZW51SXRlbXNbaWR4XSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICgoKG1lbnVJdGVtcy5sZW5ndGggJiYgaXNNZW51SXRlbSkgLy8gbWVudSBoYXMgaXRlbXNcbiAgICAgICAgICAgIHx8ICghbWVudUl0ZW1zLmxlbmd0aCAmJiAoaXNJbnNpZGVNZW51IHx8IGlzU2FtZUVsZW1lbnQpKSAvLyBtZW51IG1pZ2h0IGJlIGEgZm9ybVxuICAgICAgICAgICAgfHwgIWlzSW5zaWRlTWVudSkgLy8gb3IgdGhlIGZvY3VzZWQgZWxlbWVudCBpcyBub3QgaW4gdGhlIG1lbnUgYXQgYWxsXG4gICAgICAgICAgICAmJiBlbGVtZW50Lm9wZW4gJiYga2V5ID09PSAyNyAvLyBtZW51IG11c3QgYmUgb3BlblxuICAgICAgKSB7XG4gICAgICAgIHNlbGYudG9nZ2xlKCk7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAnZHJvcGRvd24nLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuXG4gICAgICBtZW51LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgZWxlbWVudC5vcGVuID0gdHJ1ZTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRGb2N1cyhtZW51LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdIHx8IGVsZW1lbnQpOyAvLyBmb2N1cyB0aGUgZmlyc3QgaW5wdXQgaXRlbSB8IGVsZW1lbnRcbiAgICAgICAgdG9nZ2xlRGlzbWlzcygpO1xuICAgICAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ2Ryb3Bkb3duJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0IH0pO1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICAgIH0sIDEpO1xuICAgIH07XG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAnZHJvcGRvd24nLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuXG4gICAgICBtZW51LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnQub3BlbiA9IGZhbHNlO1xuICAgICAgdG9nZ2xlRGlzbWlzcygpO1xuICAgICAgc2V0Rm9jdXMoZWxlbWVudCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb25seSByZS1hdHRhY2ggaGFuZGxlciBpZiB0aGUgaW5pdCBpcyBub3QgZGlzcG9zZWRcbiAgICAgICAgaWYgKGVsZW1lbnQuRHJvcGRvd24pIHsgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpOyB9XG4gICAgICB9LCAxKTtcblxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ2Ryb3Bkb3duJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0IH0pO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICAgIH07XG4gICAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmIGVsZW1lbnQub3BlbikgeyBzZWxmLmhpZGUoKTsgfSBlbHNlIHsgc2VsZi5zaG93KCk7IH1cbiAgICB9O1xuICAgIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgZWxlbWVudC5vcGVuKSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkZWxldGUgZWxlbWVudC5Ecm9wZG93bjtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbSk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuRHJvcGRvd24pIHsgZWxlbWVudC5Ecm9wZG93bi5kaXNwb3NlKCk7IH1cblxuICAgIC8vIHNldCAgdGFyZ2V0c1xuICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBtZW51ID0gcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tbWVudScsIHBhcmVudCk7XG5cbiAgICBBcnJheS5mcm9tKG1lbnUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkLmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICBtZW51SXRlbXMucHVzaChjaGlsZC5jaGlsZHJlblswXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0EnKSB7IG1lbnVJdGVtcy5wdXNoKGNoaWxkKTsgfVxuICAgIH0pO1xuXG4gICAgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICBpZiAoIWVsZW1lbnQuRHJvcGRvd24pIHtcbiAgICAgIGlmICghKCd0YWJpbmRleCcgaW4gbWVudSkpIHsgbWVudS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTsgfSAvLyBGaXggb25ibHVyIG9uIENocm9tZSB8IFNhZmFyaVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIHNldCBvcHRpb25cbiAgICBwZXJzaXN0ID0gb3B0aW9uID09PSB0cnVlIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBlcnNpc3QnKSA9PT0gJ3RydWUnIHx8IGZhbHNlO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgc3RhdGUgdG8gY2xvc2VkXG4gICAgZWxlbWVudC5vcGVuID0gZmFsc2U7XG5cbiAgICAvLyBhc3NvY2lhdGUgZWxlbWVudCB3aXRoIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5Ecm9wZG93biA9IHNlbGY7XG4gIH1cblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBNb2RhbFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8vIE1PREFMIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIE1vZGFsKGVsZW0sIG9wc0lucHV0KSB7IC8vIGVsZW1lbnQgY2FuIGJlIHRoZSBtb2RhbC90cmlnZ2VyaW5nIGJ1dHRvblxuICAgIHZhciBlbGVtZW50O1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZCwgbW9kYWxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1vZGFsO1xuXG4gICAgLy8gY3VzdG9tIGV2ZW50c1xuICAgIHZhciBzaG93Q3VzdG9tRXZlbnQ7XG4gICAgdmFyIHNob3duQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGVDdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZGVuQ3VzdG9tRXZlbnQ7XG4gICAgLy8gZXZlbnQgdGFyZ2V0cyBhbmQgb3RoZXJcbiAgICB2YXIgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgdmFyIHNjcm9sbEJhcldpZHRoO1xuICAgIHZhciBvdmVybGF5O1xuICAgIHZhciBvdmVybGF5RGVsYXk7XG5cbiAgICAvLyBhbHNvIGZpbmQgZml4ZWQtdG9wIC8gZml4ZWQtYm90dG9tIGl0ZW1zXG4gICAgdmFyIGZpeGVkSXRlbXM7XG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgZnVuY3Rpb24gc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgdmFyIGJvZHlDbGFzc0xpc3QgPSBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdDtcbiAgICAgIHZhciBvcGVuTW9kYWwgPSBib2R5Q2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbC1vcGVuJyk7XG4gICAgICB2YXIgYm9keVBhZCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkucGFkZGluZ1JpZ2h0LCAxMCk7XG4gICAgICB2YXIgZG9jQ2xpZW50SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgIHZhciBkb2NTY3JvbGxIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdmFyIGJvZHlDbGllbnRIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcbiAgICAgIHZhciBib2R5U2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQ7XG4gICAgICB2YXIgYm9keU92ZXJmbG93ID0gZG9jQ2xpZW50SGVpZ2h0ICE9PSBkb2NTY3JvbGxIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICB8fCBib2R5Q2xpZW50SGVpZ2h0ICE9PSBib2R5U2Nyb2xsSGVpZ2h0O1xuICAgICAgdmFyIG1vZGFsT3ZlcmZsb3cgPSBtb2RhbC5jbGllbnRIZWlnaHQgIT09IG1vZGFsLnNjcm9sbEhlaWdodDtcblxuICAgICAgc2Nyb2xsQmFyV2lkdGggPSBtZWFzdXJlU2Nyb2xsYmFyKCk7XG5cbiAgICAgIG1vZGFsLnN0eWxlLnBhZGRpbmdSaWdodCA9ICFtb2RhbE92ZXJmbG93ICYmIHNjcm9sbEJhcldpZHRoID8gKHNjcm9sbEJhcldpZHRoICsgXCJweFwiKSA6ICcnO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBtb2RhbE92ZXJmbG93IHx8IGJvZHlPdmVyZmxvd1xuICAgICAgICA/ICgoYm9keVBhZCArIChvcGVuTW9kYWwgPyAwIDogc2Nyb2xsQmFyV2lkdGgpKSArIFwicHhcIikgOiAnJztcblxuICAgICAgaWYgKGZpeGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGZpeGVkSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoZml4ZWQpIHtcbiAgICAgICAgICB2YXIgaXRlbVBhZCA9IGdldENvbXB1dGVkU3R5bGUoZml4ZWQpLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICBmaXhlZC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBtb2RhbE92ZXJmbG93IHx8IGJvZHlPdmVyZmxvd1xuICAgICAgICAgICAgPyAoKHBhcnNlSW50KGl0ZW1QYWQsIDEwKSArIChvcGVuTW9kYWwgPyAwIDogc2Nyb2xsQmFyV2lkdGgpKSArIFwicHhcIilcbiAgICAgICAgICAgIDogKChwYXJzZUludChpdGVtUGFkLCAxMCkpICsgXCJweFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICAgIG1vZGFsLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgICAgaWYgKGZpeGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGZpeGVkSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoZml4ZWQpIHtcbiAgICAgICAgICBmaXhlZC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lYXN1cmVTY3JvbGxiYXIoKSB7XG4gICAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJzsgLy8gdGhpcyBpcyBoZXJlIHRvIHN0YXlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICAgIHZhciB3aWR0aFZhbHVlID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgcmV0dXJuIHdpZHRoVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXkoKSB7XG4gICAgICB2YXIgbmV3T3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWJhY2tkcm9wJyk7XG5cbiAgICAgIGlmIChvdmVybGF5ID09PSBudWxsKSB7XG4gICAgICAgIG5ld092ZXJsYXkuc2V0QXR0cmlidXRlKCdjbGFzcycsIChcIm1vZGFsLWJhY2tkcm9wXCIgKyAob3BzLmFuaW1hdGlvbiA/ICcgZmFkZScgOiAnJykpKTtcbiAgICAgICAgb3ZlcmxheSA9IG5ld092ZXJsYXk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlT3ZlcmxheSgpIHtcbiAgICAgIG92ZXJsYXkgPSBxdWVyeUVsZW1lbnQoJy5tb2RhbC1iYWNrZHJvcCcpO1xuICAgICAgaWYgKG92ZXJsYXkgJiYgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXkpOyBvdmVybGF5ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5ID09PSBudWxsKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbW9kYWwtb3BlbicpO1xuICAgICAgICByZXNldFNjcm9sbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIHNlbGYudXBkYXRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICBtb2RhbFthY3Rpb25dKCdjbGljaycsIGRpc21pc3NIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudFthY3Rpb25dKCdrZXlkb3duJywga2V5SGFuZGxlciwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2Vyc1xuICAgIGZ1bmN0aW9uIGJlZm9yZVNob3coKSB7XG4gICAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSkgeyBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ21vZGFsLW9wZW4nKTsgfVxuXG4gICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuXG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykpIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWwsIHRyaWdnZXJTaG93KTsgfVxuICAgICAgZWxzZSB7IHRyaWdnZXJTaG93KCk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpZ2dlclNob3coKSB7XG4gICAgICBzZXRGb2N1cyhtb2RhbCk7XG4gICAgICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICB0b2dnbGVFdmVudHMoMSk7XG5cbiAgICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAnbW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VySGlkZShmb3JjZSkge1xuICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgaWYgKGVsZW1lbnQpIHsgc2V0Rm9jdXMoZWxlbWVudCk7IH1cblxuICAgICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWJhY2tkcm9wJyk7XG5cbiAgICAgIC8vIGZvcmNlIGNhbiBhbHNvIGJlIHRoZSB0cmFuc2l0aW9uRXZlbnQgb2JqZWN0LCB3ZSB3YW5uYSBtYWtlIHN1cmUgaXQncyBub3RcbiAgICAgIGlmIChmb3JjZSAhPT0gMSAmJiBvdmVybGF5ICYmIG92ZXJsYXkuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSkge1xuICAgICAgICBvdmVybGF5LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQob3ZlcmxheSwgcmVtb3ZlT3ZlcmxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVPdmVybGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHRvZ2dsZUV2ZW50cygpO1xuXG4gICAgICBtb2RhbC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAnbW9kYWwnKTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICAvLyBoYW5kbGVyc1xuICAgIGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICBpZiAobW9kYWwuaXNBbmltYXRpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgY2xpY2tUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIHZhciBtb2RhbElEID0gXCIjXCIgKyAobW9kYWwuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgIHZhciB0YXJnZXRBdHRyVmFsdWUgPSBjbGlja1RhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgY2xpY2tUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICB2YXIgZWxlbUF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAgIGlmICghbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JylcbiAgICAgICAgICAmJiAoKGNsaWNrVGFyZ2V0ID09PSBlbGVtZW50ICYmIHRhcmdldEF0dHJWYWx1ZSA9PT0gbW9kYWxJRClcbiAgICAgICAgICB8fCAoZWxlbWVudC5jb250YWlucyhjbGlja1RhcmdldCkgJiYgZWxlbUF0dHJWYWx1ZSA9PT0gbW9kYWxJRCkpKSB7XG4gICAgICAgIG1vZGFsLm1vZGFsVHJpZ2dlciA9IGVsZW1lbnQ7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQgPSBlbGVtZW50O1xuICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlIYW5kbGVyKHJlZikge1xuICAgICAgdmFyIHdoaWNoID0gcmVmLndoaWNoO1xuXG4gICAgICBpZiAoIW1vZGFsLmlzQW5pbWF0aW5nICYmIG9wcy5rZXlib2FyZCAmJiB3aGljaCA9PT0gMjcgJiYgbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc21pc3NIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChtb2RhbC5pc0FuaW1hdGluZykgeyByZXR1cm47IH1cbiAgICAgIHZhciBjbGlja1RhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIGhhc0RhdGEgPSBjbGlja1RhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzbWlzcycpID09PSAnbW9kYWwnO1xuICAgICAgdmFyIHBhcmVudFdpdGhEYXRhID0gY2xpY2tUYXJnZXQuY2xvc2VzdCgnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJyk7XG5cbiAgICAgIGlmIChtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiAocGFyZW50V2l0aERhdGEgfHwgaGFzRGF0YVxuICAgICAgICAgIHx8IChjbGlja1RhcmdldCA9PT0gbW9kYWwgJiYgb3BzLmJhY2tkcm9wICE9PSAnc3RhdGljJykpKSB7XG4gICAgICAgIHNlbGYuaGlkZSgpOyByZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHsgc2VsZi5oaWRlKCk7IH0gZWxzZSB7IHNlbGYuc2hvdygpOyB9XG4gICAgfTtcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgISFtb2RhbC5pc0FuaW1hdGluZykgeyByZXR1cm47IH1cblxuICAgICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAnbW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3dDdXN0b21FdmVudCk7XG5cbiAgICAgIGlmIChzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cblxuICAgICAgbW9kYWwuaXNBbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICAvLyB3ZSBlbGVnYW50bHkgaGlkZSBhbnkgb3BlbmVkIG1vZGFsXG4gICAgICB2YXIgY3VycmVudE9wZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb2RhbCBzaG93JylbMF07XG4gICAgICBpZiAoY3VycmVudE9wZW4gJiYgY3VycmVudE9wZW4gIT09IG1vZGFsKSB7XG4gICAgICAgIGlmIChjdXJyZW50T3Blbi5tb2RhbFRyaWdnZXIpIHsgY3VycmVudE9wZW4ubW9kYWxUcmlnZ2VyLk1vZGFsLmhpZGUoKTsgfVxuICAgICAgICBpZiAoY3VycmVudE9wZW4uTW9kYWwpIHsgY3VycmVudE9wZW4uTW9kYWwuaGlkZSgpOyB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHMuYmFja2Ryb3ApIHsgb3ZlcmxheSA9IGNyZWF0ZU92ZXJsYXkoKTsgfVxuXG4gICAgICBpZiAob3ZlcmxheSAmJiAhY3VycmVudE9wZW4gJiYgIW92ZXJsYXkuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgcmVmbG93KG92ZXJsYXkpO1xuICAgICAgICBvdmVybGF5RGVsYXkgPSBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKG92ZXJsYXkpO1xuICAgICAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50T3BlbikgeyBzZXRUaW1lb3V0KGJlZm9yZVNob3csIG92ZXJsYXkgJiYgb3ZlcmxheURlbGF5ID8gb3ZlcmxheURlbGF5IDogMCk7IH1cbiAgICAgIGVsc2UgeyBiZWZvcmVTaG93KCk7IH1cbiAgICB9O1xuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgaWYgKCFtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkgeyByZXR1cm47IH1cblxuICAgICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAnbW9kYWwnKTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cblxuICAgICAgbW9kYWwuaXNBbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgIGlmIChtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSAmJiBmb3JjZSAhPT0gMSkgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbCwgdHJpZ2dlckhpZGUpOyB9XG4gICAgICBlbHNlIHsgdHJpZ2dlckhpZGUoKTsgfVxuICAgIH07XG4gICAgc2VsZi5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWNvbnRlbnQnLCBtb2RhbCkuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9O1xuICAgIHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgIHNldFNjcm9sbGJhcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5oaWRlKDEpO1xuICAgICAgaWYgKGVsZW1lbnQpIHsgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpOyBkZWxldGUgZWxlbWVudC5Nb2RhbDsgfSBlbHNlIHsgZGVsZXRlIG1vZGFsLk1vZGFsOyB9XG4gICAgfTtcblxuICAgIC8vIGluaXRcblxuICAgIC8vIHRoZSBtb2RhbCAoYm90aCBKYXZhU2NyaXB0IC8gREFUQSBBUEkgaW5pdCkgLyB0cmlnZ2VyaW5nIGJ1dHRvbiBlbGVtZW50IChEQVRBIEFQSSlcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG1vZGFsLCB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICB2YXIgY2hlY2tNb2RhbCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcbiAgICBtb2RhbCA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbCcpID8gZWxlbWVudCA6IGNoZWNrTW9kYWw7XG5cbiAgICAvLyBzZXQgZml4ZWQgaXRlbXNcbiAgICBmaXhlZEl0ZW1zID0gQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmaXhlZC10b3AnKSlcbiAgICAgIC5jb25jYXQoQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmaXhlZC1ib3R0b20nKSkpO1xuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbCcpKSB7IGVsZW1lbnQgPSBudWxsOyB9IC8vIG1vZGFsIGlzIG5vdyBpbmRlcGVuZGVudCBvZiBpdCdzIHRyaWdnZXJpbmcgZWxlbWVudFxuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuTW9kYWwpIHsgZWxlbWVudC5Nb2RhbC5kaXNwb3NlKCk7IH1cbiAgICBpZiAobW9kYWwgJiYgbW9kYWwuTW9kYWwpIHsgbW9kYWwuTW9kYWwuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wcy5rZXlib2FyZCA9ICEob3B0aW9ucy5rZXlib2FyZCA9PT0gZmFsc2UgfHwgbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleWJvYXJkJykgPT09ICdmYWxzZScpO1xuICAgIG9wcy5iYWNrZHJvcCA9IG9wdGlvbnMuYmFja2Ryb3AgPT09ICdzdGF0aWMnIHx8IG1vZGFsLmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrZHJvcCcpID09PSAnc3RhdGljJyA/ICdzdGF0aWMnIDogdHJ1ZTtcbiAgICBvcHMuYmFja2Ryb3AgPSBvcHRpb25zLmJhY2tkcm9wID09PSBmYWxzZSB8fCBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmFja2Ryb3AnKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogb3BzLmJhY2tkcm9wO1xuICAgIG9wcy5hbmltYXRpb24gPSAhIW1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpO1xuICAgIG9wcy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50OyAvLyBKYXZhU2NyaXB0IG9ubHlcblxuICAgIC8vIHNldCBhbiBpbml0aWFsIHN0YXRlIG9mIHRoZSBtb2RhbFxuICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyBvdmVyIGFuZCBvdmVyXG4gICAgLy8gbW9kYWwgaXMgaW5kZXBlbmRlbnQgb2YgYSB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5Nb2RhbCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHMuY29udGVudCkge1xuICAgICAgc2VsZi5zZXRDb250ZW50KG9wcy5jb250ZW50LnRyaW0oKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGFzc29jaWF0aW9uc1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBtb2RhbC5tb2RhbFRyaWdnZXIgPSBlbGVtZW50O1xuICAgICAgZWxlbWVudC5Nb2RhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGFsLk1vZGFsID0gc2VsZjtcbiAgICB9XG4gIH1cblxuICB2YXIgbW91c2VDbGlja0V2ZW50cyA9IHsgZG93bjogJ21vdXNlZG93bicsIHVwOiAnbW91c2V1cCcgfTtcblxuICAvLyBQb3BvdmVyLCBUb29sdGlwICYgU2Nyb2xsU3B5XG4gIGZ1bmN0aW9uIGdldFNjcm9sbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGJvdGggcG9wb3ZlcnMgYW5kIHRvb2x0aXBzICh0YXJnZXQsdG9vbHRpcCxwbGFjZW1lbnQsZWxlbWVudFRvQXBwZW5kVG8pXG4gIGZ1bmN0aW9uIHN0eWxlVGlwKGxpbmssIGVsZW1lbnQsIG9yaWdpbmFsUG9zaXRpb24sIHBhcmVudCkge1xuICAgIHZhciB0aXBQb3NpdGlvbnMgPSAvXFxiKHRvcHxib3R0b218bGVmdHxyaWdodCkrLztcbiAgICB2YXIgZWxlbWVudERpbWVuc2lvbnMgPSB7IHc6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGg6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IH07XG4gICAgdmFyIHdpbmRvd1dpZHRoID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKTtcbiAgICB2YXIgd2luZG93SGVpZ2h0ID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpO1xuICAgIHZhciByZWN0ID0gbGluay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgc2Nyb2xsID0gcGFyZW50ID09PSBkb2N1bWVudC5ib2R5XG4gICAgICA/IGdldFNjcm9sbCgpXG4gICAgICA6IHsgeDogcGFyZW50Lm9mZnNldExlZnQgKyBwYXJlbnQuc2Nyb2xsTGVmdCwgeTogcGFyZW50Lm9mZnNldFRvcCArIHBhcmVudC5zY3JvbGxUb3AgfTtcbiAgICB2YXIgbGlua0RpbWVuc2lvbnMgPSB7IHc6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIGg6IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgfTtcbiAgICB2YXIgaXNQb3BvdmVyID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcG92ZXInKTtcbiAgICB2YXIgYXJyb3cgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Fycm93JylbMF07XG4gICAgdmFyIGhhbGZUb3BFeGNlZWQgPSByZWN0LnRvcCArIGxpbmtEaW1lbnNpb25zLmggLyAyIC0gZWxlbWVudERpbWVuc2lvbnMuaCAvIDIgPCAwO1xuICAgIHZhciBoYWxmTGVmdEV4Y2VlZCA9IHJlY3QubGVmdCArIGxpbmtEaW1lbnNpb25zLncgLyAyIC0gZWxlbWVudERpbWVuc2lvbnMudyAvIDIgPCAwO1xuICAgIHZhciBoYWxmUmlnaHRFeGNlZWQgPSByZWN0LmxlZnQgKyBlbGVtZW50RGltZW5zaW9ucy53IC8gMlxuICAgICAgKyBsaW5rRGltZW5zaW9ucy53IC8gMiA+PSB3aW5kb3dXaWR0aDtcbiAgICB2YXIgaGFsZkJvdHRvbUV4Y2VlZCA9IHJlY3QudG9wICsgZWxlbWVudERpbWVuc2lvbnMuaCAvIDJcbiAgICAgICsgbGlua0RpbWVuc2lvbnMuaCAvIDIgPj0gd2luZG93SGVpZ2h0O1xuICAgIHZhciB0b3BFeGNlZWQgPSByZWN0LnRvcCAtIGVsZW1lbnREaW1lbnNpb25zLmggPCAwO1xuICAgIHZhciBsZWZ0RXhjZWVkID0gcmVjdC5sZWZ0IC0gZWxlbWVudERpbWVuc2lvbnMudyA8IDA7XG4gICAgdmFyIGJvdHRvbUV4Y2VlZCA9IHJlY3QudG9wICsgZWxlbWVudERpbWVuc2lvbnMuaCArIGxpbmtEaW1lbnNpb25zLmggPj0gd2luZG93SGVpZ2h0O1xuICAgIHZhciByaWdodEV4Y2VlZCA9IHJlY3QubGVmdCArIGVsZW1lbnREaW1lbnNpb25zLncgKyBsaW5rRGltZW5zaW9ucy53ID49IHdpbmRvd1dpZHRoO1xuICAgIHZhciBwb3NpdGlvbiA9IG9yaWdpbmFsUG9zaXRpb247XG5cbiAgICAvLyByZWNvbXB1dGUgcG9zaXRpb25cbiAgICAvLyBmaXJzdCwgd2hlbiBib3RoIGxlZnQgYW5kIHJpZ2h0IGxpbWl0cyBhcmUgZXhjZWVkZWQsIHdlIGZhbGwgYmFjayB0byB0b3B8Ym90dG9tXG4gICAgcG9zaXRpb24gPSAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykgJiYgbGVmdEV4Y2VlZCAmJiByaWdodEV4Y2VlZCA/ICd0b3AnIDogcG9zaXRpb247XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdG9wRXhjZWVkID8gJ2JvdHRvbScgOiBwb3NpdGlvbjtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSAnYm90dG9tJyAmJiBib3R0b21FeGNlZWQgPyAndG9wJyA6IHBvc2l0aW9uO1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyAmJiBsZWZ0RXhjZWVkID8gJ3JpZ2h0JyA6IHBvc2l0aW9uO1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdyaWdodCcgJiYgcmlnaHRFeGNlZWQgPyAnbGVmdCcgOiBwb3NpdGlvbjtcblxuICAgIHZhciB0b3BQb3NpdGlvbjtcbiAgICB2YXIgbGVmdFBvc2l0aW9uO1xuICAgIHZhciBhcnJvd1RvcDtcbiAgICB2YXIgYXJyb3dMZWZ0O1xuXG4gICAgLy8gdXBkYXRlIHRvb2x0aXAvcG9wb3ZlciBjbGFzc1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh0aXBQb3NpdGlvbnMsIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBjaGVjayB0aGUgY29tcHV0ZWQgd2lkdGggJiBoZWlnaHQgYW5kIHVwZGF0ZSBoZXJlXG4gICAgdmFyIGFycm93V2lkdGggPSBhcnJvdy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgYXJyb3dIZWlnaHQgPSBhcnJvdy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBhcHBseSBzdHlsaW5nIHRvIHRvb2x0aXAgb3IgcG9wb3ZlclxuICAgIC8vIHNlY29uZGFyeXxzaWRlIHBvc2l0aW9uc1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JykgeyAvLyBMRUZUXG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3QubGVmdCArIHNjcm9sbC54IC0gZWxlbWVudERpbWVuc2lvbnMudyAtIChpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogMCk7XG4gICAgICB9IGVsc2UgeyAvLyBSSUdIVFxuICAgICAgICBsZWZ0UG9zaXRpb24gPSByZWN0LmxlZnQgKyBzY3JvbGwueCArIGxpbmtEaW1lbnNpb25zLnc7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkanVzdCB0b3AgYW5kIGFycm93XG4gICAgICBpZiAoaGFsZlRvcEV4Y2VlZCkge1xuICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnk7XG4gICAgICAgIGFycm93VG9wID0gbGlua0RpbWVuc2lvbnMuaCAvIDIgLSBhcnJvd1dpZHRoO1xuICAgICAgfSBlbHNlIGlmIChoYWxmQm90dG9tRXhjZWVkKSB7XG4gICAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oO1xuICAgICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmggLSBsaW5rRGltZW5zaW9ucy5oIC8gMiAtIGFycm93V2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3QudG9wICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oIC8gMiArIGxpbmtEaW1lbnNpb25zLmggLyAyO1xuICAgICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmggLyAyIC0gKGlzUG9wb3ZlciA/IGFycm93SGVpZ2h0ICogMC45IDogYXJyb3dIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAvLyBwcmltYXJ5fHZlcnRpY2FsIHBvc2l0aW9uc1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykgeyAvLyBUT1BcbiAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaCAtIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDApO1xuICAgICAgfSBlbHNlIHsgLy8gQk9UVE9NXG4gICAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVmdCB8IHJpZ2h0IGFuZCBhbHNvIHRoZSBhcnJvd1xuICAgICAgaWYgKGhhbGZMZWZ0RXhjZWVkKSB7XG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGFycm93TGVmdCA9IHJlY3QubGVmdCArIGxpbmtEaW1lbnNpb25zLncgLyAyIC0gYXJyb3dXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoaGFsZlJpZ2h0RXhjZWVkKSB7XG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IHdpbmRvd1dpZHRoIC0gZWxlbWVudERpbWVuc2lvbnMudyAqIDEuMDE7XG4gICAgICAgIGFycm93TGVmdCA9IGVsZW1lbnREaW1lbnNpb25zLncgLSAod2luZG93V2lkdGggLSByZWN0LmxlZnQpXG4gICAgICAgICAgKyBsaW5rRGltZW5zaW9ucy53IC8gMiAtIGFycm93V2lkdGggLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53IC8gMiArIGxpbmtEaW1lbnNpb25zLncgLyAyO1xuICAgICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53IC8gMiAtIChpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogYXJyb3dXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHN0eWxlIHRvIHRvb2x0aXAvcG9wb3ZlciBhbmQgaXRzIGFycm93XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSB0b3BQb3NpdGlvbiArIFwicHhcIjtcbiAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0UG9zaXRpb24gKyBcInB4XCI7XG5cbiAgICBpZiAoYXJyb3dUb3ApIHsgYXJyb3cuc3R5bGUudG9wID0gYXJyb3dUb3AgKyBcInB4XCI7IH1cbiAgICBpZiAoYXJyb3dMZWZ0KSB7IGFycm93LnN0eWxlLmxlZnQgPSBhcnJvd0xlZnQgKyBcInB4XCI7IH1cbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFBvcG92ZXJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8vIFBPUE9WRVIgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQb3BvdmVyKGVsZW0sIG9wc0lucHV0KSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHBvcG92ZXIgYW5kIHRpbWVyXG4gICAgdmFyIHBvcG92ZXIgPSBudWxsO1xuICAgIHZhciB0aW1lciA9IDA7XG4gICAgdmFyIGlzSXBob25lID0gLyhpUGhvbmV8aVBvZHxpUGFkKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAvLyB0aXRsZSBhbmQgY29udGVudFxuICAgIHZhciB0aXRsZVN0cmluZztcbiAgICB2YXIgY29udGVudFN0cmluZztcbiAgICB2YXIgcGxhY2VtZW50Q2xhc3M7XG5cbiAgICAvLyBvcHRpb25zXG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gY2xvc2UgYnRuIGZvciBkaXNzbWlzc2libGUgcG9wb3ZlclxuICAgIHZhciBjbG9zZUJ0bjtcblxuICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICB2YXIgc2hvd0N1c3RvbUV2ZW50O1xuICAgIHZhciBzaG93bkN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRlQ3VzdG9tRXZlbnQ7XG4gICAgdmFyIGhpZGRlbkN1c3RvbUV2ZW50O1xuXG4gICAgLy8gaGFuZGxlcnNcbiAgICBmdW5jdGlvbiBkaXNtaXNzaWJsZUhhbmRsZXIoZSkge1xuICAgICAgaWYgKHBvcG92ZXIgIT09IG51bGwgJiYgZS50YXJnZXQgPT09IHF1ZXJ5RWxlbWVudCgnLmNsb3NlJywgcG9wb3ZlcikpIHtcbiAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGdldEF0dHIoYXR0KSB7XG4gICAgICByZXR1cm4gb3B0aW9uc1thdHRdIHx8IGVsZW1lbnQuZGF0YXNldFthdHRdIHx8IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIGdldEF0dHIoJ3RpdGxlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gZ2V0QXR0cignY29udGVudCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVQb3BvdmVyKCkge1xuICAgICAgb3BzLmNvbnRhaW5lci5yZW1vdmVDaGlsZChwb3BvdmVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDsgcG9wb3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUG9wb3ZlcigpIHtcbiAgICAgIHRpdGxlU3RyaW5nID0gZ2V0VGl0bGUoKTtcbiAgICAgIGNvbnRlbnRTdHJpbmcgPSBnZXRDb250ZW50KCk7XG4gICAgICAvLyBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2lzc3Vlcy8yMzNcbiAgICAgIGNvbnRlbnRTdHJpbmcgPSBjb250ZW50U3RyaW5nID8gY29udGVudFN0cmluZy50cmltKCkgOiBudWxsO1xuXG4gICAgICBwb3BvdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIC8vIHBvcG92ZXIgYXJyb3dcbiAgICAgIHZhciBwb3BvdmVyQXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvcG92ZXJBcnJvdy5jbGFzc0xpc3QuYWRkKCdhcnJvdycpO1xuICAgICAgcG9wb3Zlci5hcHBlbmRDaGlsZChwb3BvdmVyQXJyb3cpO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIHBvcG92ZXIgZnJvbSBkYXRhIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChjb250ZW50U3RyaW5nICE9PSBudWxsICYmIG9wcy50ZW1wbGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwb3BvdmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG5cbiAgICAgICAgaWYgKHRpdGxlU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBvcG92ZXJUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgICAgICAgcG9wb3ZlclRpdGxlLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItaGVhZGVyJyk7XG4gICAgICAgICAgcG9wb3ZlclRpdGxlLmlubmVySFRNTCA9IG9wcy5kaXNtaXNzaWJsZSA/IHRpdGxlU3RyaW5nICsgY2xvc2VCdG4gOiB0aXRsZVN0cmluZztcbiAgICAgICAgICBwb3BvdmVyLmFwcGVuZENoaWxkKHBvcG92ZXJUaXRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgcG9wb3ZlciBjb250ZW50XG4gICAgICAgIHZhciBwb3BvdmVyQm9keU1hcmt1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwb3BvdmVyQm9keU1hcmt1cC5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLWJvZHknKTtcbiAgICAgICAgcG9wb3ZlckJvZHlNYXJrdXAuaW5uZXJIVE1MID0gb3BzLmRpc21pc3NpYmxlICYmIHRpdGxlU3RyaW5nID09PSBudWxsXG4gICAgICAgICAgPyBjb250ZW50U3RyaW5nICsgY2xvc2VCdG5cbiAgICAgICAgICA6IGNvbnRlbnRTdHJpbmc7XG4gICAgICAgIHBvcG92ZXIuYXBwZW5kQ2hpbGQocG9wb3ZlckJvZHlNYXJrdXApO1xuICAgICAgfSBlbHNlIHsgLy8gb3IgY3JlYXRlIHRoZSBwb3BvdmVyIGZyb20gdGVtcGxhdGVcbiAgICAgICAgdmFyIHBvcG92ZXJUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwb3BvdmVyVGVtcGxhdGUuaW5uZXJIVE1MID0gb3BzLnRlbXBsYXRlLnRyaW0oKTtcbiAgICAgICAgcG9wb3Zlci5jbGFzc05hbWUgPSBwb3BvdmVyVGVtcGxhdGUuZmlyc3RDaGlsZC5jbGFzc05hbWU7XG4gICAgICAgIHBvcG92ZXIuaW5uZXJIVE1MID0gcG9wb3ZlclRlbXBsYXRlLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuXG4gICAgICAgIHZhciBwb3BvdmVySGVhZGVyID0gcXVlcnlFbGVtZW50KCcucG9wb3Zlci1oZWFkZXInLCBwb3BvdmVyKTtcbiAgICAgICAgdmFyIHBvcG92ZXJCb2R5ID0gcXVlcnlFbGVtZW50KCcucG9wb3Zlci1ib2R5JywgcG9wb3Zlcik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgdGVtcGxhdGUgd2l0aCBjb250ZW50IGZyb20gZGF0YSBhdHRyaWJ1dGVzXG4gICAgICAgIGlmICh0aXRsZVN0cmluZyAmJiBwb3BvdmVySGVhZGVyKSB7IHBvcG92ZXJIZWFkZXIuaW5uZXJIVE1MID0gdGl0bGVTdHJpbmcudHJpbSgpOyB9XG4gICAgICAgIGlmIChjb250ZW50U3RyaW5nICYmIHBvcG92ZXJCb2R5KSB7IHBvcG92ZXJCb2R5LmlubmVySFRNTCA9IGNvbnRlbnRTdHJpbmcudHJpbSgpOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGVuZCB0byB0aGUgY29udGFpbmVyXG4gICAgICBvcHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuICAgICAgcG9wb3Zlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIGlmICghcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcG92ZXInKSkgeyBwb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXInKTsgfVxuICAgICAgaWYgKCFwb3BvdmVyLmNsYXNzTGlzdC5jb250YWlucyhvcHMuYW5pbWF0aW9uKSkgeyBwb3BvdmVyLmNsYXNzTGlzdC5hZGQob3BzLmFuaW1hdGlvbik7IH1cbiAgICAgIGlmICghcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMocGxhY2VtZW50Q2xhc3MpKSB7IHBvcG92ZXIuY2xhc3NMaXN0LmFkZChwbGFjZW1lbnRDbGFzcyk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvd1BvcG92ZXIoKSB7XG4gICAgICBpZiAoIXBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHsgcG9wb3Zlci5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUG9wb3ZlcigpIHtcbiAgICAgIHN0eWxlVGlwKGVsZW1lbnQsIHBvcG92ZXIsIG9wcy5wbGFjZW1lbnQsIG9wcy5jb250YWluZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZUZvY3VzKCkge1xuICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHsgZWxlbWVudC5mb2N1cygpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhZGQpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlQ2xpY2tFdmVudHMuZG93biwgc2VsZi5zaG93KTtcbiAgICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlSG92ZXJFdmVudHNbMF0sIHNlbGYuc2hvdyk7XG4gICAgICAgIC8vIG1vdXNlSG92ZXIgPSAoJ29ubW91c2VsZWF2ZScgaW4gZG9jdW1lbnQpXG4gICAgICAgIC8vICAgPyBbICdtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnXVxuICAgICAgICAvLyAgIDogWyAnbW91c2VvdmVyJywgJ21vdXNlb3V0JyBdXG4gICAgICAgIGlmICghb3BzLmRpc21pc3NpYmxlKSB7IGVsZW1lbnRbYWN0aW9uXShtb3VzZUhvdmVyRXZlbnRzWzFdLCBzZWxmLmhpZGUpOyB9XG4gICAgICB9IGVsc2UgaWYgKG9wcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgIGVsZW1lbnRbYWN0aW9uXShvcHMudHJpZ2dlciwgc2VsZi50b2dnbGUpO1xuICAgICAgfSBlbHNlIGlmIChvcHMudHJpZ2dlciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICBpZiAoaXNJcGhvbmUpIHsgZWxlbWVudFthY3Rpb25dKCdjbGljaycsIGZvcmNlRm9jdXMsIGZhbHNlKTsgfVxuICAgICAgICBlbGVtZW50W2FjdGlvbl0ob3BzLnRyaWdnZXIsIHNlbGYudG9nZ2xlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG91Y2hIYW5kbGVyKGUpIHtcbiAgICAgIGlmICgocG9wb3ZlciAmJiBwb3BvdmVyLmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIDsgZWxzZSB7XG4gICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBldmVudCB0b2dnbGVcbiAgICBmdW5jdGlvbiBkaXNtaXNzSGFuZGxlclRvZ2dsZShhZGQpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgICBpZiAob3BzLmRpc21pc3NpYmxlKSB7XG4gICAgICAgIGRvY3VtZW50W2FjdGlvbl0oJ2NsaWNrJywgZGlzbWlzc2libGVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdmb2N1cycpIHsgZWxlbWVudFthY3Rpb25dKCdibHVyJywgc2VsZi5oaWRlKTsgfVxuICAgICAgICBpZiAob3BzLnRyaWdnZXIgPT09ICdob3ZlcicpIHsgZG9jdW1lbnRbYWN0aW9uXSgndG91Y2hzdGFydCcsIHRvdWNoSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpOyB9XG4gICAgICB9XG4gICAgICB3aW5kb3dbYWN0aW9uXSgncmVzaXplJywgc2VsZi5oaWRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHRyaWdnZXJzXG4gICAgZnVuY3Rpb24gc2hvd1RyaWdnZXIoKSB7XG4gICAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZSgxKTtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGlkZVRyaWdnZXIoKSB7XG4gICAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZSgpO1xuICAgICAgcmVtb3ZlUG9wb3ZlcigpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kcyAvIGhhbmRsZXJzXG4gICAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkgeyBzZWxmLnNob3coKTsgfVxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICBjcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgdXBkYXRlUG9wb3ZlcigpO1xuICAgICAgICAgIHNob3dQb3BvdmVyKCk7XG4gICAgICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3Zlciwgc2hvd1RyaWdnZXIpOyB9XG4gICAgICAgICAgZWxzZSB7IHNob3dUcmlnZ2VyKCk7IH1cbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH07XG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwb3BvdmVyICYmIHBvcG92ZXIgIT09IG51bGwgJiYgcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgICAgIGlmIChoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBwb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCBoaWRlVHJpZ2dlcik7IH1cbiAgICAgICAgICBlbHNlIHsgaGlkZVRyaWdnZXIoKTsgfVxuICAgICAgICB9XG4gICAgICB9LCBvcHMuZGVsYXkpO1xuICAgIH07XG4gICAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LlBvcG92ZXI7XG4gICAgfTtcblxuICAgIC8vIElOSVRcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5Qb3BvdmVyKSB7IGVsZW1lbnQuUG9wb3Zlci5kaXNwb3NlKCk7IH1cblxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIHRyaWdnZXJEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJpZ2dlcicpOyAvLyBjbGljayAvIGhvdmVyIC8gZm9jdXNcbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpOyAvLyB0cnVlIC8gZmFsc2VcblxuICAgIHZhciBwbGFjZW1lbnREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2VtZW50Jyk7XG4gICAgdmFyIGRpc21pc3NpYmxlRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc21pc3NpYmxlJyk7XG4gICAgdmFyIGRlbGF5RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5Jyk7XG4gICAgdmFyIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250YWluZXInKTtcblxuICAgIC8vIGNsb3NlIGJ0biBmb3IgZGlzc21pc3NpYmxlIHBvcG92ZXJcbiAgICBjbG9zZUJ0biA9ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCI+w5c8L2J1dHRvbj4nO1xuXG4gICAgLy8gY3VzdG9tIGV2ZW50c1xuICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ3BvcG92ZXInKTtcbiAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ3BvcG92ZXInKTtcbiAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICdwb3BvdmVyJyk7XG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ3BvcG92ZXInKTtcblxuICAgIC8vIGNoZWNrIGNvbnRhaW5lclxuICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gcXVlcnlFbGVtZW50KG9wdGlvbnMuY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSk7XG5cbiAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBtb2RhbFxuICAgIHZhciBtb2RhbCA9IGVsZW1lbnQuY2xvc2VzdCgnLm1vZGFsJyk7XG5cbiAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBmaXhlZCBuYXZiYXJcbiAgICB2YXIgbmF2YmFyRml4ZWRUb3AgPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC10b3AnKTtcbiAgICB2YXIgbmF2YmFyRml4ZWRCb3R0b20gPSBlbGVtZW50LmNsb3Nlc3QoJy5maXhlZC1ib3R0b20nKTtcblxuICAgIC8vIHNldCBpbnN0YW5jZSBvcHRpb25zXG4gICAgb3BzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGUgOiBudWxsOyAvLyBKYXZhU2NyaXB0IG9ubHlcbiAgICBvcHMudHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlciA/IG9wdGlvbnMudHJpZ2dlciA6IHRyaWdnZXJEYXRhIHx8ICdob3Zlcic7XG4gICAgb3BzLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSAnZmFkZScgPyBvcHRpb25zLmFuaW1hdGlvbiA6IGFuaW1hdGlvbkRhdGEgfHwgJ2ZhZGUnO1xuICAgIG9wcy5wbGFjZW1lbnQgPSBvcHRpb25zLnBsYWNlbWVudCA/IG9wdGlvbnMucGxhY2VtZW50IDogcGxhY2VtZW50RGF0YSB8fCAndG9wJztcbiAgICBvcHMuZGVsYXkgPSBwYXJzZUludCgob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpLCAxMCkgfHwgMjAwO1xuICAgIG9wcy5kaXNtaXNzaWJsZSA9ICEhKG9wdGlvbnMuZGlzbWlzc2libGUgfHwgZGlzbWlzc2libGVEYXRhID09PSAndHJ1ZScpO1xuICAgIG9wcy5jb250YWluZXIgPSBjb250YWluZXJFbGVtZW50XG4gICAgICB8fCAoY29udGFpbmVyRGF0YUVsZW1lbnRcbiAgICAgICAgfHwgKG5hdmJhckZpeGVkVG9wIHx8IChuYXZiYXJGaXhlZEJvdHRvbSB8fCAobW9kYWwgfHwgZG9jdW1lbnQuYm9keSkpKSk7XG5cbiAgICBwbGFjZW1lbnRDbGFzcyA9IFwiYnMtcG9wb3Zlci1cIiArIChvcHMucGxhY2VtZW50KTtcblxuICAgIC8vIGludmFsaWRhdGVcbiAgICB0aXRsZVN0cmluZyA9IGdldFRpdGxlKCk7XG4gICAgY29udGVudFN0cmluZyA9IGdldENvbnRlbnQoKTtcblxuICAgIGlmICghY29udGVudFN0cmluZyAmJiAhb3BzLnRlbXBsYXRlKSB7IHJldHVybjsgfVxuXG4gICAgLy8gaW5pdFxuICAgIGlmICghZWxlbWVudC5Qb3BvdmVyKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICB0b2dnbGVFdmVudHMoMSk7XG4gICAgfVxuXG4gICAgLy8gYXNzb2NpYXRlIHRhcmdldCB0byBpbml0IG9iamVjdFxuICAgIGVsZW1lbnQuUG9wb3ZlciA9IHNlbGY7XG4gIH1cblxuICAvKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDUgfCBTY3JvbGxTcHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLy8gU0NST0xMU1BZIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbSwgb3BzSW5wdXQpIHtcbiAgICB2YXIgZWxlbWVudDtcblxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBvcHNJbnB1dCB8fCB7fTtcblxuICAgIC8vIGJpbmRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBHQyBpbnRlcm5hbHNcbiAgICB2YXIgdmFycztcbiAgICB2YXIgbGlua3M7XG5cbiAgICAvLyB0YXJnZXRzXG4gICAgdmFyIHNweVRhcmdldDtcbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggaXMgdGhlIHJlYWwgc2Nyb2xsVGFyZ2V0XG4gICAgdmFyIHNjcm9sbFRhcmdldDtcbiAgICAvLyBvcHRpb25zXG4gICAgdmFyIG9wcyA9IHt9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgLy8gcG9wdWxhdGUgaXRlbXMgYW5kIHRhcmdldHNcbiAgICBmdW5jdGlvbiB1cGRhdGVUYXJnZXRzKCkge1xuICAgICAgbGlua3MgPSBzcHlUYXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0EnKTtcblxuICAgICAgdmFycy5zY3JvbGxUb3AgPSB2YXJzLmlzV2luZG93ID8gZ2V0U2Nyb2xsKCkueSA6IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAvLyBvbmx5IHVwZGF0ZSB2YXJzIG9uY2Ugb3Igd2l0aCBlYWNoIG11dGF0aW9uXG4gICAgICBpZiAodmFycy5sZW5ndGggIT09IGxpbmtzLmxlbmd0aCB8fCBnZXRTY3JvbGxIZWlnaHQoKSAhPT0gdmFycy5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGhyZWY7XG4gICAgICAgIHZhciB0YXJnZXRJdGVtO1xuICAgICAgICB2YXIgcmVjdDtcblxuICAgICAgICAvLyByZXNldCBhcnJheXMgJiB1cGRhdGVcbiAgICAgICAgdmFycy5pdGVtcyA9IFtdO1xuICAgICAgICB2YXJzLm9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFycy5zY3JvbGxIZWlnaHQgPSBnZXRTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgdmFycy5tYXhTY3JvbGwgPSB2YXJzLnNjcm9sbEhlaWdodCAtIGdldE9mZnNldEhlaWdodCgpO1xuXG4gICAgICAgIEFycmF5LmZyb20obGlua3MpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICB0YXJnZXRJdGVtID0gaHJlZiAmJiBocmVmLmNoYXJBdCgwKSA9PT0gJyMnICYmIGhyZWYuc2xpY2UoLTEpICE9PSAnIycgJiYgcXVlcnlFbGVtZW50KGhyZWYpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldEl0ZW0pIHtcbiAgICAgICAgICAgIHZhcnMuaXRlbXMucHVzaChsaW5rKTtcbiAgICAgICAgICAgIHJlY3QgPSB0YXJnZXRJdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFycy5vZmZzZXRzLnB1c2goKHZhcnMuaXNXaW5kb3dcbiAgICAgICAgICAgICAgPyByZWN0LnRvcCArIHZhcnMuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgIDogdGFyZ2V0SXRlbS5vZmZzZXRUb3ApIC0gb3BzLm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFycy5sZW5ndGggPSB2YXJzLml0ZW1zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaXRlbSB1cGRhdGVcbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgc2Nyb2xsVGFyZ2V0W2FjdGlvbl0oJ3Njcm9sbCcsIHNlbGYucmVmcmVzaCwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIHNlbGYucmVmcmVzaCwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsVGFyZ2V0LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE9mZnNldEhlaWdodCgpIHtcbiAgICAgIHJldHVybiAhdmFycy5pc1dpbmRvdyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIEFycmF5LmZyb20obGlua3MpLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICYmIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZShpbnB1dCkge1xuICAgICAgdmFyIGl0ZW0gPSBpbnB1dDtcbiAgICAgIHZhciBpdGVtQ2xhc3NMaXN0O1xuICAgICAgY2xlYXIoKTtcbiAgICAgIHZhcnMuYWN0aXZlSXRlbSA9IGl0ZW07XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuXG4gICAgICAvLyBhY3RpdmF0ZSBhbGwgcGFyZW50c1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICAgIHdoaWxlIChpdGVtLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgaXRlbUNsYXNzTGlzdCA9IGl0ZW0uY2xhc3NMaXN0O1xuXG4gICAgICAgIGlmIChpdGVtQ2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi1tZW51JykgfHwgaXRlbUNsYXNzTGlzdC5jb250YWlucygnbmF2JykpIHsgcGFyZW50cy5wdXNoKGl0ZW0pOyB9XG4gICAgICB9XG5cbiAgICAgIHBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVudUl0ZW0pIHtcbiAgICAgICAgdmFyIHBhcmVudExpbmsgPSBtZW51SXRlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXG4gICAgICAgIGlmIChwYXJlbnRMaW5rICYmICFwYXJlbnRMaW5rLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICBwYXJlbnRMaW5rLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdhY3RpdmF0ZScsICdzY3JvbGxzcHknLCB7IHJlbGF0ZWRUYXJnZXQ6IHZhcnMuYWN0aXZlSXRlbSB9KSk7XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZVRhcmdldHMoKTtcblxuICAgICAgaWYgKHZhcnMuc2Nyb2xsVG9wID49IHZhcnMubWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciBuZXdBY3RpdmVJdGVtID0gdmFycy5pdGVtc1t2YXJzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICh2YXJzLmFjdGl2ZUl0ZW0gIT09IG5ld0FjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICBhY3RpdmF0ZShuZXdBY3RpdmVJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcnMuYWN0aXZlSXRlbSAmJiB2YXJzLnNjcm9sbFRvcCA8IHZhcnMub2Zmc2V0c1swXSAmJiB2YXJzLm9mZnNldHNbMF0gPiAwKSB7XG4gICAgICAgIHZhcnMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSB2YXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpID4gLTEpIHtcbiAgICAgICAgaWYgKHZhcnMuYWN0aXZlSXRlbSAhPT0gdmFycy5pdGVtc1tpXSAmJiB2YXJzLnNjcm9sbFRvcCA+PSB2YXJzLm9mZnNldHNbaV1cbiAgICAgICAgICAmJiAodHlwZW9mIHZhcnMub2Zmc2V0c1tpICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHZhcnMuc2Nyb2xsVG9wIDwgdmFycy5vZmZzZXRzW2kgKyAxXSkpIHtcbiAgICAgICAgICBhY3RpdmF0ZSh2YXJzLml0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpIC09IDE7XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LlNjcm9sbFNweTtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnQsIHRoZSBlbGVtZW50IHdlIHNweSBvblxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbSk7XG5cbiAgICAvLyByZXNldCBvbiByZS1pbml0XG4gICAgaWYgKGVsZW1lbnQuU2Nyb2xsU3B5KSB7IGVsZW1lbnQuU2Nyb2xsU3B5LmRpc3Bvc2UoKTsgfVxuXG4gICAgLy8gZXZlbnQgdGFyZ2V0cywgY29uc3RhbnRzXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpO1xuICAgIHZhciBvZmZzZXREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2Zmc2V0Jyk7XG5cbiAgICAvLyB0YXJnZXRzXG4gICAgc3B5VGFyZ2V0ID0gcXVlcnlFbGVtZW50KG9wdGlvbnMudGFyZ2V0IHx8IHRhcmdldERhdGEpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSByZWFsIHNjcm9sbFRhcmdldFxuICAgIHNjcm9sbFRhcmdldCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgPyBlbGVtZW50IDogd2luZG93O1xuXG4gICAgaWYgKCFzcHlUYXJnZXQpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uXG4gICAgb3BzLm9mZnNldCA9ICsob3B0aW9ucy5vZmZzZXQgfHwgb2Zmc2V0RGF0YSkgfHwgMTA7XG5cbiAgICAvLyBzZXQgaW5zdGFuY2UgcHJpb3JpdHkgdmFyaWFibGVzXG4gICAgdmFycyA9IHt9O1xuICAgIHZhcnMubGVuZ3RoID0gMDtcbiAgICB2YXJzLml0ZW1zID0gW107XG4gICAgdmFycy5vZmZzZXRzID0gW107XG4gICAgdmFycy5pc1dpbmRvdyA9IHNjcm9sbFRhcmdldCA9PT0gd2luZG93O1xuICAgIHZhcnMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgdmFycy5zY3JvbGxIZWlnaHQgPSAwO1xuICAgIHZhcnMubWF4U2Nyb2xsID0gMDtcblxuICAgIC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgaWYgKCFlbGVtZW50LlNjcm9sbFNweSkgeyB0b2dnbGVFdmVudHMoMSk7IH1cblxuICAgIHNlbGYucmVmcmVzaCgpO1xuXG4gICAgLy8gYXNzb2NpYXRlIHRhcmdldCB3aXRoIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5TY3JvbGxTcHkgPSBzZWxmO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVGFiXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8vIFRBQiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gVGFiKGVsZW0sIG9wc0lucHV0KSB7XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IG9wc0lucHV0IHx8IHt9O1xuXG4gICAgLy8gYmluZFxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGV2ZW50IHRhcmdldHNcbiAgICB2YXIgdGFicztcbiAgICB2YXIgZHJvcGRvd247XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcblxuICAgIC8vIG1vcmUgR0MgbWF0ZXJpYWxcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgdGFic0NvbnRlbnRDb250YWluZXIgPSBmYWxzZTtcbiAgICB2YXIgYWN0aXZlVGFiO1xuICAgIHZhciBhY3RpdmVDb250ZW50O1xuICAgIHZhciBuZXh0Q29udGVudDtcbiAgICB2YXIgY29udGFpbmVySGVpZ2h0O1xuICAgIHZhciBlcXVhbENvbnRlbnRzO1xuICAgIHZhciBuZXh0SGVpZ2h0O1xuXG4gICAgLy8gdHJpZ2dlcnNcbiAgICBmdW5jdGlvbiB0cmlnZ2VyRW5kKCkge1xuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICB0YWJzQ29udGVudENvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgICB0YWJzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaWdnZXJTaG93KCkge1xuICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgaWYgKGVxdWFsQ29udGVudHMpIHtcbiAgICAgICAgICB0cmlnZ2VyRW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IC8vIGVuYWJsZXMgaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gbmV4dEhlaWdodCArIFwicHhcIjsgLy8gaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICAgICAgcmVmbG93KHRhYnNDb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRhYnNDb250ZW50Q29udGFpbmVyLCB0cmlnZ2VyRW5kKTtcbiAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYnMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBhY3RpdmVUYWIgfSk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd25DdXN0b21FdmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaWdnZXJIaWRlKCkge1xuICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7XG4gICAgICAgIGFjdGl2ZUNvbnRlbnQuc3R5bGUuZmxvYXQgPSAnbGVmdCc7XG4gICAgICAgIG5leHRDb250ZW50LnN0eWxlLmZsb2F0ID0gJ2xlZnQnO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBhY3RpdmVDb250ZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBhY3RpdmVUYWIgfSk7XG4gICAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndGFiJywgeyByZWxhdGVkVGFyZ2V0OiBuZXh0IH0pO1xuXG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cblxuICAgICAgbmV4dENvbnRlbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICAgIGFjdGl2ZUNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICBuZXh0SGVpZ2h0ID0gbmV4dENvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBlcXVhbENvbnRlbnRzID0gbmV4dEhlaWdodCA9PT0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzaW5nJyk7XG4gICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lckhlaWdodCArIFwicHhcIjsgLy8gaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICByZWZsb3codGFic0NvbnRlbnRDb250YWluZXIpO1xuICAgICAgICBhY3RpdmVDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgICAgIG5leHRDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q29udGVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBuZXh0Q29udGVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQobmV4dENvbnRlbnQsIHRyaWdnZXJTaG93KTtcbiAgICAgICAgfSwgMjApO1xuICAgICAgfSBlbHNlIHsgdHJpZ2dlclNob3coKTsgfVxuXG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWN0aXZlVGFiLCBoaWRkZW5DdXN0b21FdmVudCk7XG4gICAgfVxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGdldEFjdGl2ZVRhYigpIHtcbiAgICAgIHZhciBhc3NpZ247XG5cbiAgICAgIHZhciBhY3RpdmVUYWJzID0gdGFicy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKTtcblxuICAgICAgaWYgKGFjdGl2ZVRhYnMubGVuZ3RoID09PSAxICYmICFhY3RpdmVUYWJzWzBdLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bicpKSB7XG4gICAgICAgIChhc3NpZ24gPSBhY3RpdmVUYWJzLCBhY3RpdmVUYWIgPSBhc3NpZ25bMF0pO1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmVUYWJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYWN0aXZlVGFiID0gYWN0aXZlVGFic1thY3RpdmVUYWJzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGl2ZVRhYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGVudCgpIHsgcmV0dXJuIHF1ZXJ5RWxlbWVudChnZXRBY3RpdmVUYWIoKS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7IH1cbiAgICAvLyBoYW5kbGVyXG4gICAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG5leHQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICBpZiAoIXRhYnMuaXNBbmltYXRpbmcpIHsgc2VsZi5zaG93KCk7IH1cbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkgeyAvLyB0aGUgdGFiIHdlIGNsaWNrZWQgaXMgbm93IHRoZSBuZXh0IHRhYlxuICAgICAgbmV4dCA9IG5leHQgfHwgZWxlbWVudDtcblxuICAgICAgaWYgKCFuZXh0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgbmV4dENvbnRlbnQgPSBxdWVyeUVsZW1lbnQobmV4dC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7IC8vIHRoaXMgaXMgdGhlIGFjdHVhbCBvYmplY3QsIHRoZSBuZXh0IHRhYiBjb250ZW50IHRvIGFjdGl2YXRlXG4gICAgICAgIGFjdGl2ZVRhYiA9IGdldEFjdGl2ZVRhYigpO1xuICAgICAgICBhY3RpdmVDb250ZW50ID0gZ2V0QWN0aXZlQ29udGVudCgpO1xuXG4gICAgICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3RhYicsIHsgcmVsYXRlZFRhcmdldDogbmV4dCB9KTtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGFjdGl2ZVRhYiwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgaWYgKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRhYnMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICBhY3RpdmVUYWIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIGFjdGl2ZVRhYi5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgbmV4dC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgbmV4dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuXG4gICAgICAgIGlmIChkcm9wZG93bikge1xuICAgICAgICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24tbWVudScpKSB7XG4gICAgICAgICAgICBpZiAoZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgeyBkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHsgZHJvcGRvd24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3RpdmVDb250ZW50LmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpKSB7XG4gICAgICAgICAgYWN0aXZlQ29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoYWN0aXZlQ29udGVudCwgdHJpZ2dlckhpZGUpO1xuICAgICAgICB9IGVsc2UgeyB0cmlnZ2VySGlkZSgpOyB9XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkZWxldGUgZWxlbWVudC5UYWI7XG4gICAgfTtcblxuICAgIC8vIElOSVRcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtKTtcblxuICAgIC8vIHJlc2V0IG9uIHJlLWluaXRcbiAgICBpZiAoZWxlbWVudC5UYWIpIHsgZWxlbWVudC5UYWIuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBoZWlnaHREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGVpZ2h0Jyk7XG4gICAgLy8gZXZlbnQgdGFyZ2V0c1xuICAgIHRhYnMgPSBlbGVtZW50LmNsb3Nlc3QoJy5uYXYnKTtcbiAgICBkcm9wZG93biA9IHRhYnMgJiYgcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tdG9nZ2xlJywgdGFicyk7XG5cbiAgICAvLyBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGFuaW1hdGVIZWlnaHQgPSAhKCFzdXBwb3J0VHJhbnNpdGlvbiB8fCAob3B0aW9ucy5oZWlnaHQgPT09IGZhbHNlIHx8IGhlaWdodERhdGEgPT09ICdmYWxzZScpKTtcblxuICAgIC8vIHNldCBkZWZhdWx0IGFuaW1hdGlvbiBzdGF0ZVxuICAgIHRhYnMuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgIC8vIGluaXRcbiAgICBpZiAoIWVsZW1lbnQuVGFiKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGVIZWlnaHQpIHsgdGFic0NvbnRlbnRDb250YWluZXIgPSBnZXRBY3RpdmVDb250ZW50KCkucGFyZW50Tm9kZTsgfVxuXG4gICAgLy8gYXNzb2NpYXRlIHRhcmdldCB3aXRoIGluaXQgb2JqZWN0XG4gICAgZWxlbWVudC5UYWIgPSBzZWxmO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVG9hc3RcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvLyBUT0FTVCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFRvYXN0KGVsZW0sIG9wc0lucHV0KSB7XG4gICAgdmFyIGVsZW1lbnQ7XG5cbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIHZhciBvcHRpb25zID0gb3BzSW5wdXQgfHwge307XG5cbiAgICAvLyBiaW5kXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gdG9hc3QsIHRpbWVyXG4gICAgdmFyIHRvYXN0O1xuICAgIHZhciB0aW1lciA9IDA7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBzaG93bkN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcbiAgICB2YXIgb3BzID0ge307XG5cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBzaG93Q29tcGxldGUoKSB7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93aW5nJyk7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKG9wcy5hdXRvaGlkZSkgeyBzZWxmLmhpZGUoKTsgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlQ29tcGxldGUoKSB7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIGhpZGRlbkN1c3RvbUV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgaGlkZUNvbXBsZXRlKTsgfVxuICAgICAgZWxzZSB7IGhpZGVDb21wbGV0ZSgpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3Bvc2VDb21wbGV0ZSgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5oaWRlLCBmYWxzZSk7XG5cbiAgICAgIGRlbGV0ZSBlbGVtZW50LlRvYXN0O1xuICAgIH1cblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRvYXN0ICYmICF0b2FzdC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIHNob3dDdXN0b21FdmVudCk7XG4gICAgICAgIGlmIChzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgdG9hc3QuY2xhc3NMaXN0LmFkZCgnZmFkZScpOyB9XG4gICAgICAgIHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcbiAgICAgICAgcmVmbG93KHRvYXN0KTsgLy8gZm9yY2UgcmVmbG93XG4gICAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoJ3Nob3dpbmcnKTtcblxuICAgICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgc2hvd0NvbXBsZXRlKTsgfVxuICAgICAgICBlbHNlIHsgc2hvd0NvbXBsZXRlKCk7IH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uIChub1RpbWVyKSB7XG4gICAgICBpZiAodG9hc3QgJiYgdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKG5vVGltZXIpIHsgY2xvc2UoKTsgfVxuICAgICAgICBlbHNlIHsgdGltZXIgPSBzZXRUaW1lb3V0KGNsb3NlLCBvcHMuZGVsYXkpOyB9XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgZGlzcG9zZUNvbXBsZXRlKTsgfVxuICAgICAgZWxzZSB7IGRpc3Bvc2VDb21wbGV0ZSgpOyB9XG4gICAgfTtcblxuICAgIC8vIGluaXRcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW0pO1xuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50LlRvYXN0KSB7IGVsZW1lbnQuVG9hc3QuZGlzcG9zZSgpOyB9XG5cbiAgICAvLyB0b2FzdCwgdGltZXJcbiAgICB0b2FzdCA9IGVsZW1lbnQuY2xvc2VzdCgnLnRvYXN0Jyk7XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBhbmltYXRpb25EYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gICAgdmFyIGF1dG9oaWRlRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWF1dG9oaWRlJyk7XG4gICAgdmFyIGRlbGF5RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5Jyk7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndG9hc3QnKTtcbiAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICd0b2FzdCcpO1xuICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndG9hc3QnKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndG9hc3QnKTtcblxuICAgIC8vIHNldCBpbnN0YW5jZSBvcHRpb25zXG4gICAgb3BzLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uID09PSBmYWxzZSB8fCBhbmltYXRpb25EYXRhID09PSAnZmFsc2UnID8gMCA6IDE7IC8vIHRydWUgYnkgZGVmYXVsdFxuICAgIG9wcy5hdXRvaGlkZSA9IG9wdGlvbnMuYXV0b2hpZGUgPT09IGZhbHNlIHx8IGF1dG9oaWRlRGF0YSA9PT0gJ2ZhbHNlJyA/IDAgOiAxOyAvLyB0cnVlIGJ5IGRlZmF1bHRcbiAgICBvcHMuZGVsYXkgPSBwYXJzZUludCgob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpLCAxMCkgfHwgNTAwOyAvLyA1MDBtcyBkZWZhdWx0XG5cbiAgICBpZiAoIWVsZW1lbnQuVG9hc3QpIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLmhpZGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhc3NvY2lhdGUgdGFyZ2V0cyB0byBpbml0IG9iamVjdFxuICAgIGVsZW1lbnQuVG9hc3QgPSBzZWxmO1xuICB9XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVG9vbHRpcFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLy8gVE9PTFRJUCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFRvb2x0aXAoZWxlbSwgb3BzSW5wdXQpIHtcbiAgICB2YXIgZWxlbWVudDtcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIHZhciBvcHRpb25zID0gb3BzSW5wdXQgfHwge307XG5cbiAgICAvLyBiaW5kXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gdG9vbHRpcCwgdGltZXIsIGFuZCB0aXRsZVxuICAgIHZhciB0b29sdGlwID0gbnVsbDtcbiAgICB2YXIgdGltZXIgPSAwO1xuICAgIHZhciB0aXRsZVN0cmluZztcbiAgICB2YXIgcGxhY2VtZW50Q2xhc3M7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgdmFyIHNob3dDdXN0b21FdmVudDtcbiAgICB2YXIgc2hvd25DdXN0b21FdmVudDtcbiAgICB2YXIgaGlkZUN1c3RvbUV2ZW50O1xuICAgIHZhciBoaWRkZW5DdXN0b21FdmVudDtcblxuICAgIHZhciBvcHMgPSB7fTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpXG4gICAgICAgICAgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnKVxuICAgICAgICAgIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2xUaXAoKSB7XG4gICAgICBvcHMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRvb2x0aXApO1xuICAgICAgdG9vbHRpcCA9IG51bGw7IHRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVG9vbFRpcCgpIHtcbiAgICAgIHRpdGxlU3RyaW5nID0gZ2V0VGl0bGUoKTsgLy8gcmVhZCB0aGUgdGl0bGUgYWdhaW5cbiAgICAgIGlmICh0aXRsZVN0cmluZykgeyAvLyBpbnZhbGlkYXRlLCBtYXliZSBtYXJrdXAgY2hhbmdlZFxuICAgICAgICAvLyBjcmVhdGUgdG9vbHRpcFxuICAgICAgICB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gc2V0IG1hcmt1cFxuICAgICAgICBpZiAob3BzLnRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIHRvb2x0aXBNYXJrdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0b29sdGlwTWFya3VwLmlubmVySFRNTCA9IG9wcy50ZW1wbGF0ZS50cmltKCk7XG5cbiAgICAgICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IHRvb2x0aXBNYXJrdXAuZmlyc3RDaGlsZC5jbGFzc05hbWU7XG4gICAgICAgICAgdG9vbHRpcC5pbm5lckhUTUwgPSB0b29sdGlwTWFya3VwLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuXG4gICAgICAgICAgcXVlcnlFbGVtZW50KCcudG9vbHRpcC1pbm5lcicsIHRvb2x0aXApLmlubmVySFRNTCA9IHRpdGxlU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0b29sdGlwIGFycm93XG4gICAgICAgICAgdmFyIHRvb2x0aXBBcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRvb2x0aXBBcnJvdy5jbGFzc0xpc3QuYWRkKCdhcnJvdycpO1xuICAgICAgICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQodG9vbHRpcEFycm93KTtcbiAgICAgICAgICAvLyB0b29sdGlwIGlubmVyXG4gICAgICAgICAgdmFyIHRvb2x0aXBJbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRvb2x0aXBJbm5lci5jbGFzc0xpc3QuYWRkKCd0b29sdGlwLWlubmVyJyk7XG4gICAgICAgICAgdG9vbHRpcC5hcHBlbmRDaGlsZCh0b29sdGlwSW5uZXIpO1xuICAgICAgICAgIHRvb2x0aXBJbm5lci5pbm5lckhUTUwgPSB0aXRsZVN0cmluZztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCBwb3NpdGlvblxuICAgICAgICB0b29sdGlwLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIHRvb2x0aXAuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICAvLyBzZXQgY2xhc3MgYW5kIHJvbGUgYXR0cmlidXRlXG4gICAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcbiAgICAgICAgaWYgKCF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygndG9vbHRpcCcpKSB7IHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgndG9vbHRpcCcpOyB9XG4gICAgICAgIGlmICghdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMob3BzLmFuaW1hdGlvbikpIHsgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKG9wcy5hbmltYXRpb24pOyB9XG4gICAgICAgIGlmICghdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMocGxhY2VtZW50Q2xhc3MpKSB7IHRvb2x0aXAuY2xhc3NMaXN0LmFkZChwbGFjZW1lbnRDbGFzcyk7IH1cbiAgICAgICAgLy8gYXBwZW5kIHRvIGNvbnRhaW5lclxuICAgICAgICBvcHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUb29sdGlwKCkge1xuICAgICAgc3R5bGVUaXAoZWxlbWVudCwgdG9vbHRpcCwgb3BzLnBsYWNlbWVudCwgb3BzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgICAgaWYgKCF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7IHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnc2hvdycpOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvdWNoSGFuZGxlcihlKSB7XG4gICAgICBpZiAoKHRvb2x0aXAgJiYgdG9vbHRpcC5jb250YWlucyhlLnRhcmdldCkpXG4gICAgICAgIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSA7IGVsc2Uge1xuICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdHJpZ2dlcnNcbiAgICBmdW5jdGlvbiB0b2dnbGVBY3Rpb24oYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZG9jdW1lbnRbYWN0aW9uXSgndG91Y2hzdGFydCcsIHRvdWNoSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIHNlbGYuaGlkZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG93QWN0aW9uKCkge1xuICAgICAgdG9nZ2xlQWN0aW9uKDEpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoaWRlQWN0aW9uKCkge1xuICAgICAgdG9nZ2xlQWN0aW9uKCk7XG4gICAgICByZW1vdmVUb29sVGlwKCk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWRkKSB7XG4gICAgICB2YXIgYWN0aW9uID0gYWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgICAgZWxlbWVudFthY3Rpb25dKG1vdXNlQ2xpY2tFdmVudHMuZG93biwgc2VsZi5zaG93LCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0obW91c2VIb3ZlckV2ZW50c1swXSwgc2VsZi5zaG93LCBmYWxzZSk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0obW91c2VIb3ZlckV2ZW50c1sxXSwgc2VsZi5oaWRlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgLy8gaWYoY3JlYXRlVG9vbFRpcCgpID09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgaWYgKGNyZWF0ZVRvb2xUaXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgICAgICBpZiAob3BzLmFuaW1hdGlvbikgeyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBzaG93QWN0aW9uKTsgfVxuICAgICAgICAgICAgZWxzZSB7IHNob3dBY3Rpb24oKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH07XG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgICBpZiAoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICAgaWYgKG9wcy5hbmltYXRpb24pIHsgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgaGlkZUFjdGlvbik7IH1cbiAgICAgICAgICBlbHNlIHsgaGlkZUFjdGlvbigpOyB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9wcy5kZWxheSk7XG4gICAgfTtcbiAgICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdG9vbHRpcCkgeyBzZWxmLnNob3coKTsgfVxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0b2dnbGVFdmVudHMoKTtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKSk7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuVG9vbHRpcDtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW0pO1xuXG4gICAgLy8gcmVzZXQgb24gcmUtaW5pdFxuICAgIGlmIChlbGVtZW50LlRvb2x0aXApIHsgZWxlbWVudC5Ub29sdGlwLmRpc3Bvc2UoKTsgfVxuXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICAgIHZhciBwbGFjZW1lbnREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2VtZW50Jyk7XG4gICAgdmFyIGRlbGF5RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5Jyk7XG4gICAgdmFyIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250YWluZXInKTtcblxuICAgIC8vIGNoZWNrIGNvbnRhaW5lclxuICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gcXVlcnlFbGVtZW50KG9wdGlvbnMuY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSk7XG5cbiAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBtb2RhbFxuICAgIHZhciBtb2RhbCA9IGVsZW1lbnQuY2xvc2VzdCgnLm1vZGFsJyk7XG5cbiAgICAvLyBjdXN0b20gZXZlbnRzXG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAndG9vbHRpcCcpO1xuICAgIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndG9vbHRpcCcpO1xuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3Rvb2x0aXAnKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAndG9vbHRpcCcpO1xuXG4gICAgLy8gbWF5YmUgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIGEgZml4ZWQgbmF2YmFyXG4gICAgdmFyIG5hdmJhckZpeGVkVG9wID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtdG9wJyk7XG4gICAgdmFyIG5hdmJhckZpeGVkQm90dG9tID0gZWxlbWVudC5jbG9zZXN0KCcuZml4ZWQtYm90dG9tJyk7XG5cbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIG9wcy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gJ2ZhZGUnID8gb3B0aW9ucy5hbmltYXRpb24gOiBhbmltYXRpb25EYXRhIHx8ICdmYWRlJztcbiAgICBvcHMucGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQgPyBvcHRpb25zLnBsYWNlbWVudCA6IHBsYWNlbWVudERhdGEgfHwgJ3RvcCc7XG4gICAgb3BzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGUgOiBudWxsOyAvLyBKYXZhU2NyaXB0IG9ubHlcbiAgICBvcHMuZGVsYXkgPSBwYXJzZUludCgob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpLCAxMCkgfHwgMjAwO1xuICAgIG9wcy5jb250YWluZXIgPSBjb250YWluZXJFbGVtZW50XG4gICAgICB8fCAoY29udGFpbmVyRGF0YUVsZW1lbnRcbiAgICAgICAgfHwgKG5hdmJhckZpeGVkVG9wIHx8IChuYXZiYXJGaXhlZEJvdHRvbSB8fCAobW9kYWwgfHwgZG9jdW1lbnQuYm9keSkpKSk7XG5cbiAgICAvLyBzZXQgcGxhY2VtZW50IGNsYXNzXG4gICAgcGxhY2VtZW50Q2xhc3MgPSBcImJzLXRvb2x0aXAtXCIgKyAob3BzLnBsYWNlbWVudCk7XG5cbiAgICAvLyBzZXQgdG9vbHRpcCBjb250ZW50XG4gICAgdGl0bGVTdHJpbmcgPSBnZXRUaXRsZSgpO1xuXG4gICAgLy8gaW52YWxpZGF0ZVxuICAgIGlmICghdGl0bGVTdHJpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgIGlmICghZWxlbWVudC5Ub29sdGlwKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsIHRpdGxlU3RyaW5nKTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgdG9nZ2xlRXZlbnRzKDEpO1xuICAgIH1cblxuICAgIC8vIGFzc29jaWF0ZSB0YXJnZXQgdG8gaW5pdCBvYmplY3RcbiAgICBlbGVtZW50LlRvb2x0aXAgPSBzZWxmO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudHNJbml0ID0ge307XG5cbiAgLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCB8IEluaXRpYWxpemUgRGF0YSBBUElcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGFBUEkoQ29uc3RydWN0b3IsIGNvbGxlY3Rpb24pIHtcbiAgICBBcnJheS5mcm9tKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHgpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiBpbml0Q2FsbGJhY2soY29udGV4dCkge1xuICAgIHZhciBsb29rVXAgPSBjb250ZXh0IGluc3RhbmNlb2YgRWxlbWVudCA/IGNvbnRleHQgOiBkb2N1bWVudDtcbiAgICBPYmplY3Qua2V5cyhjb21wb25lbnRzSW5pdCkuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICBpbml0aWFsaXplRGF0YUFQSShjb21wb25lbnRzSW5pdFtjb21wb25lbnRdWzBdLFxuICAgICAgICBsb29rVXAucXVlcnlTZWxlY3RvckFsbChjb21wb25lbnRzSW5pdFtjb21wb25lbnRdWzFdKSk7XG4gICAgfSk7XG4gIH1cblxuICBjb21wb25lbnRzSW5pdC5BbGVydCA9IFtBbGVydCwgJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXSddO1xuICBjb21wb25lbnRzSW5pdC5CdXR0b24gPSBbQnV0dG9uLCAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXSddO1xuICBjb21wb25lbnRzSW5pdC5DYXJvdXNlbCA9IFtDYXJvdXNlbCwgJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXSddO1xuICBjb21wb25lbnRzSW5pdC5Db2xsYXBzZSA9IFtDb2xsYXBzZSwgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJ107XG4gIGNvbXBvbmVudHNJbml0LkRyb3Bkb3duID0gW0Ryb3Bkb3duLCAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nXTtcbiAgY29tcG9uZW50c0luaXQuTW9kYWwgPSBbTW9kYWwsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXSddO1xuICBjb21wb25lbnRzSW5pdC5Qb3BvdmVyID0gW1BvcG92ZXIsICdbZGF0YS10b2dnbGU9XCJwb3BvdmVyXCJdLFtkYXRhLXRpcD1cInBvcG92ZXJcIl0nXTtcbiAgY29tcG9uZW50c0luaXQuU2Nyb2xsU3B5ID0gW1Njcm9sbFNweSwgJ1tkYXRhLXNweT1cInNjcm9sbFwiXSddO1xuICBjb21wb25lbnRzSW5pdC5UYWIgPSBbVGFiLCAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJ107XG4gIGNvbXBvbmVudHNJbml0LlRvYXN0ID0gW1RvYXN0LCAnW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJ107XG4gIGNvbXBvbmVudHNJbml0LlRvb2x0aXAgPSBbVG9vbHRpcCwgJ1tkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIl0sW2RhdGEtdGlwPVwidG9vbHRpcFwiXSddO1xuXG4gIC8vIGJ1bGsgaW5pdGlhbGl6ZSBhbGwgY29tcG9uZW50c1xuICBpZiAoZG9jdW1lbnQuYm9keSkgeyBpbml0Q2FsbGJhY2soKTsgfVxuICBlbHNlIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gaW5pdFdyYXBwZXIoKSB7XG4gICAgICBpbml0Q2FsbGJhY2soKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBpbml0V3JhcHBlciwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgfCBSZW1vdmUgRGF0YSBBUElcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50RGF0YUFQSShDb25zdHJ1Y3Rvck5hbWUsIGNvbGxlY3Rpb24pIHtcbiAgICBBcnJheS5mcm9tKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geFtDb25zdHJ1Y3Rvck5hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlRGF0YUFQSShjb250ZXh0KSB7XG4gICAgdmFyIGxvb2tVcCA9IGNvbnRleHQgaW5zdGFuY2VvZiBFbGVtZW50ID8gY29udGV4dCA6IGRvY3VtZW50O1xuICAgIE9iamVjdC5rZXlzKGNvbXBvbmVudHNJbml0KS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJlbW92ZUVsZW1lbnREYXRhQVBJKGNvbXBvbmVudCwgbG9va1VwLnF1ZXJ5U2VsZWN0b3JBbGwoY29tcG9uZW50c0luaXRbY29tcG9uZW50XVsxXSkpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBcIjQuMC42XCI7XG5cbiAgdmFyIGluZGV4VjQgPSB7XG4gICAgQWxlcnQ6IEFsZXJ0LFxuICAgIEJ1dHRvbjogQnV0dG9uLFxuICAgIENhcm91c2VsOiBDYXJvdXNlbCxcbiAgICBDb2xsYXBzZTogQ29sbGFwc2UsXG4gICAgRHJvcGRvd246IERyb3Bkb3duLFxuICAgIE1vZGFsOiBNb2RhbCxcbiAgICBQb3BvdmVyOiBQb3BvdmVyLFxuICAgIFNjcm9sbFNweTogU2Nyb2xsU3B5LFxuICAgIFRhYjogVGFiLFxuICAgIFRvYXN0OiBUb2FzdCxcbiAgICBUb29sdGlwOiBUb29sdGlwLFxuXG4gICAgaW5pdENhbGxiYWNrOiBpbml0Q2FsbGJhY2ssXG4gICAgcmVtb3ZlRGF0YUFQSTogcmVtb3ZlRGF0YUFQSSxcbiAgICBjb21wb25lbnRzSW5pdDogY29tcG9uZW50c0luaXQsXG4gICAgVmVyc2lvbjogdmVyc2lvbixcbiAgfTtcblxuICByZXR1cm4gaW5kZXhWNDtcblxufSkpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\n");

/***/ }),

/***/ "./node_modules/htmx.org/dist/htmx.min.js":
/*!************************************************!*\
  !*** ./node_modules/htmx.org/dist/htmx.min.js ***!
  \************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(e,t){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else{}})(typeof self!==\"undefined\"?self:this,function(){return function(){\"use strict\";var D={onLoad:t,process:rt,on:N,off:I,trigger:lt,ajax:$t,find:w,findAll:S,closest:O,values:function(e,t){var r=Ot(e,t||\"post\");return r.values},remove:E,addClass:C,removeClass:R,toggleClass:q,takeClass:L,defineExtension:Qt,removeExtension:er,logAll:b,logger:null,config:{historyEnabled:true,historyCacheSize:10,refreshOnHistoryMiss:false,defaultSwapStyle:\"innerHTML\",defaultSwapDelay:0,defaultSettleDelay:20,includeIndicatorStyles:true,indicatorClass:\"htmx-indicator\",requestClass:\"htmx-request\",addedClass:\"htmx-added\",settlingClass:\"htmx-settling\",swappingClass:\"htmx-swapping\",allowEval:true,attributesToSettle:[\"class\",\"style\",\"width\",\"height\"],withCredentials:false,timeout:0,wsReconnectDelay:\"full-jitter\",disableSelector:\"[hx-disable], [data-hx-disable]\",useTemplateFragments:false,scrollBehavior:\"smooth\"},parseInterval:h,_:e,createEventSource:function(e){return new EventSource(e,{withCredentials:true})},createWebSocket:function(e){return new WebSocket(e,[])},version:\"1.6.0\"};var r=[\"get\",\"post\",\"put\",\"delete\",\"patch\"];var n=r.map(function(e){return\"[hx-\"+e+\"], [data-hx-\"+e+\"]\"}).join(\", \");function h(e){if(e==undefined){return undefined}if(e.slice(-2)==\"ms\"){return parseFloat(e.slice(0,-2))||undefined}if(e.slice(-1)==\"s\"){return parseFloat(e.slice(0,-1))*1e3||undefined}return parseFloat(e)||undefined}function c(e,t){return e.getAttribute&&e.getAttribute(t)}function s(e,t){return e.hasAttribute&&(e.hasAttribute(t)||e.hasAttribute(\"data-\"+t))}function F(e,t){return c(e,t)||c(e,\"data-\"+t)}function l(e){return e.parentElement}function P(){return document}function d(e,t){if(t(e)){return e}else if(l(e)){return d(l(e),t)}else{return null}}function X(e,t){var r=null;d(e,function(e){return r=F(e,t)});if(r!==\"unset\"){return r}}function v(e,t){var r=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.webkitMatchesSelector||e.oMatchesSelector;return r&&r.call(e,t)}function i(e){var t=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;var r=t.exec(e);if(r){return r[1].toLowerCase()}else{return\"\"}}function o(e,t){var r=new DOMParser;var n=r.parseFromString(e,\"text/html\");var i=n.body;while(t>0){t--;i=i.firstChild}if(i==null){i=P().createDocumentFragment()}return i}function u(e){if(D.config.useTemplateFragments){var t=o(\"<body><template>\"+e+\"</template></body>\",0);return t.querySelector(\"template\").content}else{var r=i(e);switch(r){case\"thead\":case\"tbody\":case\"tfoot\":case\"colgroup\":case\"caption\":return o(\"<table>\"+e+\"</table>\",1);case\"col\":return o(\"<table><colgroup>\"+e+\"</colgroup></table>\",2);case\"tr\":return o(\"<table><tbody>\"+e+\"</tbody></table>\",2);case\"td\":case\"th\":return o(\"<table><tbody><tr>\"+e+\"</tr></tbody></table>\",3);case\"script\":return o(\"<div>\"+e+\"</div>\",1);default:return o(e,0)}}}function U(e){if(e){e()}}function a(e,t){return Object.prototype.toString.call(e)===\"[object \"+t+\"]\"}function f(e){return a(e,\"Function\")}function g(e){return a(e,\"Object\")}function j(e){var t=\"htmx-internal-data\";var r=e[t];if(!r){r=e[t]={}}return r}function p(e){var t=[];if(e){for(var r=0;r<e.length;r++){t.push(e[r])}}return t}function B(e,t){if(e){for(var r=0;r<e.length;r++){t(e[r])}}}function m(e){var t=e.getBoundingClientRect();var r=t.top;var n=t.bottom;return r<window.innerHeight&&n>=0}function z(e){return P().body.contains(e)}function y(e){return e.trim().split(/\\s+/)}function V(e,t){for(var r in t){if(t.hasOwnProperty(r)){e[r]=t[r]}}return e}function x(e){try{return JSON.parse(e)}catch(e){ut(e);return null}}function e(e){return Ut(P().body,function(){return eval(e)})}function t(t){var e=D.on(\"htmx:load\",function(e){t(e.detail.elt)});return e}function b(){D.logger=function(e,t,r){if(console){console.log(t,e,r)}}}function w(e,t){if(t){return e.querySelector(t)}else{return w(P(),e)}}function S(e,t){if(t){return e.querySelectorAll(t)}else{return S(P(),e)}}function E(e,t){e=H(e);if(t){setTimeout(function(){E(e)},t)}else{e.parentElement.removeChild(e)}}function C(e,t,r){e=H(e);if(r){setTimeout(function(){C(e,t)},r)}else{e.classList&&e.classList.add(t)}}function R(e,t,r){e=H(e);if(r){setTimeout(function(){R(e,t)},r)}else{if(e.classList){e.classList.remove(t);if(e.classList.length===0){e.removeAttribute(\"class\")}}}}function q(e,t){e=H(e);e.classList.toggle(t)}function L(e,t){e=H(e);B(e.parentElement.children,function(e){R(e,t)});C(e,t)}function O(e,t){e=H(e);if(e.closest){return e.closest(t)}else{do{if(e==null||v(e,t)){return e}}while(e=e&&l(e))}}function T(e,t){if(t.indexOf(\"closest \")===0){return[O(e,t.substr(8))]}else if(t.indexOf(\"find \")===0){return[w(e,t.substr(5))]}else if(t===\"document\"){return[document]}else if(t===\"window\"){return[window]}else{return P().querySelectorAll(t)}}function A(e,t){if(t){return T(e,t)[0]}else{return T(P().body,e)[0]}}function H(e){if(a(e,\"String\")){return w(e)}else{return e}}function k(e,t,r){if(f(t)){return{target:P().body,event:e,listener:t}}else{return{target:H(e),event:t,listener:r}}}function N(t,r,n){rr(function(){var e=k(t,r,n);e.target.addEventListener(e.event,e.listener)});var e=f(r);return e?r:n}function I(t,r,n){rr(function(){var e=k(t,r,n);e.target.removeEventListener(e.event,e.listener)});return f(r)?r:n}function _(e){var t=d(e,function(e){return F(e,\"hx-target\")!==null});if(t){var r=F(t,\"hx-target\");if(r===\"this\"){return t}else{return A(e,r)}}else{var n=j(e);if(n.boosted){return P().body}else{return e}}}function M(e){var t=D.config.attributesToSettle;for(var r=0;r<t.length;r++){if(e===t[r]){return true}}return false}function W(t,r){B(t.attributes,function(e){if(!r.hasAttribute(e.name)&&M(e.name)){t.removeAttribute(e.name)}});B(r.attributes,function(e){if(M(e.name)){t.setAttribute(e.name,e.value)}})}function $(e,t){var r=tr(t);for(var n=0;n<r.length;n++){var i=r[n];try{if(i.isInlineSwap(e)){return true}}catch(e){ut(e)}}return e===\"outerHTML\"}function J(e,t,r){var n=\"#\"+t.id;var i=\"outerHTML\";if(e===\"true\"){}else if(e.indexOf(\":\")>0){i=e.substr(0,e.indexOf(\":\"));n=e.substr(e.indexOf(\":\")+1,e.length)}else{i=e}var o=P().querySelector(n);if(o){var a;a=P().createDocumentFragment();a.appendChild(t);if(!$(i,o)){a=t}le(i,o,o,a,r)}else{t.parentNode.removeChild(t);ot(P().body,\"htmx:oobErrorNoTarget\",{content:t})}return e}function Z(e,r){B(S(e,\"[hx-swap-oob], [data-hx-swap-oob]\"),function(e){var t=F(e,\"hx-swap-oob\");if(t!=null){J(t,e,r)}})}function G(e){B(S(e,\"[hx-preserve], [data-hx-preserve]\"),function(e){var t=F(e,\"id\");var r=P().getElementById(t);if(r!=null){e.parentNode.replaceChild(r,e)}})}function K(n,e,i){B(e.querySelectorAll(\"[id]\"),function(e){if(e.id&&e.id.length>0){var t=n.querySelector(e.tagName+\"[id='\"+e.id+\"']\");if(t&&t!==n){var r=e.cloneNode();W(e,t);i.tasks.push(function(){W(e,r)})}}})}function Y(e){return function(){R(e,D.config.addedClass);rt(e);Ke(e);Q(e);lt(e,\"htmx:load\")}}function Q(e){var t=\"[autofocus]\";var r=v(e,t)?e:e.querySelector(t);if(r!=null){r.focus()}}function ee(e,t,r,n){K(e,r,n);while(r.childNodes.length>0){var i=r.firstChild;C(i,D.config.addedClass);e.insertBefore(i,t);if(i.nodeType!==Node.TEXT_NODE&&i.nodeType!==Node.COMMENT_NODE){n.tasks.push(Y(i))}}}function te(t){var e=j(t);if(e.webSocket){e.webSocket.close()}if(e.sseEventSource){e.sseEventSource.close()}if(e.listenerInfos){B(e.listenerInfos,function(e){if(t!==e.on){e.on.removeEventListener(e.trigger,e.listener)}})}if(t.children){B(t.children,function(e){te(e)})}}function re(e,t,r){if(e.tagName===\"BODY\"){return se(e,t,r)}else{var n=e.previousSibling;ee(l(e),e,t,r);if(n==null){var i=l(e).firstChild}else{var i=n.nextSibling}j(e).replacedWith=i;r.elts=[];while(i&&i!==e){if(i.nodeType===Node.ELEMENT_NODE){r.elts.push(i)}i=i.nextElementSibling}te(e);l(e).removeChild(e)}}function ne(e,t,r){return ee(e,e.firstChild,t,r)}function ie(e,t,r){return ee(l(e),e,t,r)}function oe(e,t,r){return ee(e,null,t,r)}function ae(e,t,r){return ee(l(e),e.nextSibling,t,r)}function se(e,t,r){var n=e.firstChild;ee(e,n,t,r);if(n){while(n.nextSibling){te(n.nextSibling);e.removeChild(n.nextSibling)}te(n);e.removeChild(n)}}function ue(e,t){var r=X(e,\"hx-select\");if(r){var n=P().createDocumentFragment();B(t.querySelectorAll(r),function(e){n.appendChild(e)});t=n}return t}function le(e,t,r,n,i){switch(e){case\"none\":return;case\"outerHTML\":re(r,n,i);return;case\"afterbegin\":ne(r,n,i);return;case\"beforebegin\":ie(r,n,i);return;case\"beforeend\":oe(r,n,i);return;case\"afterend\":ae(r,n,i);return;default:var o=tr(t);for(var a=0;a<o.length;a++){var s=o[a];try{var u=s.handleSwap(e,r,n,i);if(u){if(typeof u.length!==\"undefined\"){for(var l=0;l<u.length;l++){var f=u[l];if(f.nodeType!==Node.TEXT_NODE&&f.nodeType!==Node.COMMENT_NODE){i.tasks.push(Y(f))}}}return}}catch(e){ut(e)}}se(r,n,i)}}function fe(e){if(e.indexOf(\"<title\")>-1){var t=e.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\"\");var r=t.match(/<title(\\s[^>]*>|>)([\\s\\S]*?)<\\/title>/im);if(r){return r[2]}}}function ce(e,t,r,n,i){var o=fe(n);if(o){var a=w(\"title\");if(a){a.innerHTML=o}else{window.document.title=o}}var s=u(n);if(s){Z(s,i);s=ue(r,s);G(s);return le(e,r,t,s,i)}}function he(e,t,r){var n=e.getResponseHeader(t);if(n.indexOf(\"{\")===0){var i=x(n);for(var o in i){if(i.hasOwnProperty(o)){var a=i[o];if(!g(a)){a={value:a}}lt(r,o,a)}}}else{lt(r,n,[])}}var de=/\\s/;var ve=/[\\s,]/;var ge=/[_$a-zA-Z]/;var pe=/[_$a-zA-Z0-9]/;var me=['\"',\"'\",\"/\"];var ye=/[^\\s]/;function xe(e){var t=[];var r=0;while(r<e.length){if(ge.exec(e.charAt(r))){var n=r;while(pe.exec(e.charAt(r+1))){r++}t.push(e.substr(n,r-n+1))}else if(me.indexOf(e.charAt(r))!==-1){var i=e.charAt(r);var n=r;r++;while(r<e.length&&e.charAt(r)!==i){if(e.charAt(r)===\"\\\\\"){r++}r++}t.push(e.substr(n,r-n+1))}else{var o=e.charAt(r);t.push(o)}r++}return t}function be(e,t,r){return ge.exec(e.charAt(0))&&e!==\"true\"&&e!==\"false\"&&e!==\"this\"&&e!==r&&t!==\".\"}function we(e,t,r){if(t[0]===\"[\"){t.shift();var n=1;var i=\" return (function(\"+r+\"){ return (\";var o=null;while(t.length>0){var a=t[0];if(a===\"]\"){n--;if(n===0){if(o===null){i=i+\"true\"}t.shift();i+=\")})\";try{var s=Ut(e,function(){return Function(i)()},function(){return true});s.source=i;return s}catch(e){ot(P().body,\"htmx:syntax:error\",{error:e,source:i});return null}}}else if(a===\"[\"){n++}if(be(a,o,r)){i+=\"((\"+r+\".\"+a+\") ? (\"+r+\".\"+a+\") : (window.\"+a+\"))\"}else{i=i+a}o=t.shift()}}}function Se(e,t){var r=\"\";while(e.length>0&&!e[0].match(t)){r+=e.shift()}return r}var Ee=\"input, textarea, select\";function Ce(e){var t=F(e,\"hx-trigger\");var r=[];if(t){var n=xe(t);do{Se(n,ye);var i=n.length;var o=Se(n,/[,\\[\\s]/);if(o!==\"\"){if(o===\"every\"){var a={trigger:\"every\"};Se(n,ye);a.pollInterval=h(Se(n,/[,\\[\\s]/));Se(n,ye);var s=we(e,n,\"event\");if(s){a.eventFilter=s}r.push(a)}else if(o.indexOf(\"sse:\")===0){r.push({trigger:\"sse\",sseEvent:o.substr(4)})}else{var u={trigger:o};var s=we(e,n,\"event\");if(s){u.eventFilter=s}while(n.length>0&&n[0]!==\",\"){Se(n,ye);var l=n.shift();if(l===\"changed\"){u.changed=true}else if(l===\"once\"){u.once=true}else if(l===\"consume\"){u.consume=true}else if(l===\"delay\"&&n[0]===\":\"){n.shift();u.delay=h(Se(n,ve))}else if(l===\"from\"&&n[0]===\":\"){n.shift();u.from=Se(n,ve)}else if(l===\"target\"&&n[0]===\":\"){n.shift();u.target=Se(n,ve)}else if(l===\"throttle\"&&n[0]===\":\"){n.shift();u.throttle=h(Se(n,ve))}else if(l===\"queue\"&&n[0]===\":\"){n.shift();u.queue=Se(n,ve)}else if((l===\"root\"||l===\"threshold\")&&n[0]===\":\"){n.shift();u[l]=Se(n,ve)}else{ot(e,\"htmx:syntax:error\",{token:n.shift()})}}r.push(u)}}if(n.length===i){ot(e,\"htmx:syntax:error\",{token:n.shift()})}Se(n,ye)}while(n[0]===\",\"&&n.shift())}if(r.length>0){return r}else if(v(e,\"form\")){return[{trigger:\"submit\"}]}else if(v(e,Ee)){return[{trigger:\"change\"}]}else{return[{trigger:\"click\"}]}}function Re(e){j(e).cancelled=true}function qe(e,t,r,n){var i=j(e);i.timeout=setTimeout(function(){if(z(e)&&i.cancelled!==true){if(!He(n,it(\"hx:poll:trigger\",{triggerSpec:n}))){Zt(t,r,e)}qe(e,t,F(e,\"hx-\"+t),n)}},n.pollInterval)}function Le(e){return location.hostname===e.hostname&&c(e,\"href\")&&c(e,\"href\").indexOf(\"#\")!==0}function Oe(t,r,e){if(t.tagName===\"A\"&&Le(t)||t.tagName===\"FORM\"){r.boosted=true;var n,i;if(t.tagName===\"A\"){n=\"get\";i=c(t,\"href\");r.pushURL=true}else{var o=c(t,\"method\");n=o?o.toLowerCase():\"get\";if(n===\"get\"){r.pushURL=true}i=c(t,\"action\")}e.forEach(function(e){ke(t,n,i,r,e,true)})}}function Te(e){return e.tagName===\"FORM\"||v(e,'input[type=\"submit\"], button')&&O(e,\"form\")!==null||e.tagName===\"A\"&&e.href&&(e.getAttribute(\"href\")===\"#\"||e.getAttribute(\"href\").indexOf(\"#\")!==0)}function Ae(e,t){return j(e).boosted&&e.tagName===\"A\"&&t.type===\"click\"&&(t.ctrlKey||t.metaKey)}function He(e,t){var r=e.eventFilter;if(r){try{return r(t)!==true}catch(e){ot(P().body,\"htmx:eventFilter:error\",{error:e,source:r.source});return true}}return false}function ke(o,a,s,e,u,l){var t;if(u.from){t=T(o,u.from)}else{t=[o]}B(t,function(n){var i=function(e){if(!z(o)){n.removeEventListener(u.trigger,i);return}if(Ae(o,e)){return}if(l||Te(o)){e.preventDefault()}if(He(u,e)){return}var t=j(e);t.triggerSpec=u;if(t.handledFor==null){t.handledFor=[]}var r=j(o);if(t.handledFor.indexOf(o)<0){t.handledFor.push(o);if(u.consume){e.stopPropagation()}if(u.target&&e.target){if(!v(e.target,u.target)){return}}if(u.once){if(r.triggeredOnce){return}else{r.triggeredOnce=true}}if(u.changed){if(r.lastValue===o.value){return}else{r.lastValue=o.value}}if(r.delayed){clearTimeout(r.delayed)}if(r.throttle){return}if(u.throttle){if(!r.throttle){Zt(a,s,o,e);r.throttle=setTimeout(function(){r.throttle=null},u.throttle)}}else if(u.delay){r.delayed=setTimeout(function(){Zt(a,s,o,e)},u.delay)}else{Zt(a,s,o,e)}}};if(e.listenerInfos==null){e.listenerInfos=[]}e.listenerInfos.push({trigger:u.trigger,listener:i,on:n});n.addEventListener(u.trigger,i)})}var Ne=false;var Ie=null;function Me(){if(!Ie){Ie=function(){Ne=true};window.addEventListener(\"scroll\",Ie);setInterval(function(){if(Ne){Ne=false;B(P().querySelectorAll(\"[hx-trigger='revealed'],[data-hx-trigger='revealed']\"),function(e){De(e)})}},200)}}function De(e){var t=j(e);if(!t.revealed&&m(e)){t.revealed=true;if(t.initialized){Zt(t.verb,t.path,e)}else{e.addEventListener(\"htmx:afterProcessNode\",function(){Zt(t.verb,t.path,e)},{once:true})}}}function Fe(e,t,r){var n=y(r);for(var i=0;i<n.length;i++){var o=n[i].split(/:(.+)/);if(o[0]===\"connect\"){Pe(e,o[1],0)}if(o[0]===\"send\"){Ue(e)}}}function Pe(s,r,n){if(!z(s)){return}if(r.indexOf(\"/\")==0){var e=location.hostname+(location.port?\":\"+location.port:\"\");if(location.protocol==\"https:\"){r=\"wss://\"+e+r}else if(location.protocol==\"http:\"){r=\"ws://\"+e+r}}var t=D.createWebSocket(r);t.onerror=function(e){ot(s,\"htmx:wsError\",{error:e,socket:t});Xe(s)};t.onclose=function(e){if([1006,1012,1013].indexOf(e.code)>=0){var t=je(n);setTimeout(function(){Pe(s,r,n+1)},t)}};t.onopen=function(e){n=0};j(s).webSocket=t;t.addEventListener(\"message\",function(e){if(Xe(s)){return}var t=e.data;st(s,function(e){t=e.transformResponse(t,null,s)});var r=Ft(s);var n=u(t);var i=p(n.children);for(var o=0;o<i.length;o++){var a=i[o];J(F(a,\"hx-swap-oob\")||\"true\",a,r)}mt(r.tasks)})}function Xe(e){if(!z(e)){j(e).webSocket.close();return true}}function Ue(l){var f=d(l,function(e){return j(e).webSocket!=null});if(f){l.addEventListener(Ce(l)[0].trigger,function(e){var t=j(f).webSocket;var r=kt(l,f);var n=Ot(l,\"post\");var i=n.errors;var o=n.values;var a=zt(l);var s=V(o,a);var u=Nt(s,l);u[\"HEADERS\"]=r;if(i&&i.length>0){lt(l,\"htmx:validation:halted\",i);return}t.send(JSON.stringify(u));if(Te(l)){e.preventDefault()}})}else{ot(l,\"htmx:noWebSocketSourceError\")}}function je(e){var t=D.config.wsReconnectDelay;if(typeof t===\"function\"){return t(e)}if(t===\"full-jitter\"){var r=Math.min(e,6);var n=1e3*Math.pow(2,r);return n*Math.random()}ut('htmx.config.wsReconnectDelay must either be a function or the string \"full-jitter\"')}function Be(e,t,r){var n=y(r);for(var i=0;i<n.length;i++){var o=n[i].split(/:(.+)/);if(o[0]===\"connect\"){ze(e,o[1])}if(o[0]===\"swap\"){Ve(e,o[1])}}}function ze(t,e){var r=D.createEventSource(e);r.onerror=function(e){ot(t,\"htmx:sseError\",{error:e,source:r});We(t)};j(t).sseEventSource=r}function Ve(o,a){var s=d(o,$e);if(s){var u=j(s).sseEventSource;var l=function(e){if(We(s)){u.removeEventListener(a,l);return}var t=e.data;st(o,function(e){t=e.transformResponse(t,null,o)});var r=Mt(o);var n=_(o);var i=Ft(o);ce(r.swapStyle,o,n,t,i);mt(i.tasks);lt(o,\"htmx:sseMessage\",e)};j(o).sseListener=l;u.addEventListener(a,l)}else{ot(o,\"htmx:noSSESourceError\")}}function _e(e,t,r,n){var i=d(e,$e);if(i){var o=j(i).sseEventSource;var a=function(){if(!We(i)){if(z(e)){Zt(t,r,e)}else{o.removeEventListener(n,a)}}};j(e).sseListener=a;o.addEventListener(n,a)}else{ot(e,\"htmx:noSSESourceError\")}}function We(e){if(!z(e)){j(e).sseEventSource.close();return true}}function $e(e){return j(e).sseEventSource!=null}function Je(e,t,r,n,i){var o=function(){if(!n.loaded){n.loaded=true;Zt(t,r,e)}};if(i){setTimeout(o,i)}else{o()}}function Ze(o,a,e){var t=false;B(r,function(n){if(s(o,\"hx-\"+n)){var i=F(o,\"hx-\"+n);t=true;a.path=i;a.verb=n;e.forEach(function(e){if(e.sseEvent){_e(o,n,i,e.sseEvent)}else if(e.trigger===\"revealed\"){Me();De(o)}else if(e.trigger===\"intersect\"){var t={};if(e.root){t.root=A(o,e.root)}if(e.threshold){t.threshold=parseFloat(e.threshold)}var r=new IntersectionObserver(function(e){for(var t=0;t<e.length;t++){var r=e[t];if(r.isIntersecting){lt(o,\"intersect\");break}}},t);r.observe(o);ke(o,n,i,a,e)}else if(e.trigger===\"load\"){Je(o,n,i,a,e.delay)}else if(e.pollInterval){a.polling=true;qe(o,n,i,e)}else{ke(o,n,i,a,e)}})}});return t}function Ge(e){if(e.type===\"text/javascript\"||e.type===\"\"){var t=P().createElement(\"script\");B(e.attributes,function(e){t.setAttribute(e.name,e.value)});t.textContent=e.textContent;t.async=false;var r=e.parentElement;try{r.insertBefore(t,e)}catch(e){ut(e)}finally{r.removeChild(e)}}}function Ke(e){if(v(e,\"script\")){Ge(e)}B(S(e,\"script\"),function(e){Ge(e)})}function Ye(){return document.querySelector(\"[hx-boost], [data-hx-boost]\")}function Qe(e){if(e.querySelectorAll){var t=Ye()?\", a, form\":\"\";var r=e.querySelectorAll(n+t+\", [hx-sse], [data-hx-sse], [hx-ws],\"+\" [data-hx-ws]\");return r}else{return[]}}function et(r){var e=function(e){if(v(e.target,\"button, input[type='submit']\")){var t=j(r);t.lastButtonClicked=e.target}};r.addEventListener(\"click\",e);r.addEventListener(\"focusin\",e);r.addEventListener(\"focusout\",function(e){var t=j(r);t.lastButtonClicked=null})}function tt(e){if(e.closest&&e.closest(D.config.disableSelector)){return}var t=j(e);if(!t.initialized){t.initialized=true;lt(e,\"htmx:beforeProcessNode\");if(e.value){t.lastValue=e.value}var r=Ce(e);var n=Ze(e,t,r);if(!n&&X(e,\"hx-boost\")===\"true\"){Oe(e,t,r)}if(e.tagName===\"FORM\"){et(e)}var i=F(e,\"hx-sse\");if(i){Be(e,t,i)}var o=F(e,\"hx-ws\");if(o){Fe(e,t,o)}lt(e,\"htmx:afterProcessNode\")}}function rt(e){e=H(e);tt(e);B(Qe(e),function(e){tt(e)})}function nt(e){return e.replace(/([a-z0-9])([A-Z])/g,\"$1-$2\").toLowerCase()}function it(e,t){var r;if(window.CustomEvent&&typeof window.CustomEvent===\"function\"){r=new CustomEvent(e,{bubbles:true,cancelable:true,detail:t})}else{r=P().createEvent(\"CustomEvent\");r.initCustomEvent(e,true,true,t)}return r}function ot(e,t,r){lt(e,t,V({error:t},r))}function at(e){return e===\"htmx:afterProcessNode\"}function st(e,t){B(tr(e),function(e){try{t(e)}catch(e){ut(e)}})}function ut(e){if(console.error){console.error(e)}else if(console.log){console.log(\"ERROR: \",e)}}function lt(e,t,r){e=H(e);if(r==null){r={}}r[\"elt\"]=e;var n=it(t,r);if(D.logger&&!at(t)){D.logger(e,t,r)}if(r.error){ut(r.error);lt(e,\"htmx:error\",{errorInfo:r})}var i=e.dispatchEvent(n);var o=nt(t);if(i&&o!==t){var a=it(o,n.detail);i=i&&e.dispatchEvent(a)}st(e,function(e){i=i&&e.onEvent(t,n)!==false});return i}var ft=null;function ct(){var e=P().querySelector(\"[hx-history-elt],[data-hx-history-elt]\");return e||P().body}function ht(e,t,r,n){var i=x(localStorage.getItem(\"htmx-history-cache\"))||[];for(var o=0;o<i.length;o++){if(i[o].url===e){i.splice(o,1);break}}i.push({url:e,content:t,title:r,scroll:n});while(i.length>D.config.historyCacheSize){i.shift()}while(i.length>0){try{localStorage.setItem(\"htmx-history-cache\",JSON.stringify(i));break}catch(e){ot(P().body,\"htmx:historyCacheError\",{cause:e,cache:i});i.shift()}}}function dt(e){var t=x(localStorage.getItem(\"htmx-history-cache\"))||[];for(var r=0;r<t.length;r++){if(t[r].url===e){return t[r]}}return null}function vt(e){var t=D.config.requestClass;var r=e.cloneNode(true);B(S(r,\".\"+t),function(e){R(e,t)});return r.innerHTML}function gt(){var e=ct();var t=ft||location.pathname+location.search;lt(P().body,\"htmx:beforeHistorySave\",{path:t,historyElt:e});if(D.config.historyEnabled)history.replaceState({htmx:true},P().title,window.location.href);ht(t,vt(e),P().title,window.scrollY)}function pt(e){if(D.config.historyEnabled)history.pushState({htmx:true},\"\",e);ft=e}function mt(e){B(e,function(e){e.call()})}function yt(n){var e=new XMLHttpRequest;var i={path:n,xhr:e};lt(P().body,\"htmx:historyCacheMiss\",i);e.open(\"GET\",n,true);e.setRequestHeader(\"HX-History-Restore-Request\",\"true\");e.onload=function(){if(this.status>=200&&this.status<400){lt(P().body,\"htmx:historyCacheMissLoad\",i);var e=u(this.response);e=e.querySelector(\"[hx-history-elt],[data-hx-history-elt]\")||e;var t=ct();var r=Ft(t);se(t,e,r);mt(r.tasks);ft=n;lt(P().body,\"htmx:historyRestore\",{path:n})}else{ot(P().body,\"htmx:historyCacheMissLoadError\",i)}};e.send()}function xt(e){gt();e=e||location.pathname+location.search;var t=dt(e);if(t){var r=u(t.content);var n=ct();var i=Ft(n);se(n,r,i);mt(i.tasks);document.title=t.title;window.scrollTo(0,t.scroll);ft=e;lt(P().body,\"htmx:historyRestore\",{path:e})}else{if(D.config.refreshOnHistoryMiss){window.location.reload(true)}else{yt(e)}}}function bt(e){var t=X(e,\"hx-push-url\");return t&&t!==\"false\"||j(e).boosted&&j(e).pushURL}function wt(e){var t=X(e,\"hx-push-url\");return t===\"true\"||t===\"false\"?null:t}function St(e){var t=X(e,\"hx-indicator\");if(t){var r=T(e,t)}else{r=[e]}B(r,function(e){e.classList[\"add\"].call(e.classList,D.config.requestClass)});return r}function Et(e){B(e,function(e){e.classList[\"remove\"].call(e.classList,D.config.requestClass)})}function Ct(e,t){for(var r=0;r<e.length;r++){var n=e[r];if(n.isSameNode(t)){return true}}return false}function Rt(e){if(e.name===\"\"||e.name==null||e.disabled){return false}if(e.type===\"button\"||e.type===\"submit\"||e.tagName===\"image\"||e.tagName===\"reset\"||e.tagName===\"file\"){return false}if(e.type===\"checkbox\"||e.type===\"radio\"){return e.checked}return true}function qt(t,r,n,e,i){if(e==null||Ct(t,e)){return}else{t.push(e)}if(Rt(e)){var o=c(e,\"name\");var a=e.value;if(e.multiple){a=p(e.querySelectorAll(\"option:checked\")).map(function(e){return e.value})}if(e.files){a=p(e.files)}if(o!=null&&a!=null){var s=r[o];if(s){if(Array.isArray(s)){if(Array.isArray(a)){r[o]=s.concat(a)}else{s.push(a)}}else{if(Array.isArray(a)){r[o]=[s].concat(a)}else{r[o]=[s,a]}}}else{r[o]=a}}if(i){Lt(e,n)}}if(v(e,\"form\")){var u=e.elements;B(u,function(e){qt(t,r,n,e,i)})}}function Lt(e,t){if(e.willValidate){lt(e,\"htmx:validation:validate\");if(!e.checkValidity()){t.push({elt:e,message:e.validationMessage,validity:e.validity});lt(e,\"htmx:validation:failed\",{message:e.validationMessage,validity:e.validity})}}}function Ot(e,t){var r=[];var n={};var i={};var o=[];var a=v(e,\"form\")&&e.noValidate!==true;if(t!==\"get\"){qt(r,i,o,O(e,\"form\"),a)}qt(r,n,o,e,a);var s=j(e);if(s.lastButtonClicked){var u=c(s.lastButtonClicked,\"name\");if(u){n[u]=s.lastButtonClicked.value}}var l=X(e,\"hx-include\");if(l){var f=T(e,l);B(f,function(e){qt(r,n,o,e,a);if(!v(e,\"form\")){B(e.querySelectorAll(Ee),function(e){qt(r,n,o,e,a)})}})}n=V(n,i);return{errors:o,values:n}}function Tt(e,t,r){if(e!==\"\"){e+=\"&\"}e+=encodeURIComponent(t)+\"=\"+encodeURIComponent(r);return e}function At(e){var t=\"\";for(var r in e){if(e.hasOwnProperty(r)){var n=e[r];if(Array.isArray(n)){B(n,function(e){t=Tt(t,r,e)})}else{t=Tt(t,r,n)}}}return t}function Ht(e){var t=new FormData;for(var r in e){if(e.hasOwnProperty(r)){var n=e[r];if(Array.isArray(n)){B(n,function(e){t.append(r,e)})}else{t.append(r,n)}}}return t}function kt(e,t,r){var n={\"HX-Request\":\"true\",\"HX-Trigger\":c(e,\"id\"),\"HX-Trigger-Name\":c(e,\"name\"),\"HX-Target\":F(t,\"id\"),\"HX-Current-URL\":P().location.href};Xt(e,\"hx-headers\",false,n);if(r!==undefined){n[\"HX-Prompt\"]=r}if(j(e).boosted){n[\"HX-Boosted\"]=\"true\"}return n}function Nt(t,e){var r=X(e,\"hx-params\");if(r){if(r===\"none\"){return{}}else if(r===\"*\"){return t}else if(r.indexOf(\"not \")===0){B(r.substr(4).split(\",\"),function(e){e=e.trim();delete t[e]});return t}else{var n={};B(r.split(\",\"),function(e){e=e.trim();n[e]=t[e]});return n}}else{return t}}function It(e){return c(e,\"href\")&&c(e,\"href\").indexOf(\"#\")>=0}function Mt(e){var t=X(e,\"hx-swap\");var r={swapStyle:j(e).boosted?\"innerHTML\":D.config.defaultSwapStyle,swapDelay:D.config.defaultSwapDelay,settleDelay:D.config.defaultSettleDelay};if(j(e).boosted&&!It(e)){r[\"show\"]=\"top\"}if(t){var n=y(t);if(n.length>0){r[\"swapStyle\"]=n[0];for(var i=1;i<n.length;i++){var o=n[i];if(o.indexOf(\"swap:\")===0){r[\"swapDelay\"]=h(o.substr(5))}if(o.indexOf(\"settle:\")===0){r[\"settleDelay\"]=h(o.substr(7))}if(o.indexOf(\"scroll:\")===0){var a=o.substr(7);var s=a.split(\":\");var u=s.pop();var l=s.length>0?s.join(\":\"):null;r[\"scroll\"]=u;r[\"scrollTarget\"]=l}if(o.indexOf(\"show:\")===0){var f=o.substr(5);var s=f.split(\":\");var c=s.pop();var l=s.length>0?s.join(\":\"):null;r[\"show\"]=c;r[\"showTarget\"]=l}}}}return r}function Dt(t,r,n){var i=null;st(r,function(e){if(i==null){i=e.encodeParameters(t,n,r)}});if(i!=null){return i}else{if(X(r,\"hx-encoding\")===\"multipart/form-data\"||v(r,\"form\")&&c(r,\"enctype\")===\"multipart/form-data\"){return Ht(n)}else{return At(n)}}}function Ft(e){return{tasks:[],elts:[e]}}function Pt(e,t){var r=e[0];var n=e[e.length-1];if(t.scroll){var i=null;if(t.scrollTarget){i=A(r,t.scrollTarget)}if(t.scroll===\"top\"&&(r||i)){i=i||r;i.scrollTop=0}if(t.scroll===\"bottom\"&&(n||i)){i=i||n;i.scrollTop=i.scrollHeight}}if(t.show){var i=null;if(t.showTarget){var o=t.showTarget;if(t.showTarget===\"window\"){o=\"body\"}i=A(r,o)}if(t.show===\"top\"&&(r||i)){i=i||r;i.scrollIntoView({block:\"start\",behavior:D.config.scrollBehavior})}if(t.show===\"bottom\"&&(n||i)){i=i||n;i.scrollIntoView({block:\"end\",behavior:D.config.scrollBehavior})}}}function Xt(e,t,r,n){if(n==null){n={}}if(e==null){return n}var i=F(e,t);if(i){var o=i.trim();var a=r;if(o.indexOf(\"javascript:\")===0){o=o.substr(11);a=true}else if(o.indexOf(\"js:\")===0){o=o.substr(3);a=true}if(o.indexOf(\"{\")!==0){o=\"{\"+o+\"}\"}var s;if(a){s=Ut(e,function(){return Function(\"return (\"+o+\")\")()},{})}else{s=x(o)}for(var u in s){if(s.hasOwnProperty(u)){if(n[u]==null){n[u]=s[u]}}}}return Xt(l(e),t,r,n)}function Ut(e,t,r){if(D.config.allowEval){return t()}else{ot(e,\"htmx:evalDisallowedError\");return r}}function jt(e,t){return Xt(e,\"hx-vars\",true,t)}function Bt(e,t){return Xt(e,\"hx-vals\",false,t)}function zt(e){return V(jt(e),Bt(e))}function Vt(t,r,n){if(n!==null){try{t.setRequestHeader(r,n)}catch(e){t.setRequestHeader(r,encodeURIComponent(n));t.setRequestHeader(r+\"-URI-AutoEncoded\",\"true\")}}}function _t(t){if(t.responseURL&&typeof URL!==\"undefined\"){try{var e=new URL(t.responseURL);return e.pathname+e.search}catch(e){ot(P().body,\"htmx:badResponseUrl\",{url:t.responseURL})}}}function Wt(e,t){return e.getAllResponseHeaders().match(t)}function $t(e,t,r){e=e.toLowerCase();if(r){if(r instanceof Element||a(r,\"String\")){return Zt(e,t,null,null,{targetOverride:H(r),returnPromise:true})}else{return Zt(e,t,H(r.source),r.event,{handler:r.handler,headers:r.headers,values:r.values,targetOverride:H(r.target),returnPromise:true})}}else{return Zt(e,t,null,null,{returnPromise:true})}}function Jt(e){var t=[];while(e){t.push(e);e=e.parentElement}return t}function Zt(e,t,n,r,i){var o=null;var a=null;i=i!=null?i:{};if(i.returnPromise&&typeof Promise!==\"undefined\"){var s=new Promise(function(e,t){o=e;a=t})}if(n==null){n=P().body}var u=i.handler||Gt;if(!z(n)){return}var l=i.targetOverride||_(n);if(l==null){ot(n,\"htmx:targetError\",{target:F(n,\"hx-target\")});return}var f=j(n);if(f.requestInFlight){var c=\"last\";if(r){var h=j(r);if(h&&h.triggerSpec&&h.triggerSpec.queue){c=h.triggerSpec.queue}}if(f.queuedRequests==null){f.queuedRequests=[]}if(c===\"first\"&&f.queuedRequests.length===0){f.queuedRequests.push(function(){Zt(e,t,n,r,i)})}else if(c===\"all\"){f.queuedRequests.push(function(){Zt(e,t,n,r,i)})}else if(c===\"last\"){f.queuedRequests=[];f.queuedRequests.push(function(){Zt(e,t,n,r,i)})}return}else{f.requestInFlight=true}var d=function(){f.requestInFlight=false;if(f.queuedRequests!=null&&f.queuedRequests.length>0){var e=f.queuedRequests.shift();e()}};var v=X(n,\"hx-prompt\");if(v){var g=prompt(v);if(g===null||!lt(n,\"htmx:prompt\",{prompt:g,target:l})){U(o);d();return s}}var p=X(n,\"hx-confirm\");if(p){if(!confirm(p)){U(o);d();return s}}var m=new XMLHttpRequest;var y=kt(n,l,g);if(i.headers){y=V(y,i.headers)}var x=Ot(n,e);var b=x.errors;var w=x.values;if(i.values){w=V(w,i.values)}var S=zt(n);var E=V(w,S);var C=Nt(E,n);if(e!==\"get\"&&X(n,\"hx-encoding\")==null){y[\"Content-Type\"]=\"application/x-www-form-urlencoded; charset=UTF-8\"}if(t==null||t===\"\"){t=P().location.href}var R=Xt(n,\"hx-request\");var q={parameters:C,unfilteredParameters:E,headers:y,target:l,verb:e,errors:b,withCredentials:i.credentials||R.credentials||D.config.withCredentials,timeout:i.timeout||R.timeout||D.config.timeout,path:t,triggeringEvent:r};if(!lt(n,\"htmx:configRequest\",q)){U(o);d();return s}t=q.path;e=q.verb;y=q.headers;C=q.parameters;b=q.errors;if(b&&b.length>0){lt(n,\"htmx:validation:halted\",q);U(o);d();return s}var L=t.split(\"#\");var O=L[0];var T=L[1];if(e===\"get\"){var A=O;var H=Object.keys(C).length!==0;if(H){if(A.indexOf(\"?\")<0){A+=\"?\"}else{A+=\"&\"}A+=At(C);if(T){A+=\"#\"+T}}m.open(\"GET\",A,true)}else{m.open(e.toUpperCase(),t,true)}m.overrideMimeType(\"text/html\");m.withCredentials=q.withCredentials;m.timeout=q.timeout;if(R.noHeaders){}else{for(var k in y){if(y.hasOwnProperty(k)){var N=y[k];Vt(m,k,N)}}}var I={xhr:m,target:l,requestConfig:q,pathInfo:{path:t,finalPath:A,anchor:T}};m.onload=function(){try{var e=Jt(n);u(n,I);Et(M);lt(n,\"htmx:afterRequest\",I);lt(n,\"htmx:afterOnLoad\",I);if(!z(n)){var t=null;while(e.length>0&&t==null){var r=e.shift();if(z(r)){t=r}}if(t){lt(t,\"htmx:afterRequest\",I);lt(t,\"htmx:afterOnLoad\",I)}}U(o);d()}catch(e){ot(n,\"htmx:onLoadError\",V({error:e},I));throw e}};m.onerror=function(){Et(M);ot(n,\"htmx:afterRequest\",I);ot(n,\"htmx:sendError\",I);U(a);d()};m.onabort=function(){Et(M);ot(n,\"htmx:afterRequest\",I);ot(n,\"htmx:sendAbort\",I);U(a);d()};m.ontimeout=function(){Et(M);ot(n,\"htmx:afterRequest\",I);ot(n,\"htmx:timeout\",I);U(a);d()};if(!lt(n,\"htmx:beforeRequest\",I)){U(o);d();return s}var M=St(n);B([\"loadstart\",\"loadend\",\"progress\",\"abort\"],function(t){B([m,m.upload],function(e){e.addEventListener(t,function(e){lt(n,\"htmx:xhr:\"+t,{lengthComputable:e.lengthComputable,loaded:e.loaded,total:e.total})})})});lt(n,\"htmx:beforeSend\",I);m.send(e===\"get\"?null:Dt(m,n,C));return s}function Gt(a,s){var u=s.xhr;var l=s.target;if(!lt(a,\"htmx:beforeOnLoad\",s))return;if(Wt(u,/HX-Trigger:/i)){he(u,\"HX-Trigger\",a)}if(Wt(u,/HX-Push:/i)){var f=u.getResponseHeader(\"HX-Push\")}if(Wt(u,/HX-Redirect:/i)){window.location.href=u.getResponseHeader(\"HX-Redirect\");return}if(Wt(u,/HX-Refresh:/i)){if(\"true\"===u.getResponseHeader(\"HX-Refresh\")){location.reload();return}}var c=bt(a)||f;var e=u.status>=200&&u.status<400&&u.status!==204;var h=u.response;var t=V({shouldSwap:e,serverResponse:h},s);if(!lt(l,\"htmx:beforeSwap\",t))return;l=t.target;h=t.serverResponse;if(t.shouldSwap){if(u.status===286){Re(a)}st(a,function(e){h=e.transformResponse(h,u,a)});if(c){gt()}var d=Mt(a);l.classList.add(D.config.swappingClass);var r=function(){try{var e=document.activeElement;var t={};try{t={elt:e,start:e?e.selectionStart:null,end:e?e.selectionEnd:null}}catch(e){}var r=Ft(l);ce(d.swapStyle,l,a,h,r);if(t.elt&&!z(t.elt)&&t.elt.id){var n=document.getElementById(t.elt.id);if(n){if(t.start&&n.setSelectionRange){n.setSelectionRange(t.start,t.end)}n.focus()}}l.classList.remove(D.config.swappingClass);B(r.elts,function(e){if(e.classList){e.classList.add(D.config.settlingClass)}lt(e,\"htmx:afterSwap\",s)});if(s.pathInfo.anchor){location.hash=s.pathInfo.anchor}if(Wt(u,/HX-Trigger-After-Swap:/i)){var i=a;if(!z(a)){i=P().body}he(u,\"HX-Trigger-After-Swap\",i)}var o=function(){B(r.tasks,function(e){e.call()});B(r.elts,function(e){if(e.classList){e.classList.remove(D.config.settlingClass)}lt(e,\"htmx:afterSettle\",s)});if(c){var e=f||wt(a)||_t(u)||s.pathInfo.finalPath||s.pathInfo.path;pt(e);lt(P().body,\"htmx:pushedIntoHistory\",{path:e})}Pt(r.elts,d);if(Wt(u,/HX-Trigger-After-Settle:/i)){var t=a;if(!z(a)){t=P().body}he(u,\"HX-Trigger-After-Settle\",t)}};if(d.settleDelay>0){setTimeout(o,d.settleDelay)}else{o()}}catch(e){ot(a,\"htmx:swapError\",s);throw e}};if(d.swapDelay>0){setTimeout(r,d.swapDelay)}else{r()}}else{ot(a,\"htmx:responseError\",V({error:\"Response Status Error Code \"+u.status+\" from \"+s.pathInfo.path},s))}}var Kt={};function Yt(){return{onEvent:function(e,t){return true},transformResponse:function(e,t,r){return e},isInlineSwap:function(e){return false},handleSwap:function(e,t,r,n){return false},encodeParameters:function(e,t,r){return null}}}function Qt(e,t){Kt[e]=V(Yt(),t)}function er(e){delete Kt[e]}function tr(e,r,n){if(e==undefined){return r}if(r==undefined){r=[]}if(n==undefined){n=[]}var t=F(e,\"hx-ext\");if(t){B(t.split(\",\"),function(e){e=e.replace(/ /g,\"\");if(e.slice(0,7)==\"ignore:\"){n.push(e.slice(7));return}if(n.indexOf(e)<0){var t=Kt[e];if(t&&r.indexOf(t)<0){r.push(t)}}})}return tr(l(e),r,n)}function rr(e){if(P().readyState!==\"loading\"){e()}else{P().addEventListener(\"DOMContentLoaded\",e)}}function nr(){if(D.config.includeIndicatorStyles!==false){P().head.insertAdjacentHTML(\"beforeend\",\"<style>                      .\"+D.config.indicatorClass+\"{opacity:0;transition: opacity 200ms ease-in;}                      .\"+D.config.requestClass+\" .\"+D.config.indicatorClass+\"{opacity:1}                      .\"+D.config.requestClass+\".\"+D.config.indicatorClass+\"{opacity:1}                    </style>\")}}function ir(){var e=P().querySelector('meta[name=\"htmx-config\"]');if(e){return x(e.content)}else{return null}}function or(){var e=ir();if(e){D.config=V(D.config,e)}}rr(function(){or();nr();var e=P().body;rt(e);window.onpopstate=function(e){if(e.state&&e.state.htmx){xt()}};setTimeout(function(){lt(e,\"htmx:load\",{})},0)});return D}()});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRteC5vcmcvZGlzdC9odG14Lm1pbi5qcz9jOGU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtHQUFlLEdBQUcsSUFBc0MsRUFBRSxpQ0FBTyxFQUFFLG9DQUFDLENBQUM7QUFBQTtBQUFBO0FBQUEsa0dBQUMsQ0FBQyxJQUFJLEVBQVksQ0FBQyxpREFBaUQsa0JBQWtCLGFBQWEsT0FBTyxrR0FBa0csc0JBQXNCLGdCQUFnQixnSUFBZ0ksOGhCQUE4aEIsbURBQW1ELDBCQUEwQixxQkFBcUIsRUFBRSw2QkFBNkIsMkJBQTJCLGtCQUFrQiw0Q0FBNEMsd0JBQXdCLG9DQUFvQyxhQUFhLGNBQWMsaUJBQWlCLGlCQUFpQixzQkFBc0IsNENBQTRDLHFCQUFxQixnREFBZ0QsZ0NBQWdDLGdCQUFnQix5Q0FBeUMsZ0JBQWdCLHNFQUFzRSxnQkFBZ0IsOEJBQThCLGNBQWMsdUJBQXVCLGFBQWEsZ0JBQWdCLGdCQUFnQixTQUFTLFNBQVMsY0FBYyxpQkFBaUIsS0FBSyxhQUFhLGdCQUFnQixXQUFXLGdCQUFnQixnQkFBZ0IsRUFBRSxnQkFBZ0IsVUFBVSxnQkFBZ0IsMkhBQTJILHNCQUFzQixjQUFjLHVDQUF1QyxnQkFBZ0IsTUFBTSwwQkFBMEIsS0FBSyxVQUFVLGdCQUFnQixvQkFBb0IsdUNBQXVDLGFBQWEsV0FBVyxJQUFJLGVBQWUsWUFBWSwrQkFBK0IsU0FBUyxjQUFjLGtDQUFrQyxxREFBcUQsMkNBQTJDLEtBQUssV0FBVyxVQUFVLG9HQUFvRyxrRUFBa0UsMkRBQTJELDZFQUE2RSw0Q0FBNEMsd0JBQXdCLGNBQWMsTUFBTSxLQUFLLGdCQUFnQiw0REFBNEQsY0FBYyx1QkFBdUIsY0FBYyxxQkFBcUIsY0FBYywyQkFBMkIsV0FBVyxPQUFPLFVBQVUsU0FBUyxjQUFjLFNBQVMsTUFBTSxZQUFZLFdBQVcsS0FBSyxjQUFjLFNBQVMsZ0JBQWdCLE1BQU0sWUFBWSxXQUFXLEtBQUssVUFBVSxjQUFjLGdD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QU8sRUFBRSxhQUFhLHNDQUFzQyxRQUFRLFVBQVUsV0FBVyxvQ0FBb0Msb0JBQW9CLDRCQUE0QixLQUFLLEtBQUssU0FBUyx5QkFBeUIsVUFBVSxrQkFBa0IsMEJBQTBCLEtBQUssS0FBSyxLQUFLLDZCQUE2QixzRUFBc0UsTUFBTSxVQUFVLGNBQWMsT0FBTyxzQkFBc0IsWUFBWSxtQ0FBbUMsU0FBUywwQkFBMEIsYUFBYSw4QkFBOEIsYUFBYSxrQ0FBa0MsY0FBYyxpQkFBaUIsZ0JBQWdCLGVBQWUsYUFBYSxtQkFBbUIsaUJBQWlCLFNBQVMsaUJBQWlCLEtBQUssaUJBQWlCLEtBQUssb0JBQW9CLE1BQU0sMkJBQTJCLHFCQUFxQiw0QkFBNEIsbUJBQW1CLE9BQU8sbUJBQW1CLFlBQVksc0JBQXNCLFlBQVksRUFBRSxvQkFBb0IsZUFBZSwrQkFBK0IsSUFBSSxLQUFLLDRDQUE0QyxjQUFjLDRDQUE0QyxtR0FBbUcsVUFBVSxtQ0FBbUMsOEVBQThFLFVBQVUsNkVBQTZFLFVBQVUsZ0NBQWdDLGNBQWMsb0RBQW9ELE1BQU0sb0JBQW9CLEtBQUssYUFBYSxjQUFjLFdBQVcsTUFBTSx3QkFBd0IsY0FBYyxLQUFLLEtBQUssZUFBZSxNQUFNLDhCQUE4QiwwQkFBMEIsT0FBTyxzQkFBc0IsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLFNBQVMsR0FBRyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9odG14Lm9yZy9kaXN0L2h0bXgubWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGUsdCl7aWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLHQpfWVsc2V7ZS5odG14PXQoKX19KSh0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIEQ9e29uTG9hZDp0LHByb2Nlc3M6cnQsb246TixvZmY6SSx0cmlnZ2VyOmx0LGFqYXg6JHQsZmluZDp3LGZpbmRBbGw6UyxjbG9zZXN0Ok8sdmFsdWVzOmZ1bmN0aW9uKGUsdCl7dmFyIHI9T3QoZSx0fHxcInBvc3RcIik7cmV0dXJuIHIudmFsdWVzfSxyZW1vdmU6RSxhZGRDbGFzczpDLHJlbW92ZUNsYXNzOlIsdG9nZ2xlQ2xhc3M6cSx0YWtlQ2xhc3M6TCxkZWZpbmVFeHRlbnNpb246UXQscmVtb3ZlRXh0ZW5zaW9uOmVyLGxvZ0FsbDpiLGxvZ2dlcjpudWxsLGNvbmZpZzp7aGlzdG9yeUVuYWJsZWQ6dHJ1ZSxoaXN0b3J5Q2FjaGVTaXplOjEwLHJlZnJlc2hPbkhpc3RvcnlNaXNzOmZhbHNlLGRlZmF1bHRTd2FwU3R5bGU6XCJpbm5lckhUTUxcIixkZWZhdWx0U3dhcERlbGF5OjAsZGVmYXVsdFNldHRsZURlbGF5OjIwLGluY2x1ZGVJbmRpY2F0b3JTdHlsZXM6dHJ1ZSxpbmRpY2F0b3JDbGFzczpcImh0bXgtaW5kaWNhdG9yXCIscmVxdWVzdENsYXNzOlwiaHRteC1yZXF1ZXN0XCIsYWRkZWRDbGFzczpcImh0bXgtYWRkZWRcIixzZXR0bGluZ0NsYXNzOlwiaHRteC1zZXR0bGluZ1wiLHN3YXBwaW5nQ2xhc3M6XCJodG14LXN3YXBwaW5nXCIsYWxsb3dFdmFsOnRydWUsYXR0cmlidXRlc1RvU2V0dGxlOltcImNsYXNzXCIsXCJzdHlsZVwiLFwid2lkdGhcIixcImhlaWdodFwiXSx3aXRoQ3JlZGVudGlhbHM6ZmFsc2UsdGltZW91dDowLHdzUmVjb25uZWN0RGVsYXk6XCJmdWxsLWppdHRlclwiLGRpc2FibGVTZWxlY3RvcjpcIltoeC1kaXNhYmxlXSwgW2RhdGEtaHgtZGlzYWJsZV1cIix1c2VUZW1wbGF0ZUZyYWdtZW50czpmYWxzZSxzY3JvbGxCZWhhdmlvcjpcInNtb290aFwifSxwYXJzZUludGVydmFsOmgsXzplLGNyZWF0ZUV2ZW50U291cmNlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRXZlbnRTb3VyY2UoZSx7d2l0aENyZWRlbnRpYWxzOnRydWV9KX0sY3JlYXRlV2ViU29ja2V0OmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgV2ViU29ja2V0KGUsW10pfSx2ZXJzaW9uOlwiMS42LjBcIn07dmFyIHI9W1wiZ2V0XCIsXCJwb3N0XCIsXCJwdXRcIixcImRlbGV0ZVwiLFwicGF0Y2hcIl07dmFyIG49ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJbaHgtXCIrZStcIl0sIFtkYXRhLWh4LVwiK2UrXCJdXCJ9KS5qb2luKFwiLCBcIik7ZnVuY3Rpb24gaChlKXtpZihlPT11bmRlZmluZWQpe3JldHVybiB1bmRlZmluZWR9aWYoZS5zbGljZSgtMik9PVwibXNcIil7cmV0dXJuIHBhcnNlRmxvYXQoZS5zbGljZSgwLC0yKSl8fHVuZGVmaW5lZH1pZihlLnNsaWNlKC0xKT09XCJzXCIpe3JldHVybiBwYXJzZUZsb2F0KGUuc2xpY2UoMCwtMSkpKjFlM3x8dW5kZWZpbmVkfXJldHVybiBwYXJzZUZsb2F0KGUpfHx1bmRlZmluZWR9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiBlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUodCl9ZnVuY3Rpb24gcyhlLHQpe3JldHVybiBlLmhhc0F0dHJpYnV0ZSYmKGUuaGFzQXR0cmlidXRlKHQpfHxlLmhhc0F0dHJpYnV0ZShcImRhdGEtXCIrdCkpfWZ1bmN0aW9uIEYoZSx0KXtyZXR1cm4gYyhlLHQpfHxjKGUsXCJkYXRhLVwiK3QpfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIGUucGFyZW50RWxlbWVudH1mdW5jdGlvbiBQKCl7cmV0dXJuIGRvY3VtZW50fWZ1bmN0aW9uIGQoZSx0KXtpZih0KGUpKXtyZXR1cm4gZX1lbHNlIGlmKGwoZSkpe3JldHVybiBkKGwoZSksdCl9ZWxzZXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gWChlLHQpe3ZhciByPW51bGw7ZChlLGZ1bmN0aW9uKGUpe3JldHVybiByPUYoZSx0KX0pO2lmKHIhPT1cInVuc2V0XCIpe3JldHVybiByfX1mdW5jdGlvbiB2KGUsdCl7dmFyIHI9ZS5tYXRjaGVzfHxlLm1hdGNoZXNTZWxlY3Rvcnx8ZS5tc01hdGNoZXNTZWxlY3Rvcnx8ZS5tb3pNYXRjaGVzU2VsZWN0b3J8fGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxlLm9NYXRjaGVzU2VsZWN0b3I7cmV0dXJuIHImJnIuY2FsbChlLHQpfWZ1bmN0aW9uIGkoZSl7dmFyIHQ9LzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pO3ZhciByPXQuZXhlYyhlKTtpZihyKXtyZXR1cm4gclsxXS50b0xvd2VyQ2FzZSgpfWVsc2V7cmV0dXJuXCJcIn19ZnVuY3Rpb24gbyhlLHQpe3ZhciByPW5ldyBET01QYXJzZXI7dmFyIG49ci5wYXJzZUZyb21TdHJpbmcoZSxcInRleHQvaHRtbFwiKTt2YXIgaT1uLmJvZHk7d2hpbGUodD4wKXt0LS07aT1pLmZpcnN0Q2hpbGR9aWYoaT09bnVsbCl7aT1QKCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpfXJldHVybiBpfWZ1bmN0aW9uIHUoZSl7aWYoRC5jb25maWcudXNlVGVtcGxhdGVGcmFnbWVudHMpe3ZhciB0PW8oXCI8Ym9keT48dGVtcGxhdGU+XCIrZStcIjwvdGVtcGxhdGU+PC9ib2R5PlwiLDApO3JldHVybiB0LnF1ZXJ5U2VsZWN0b3IoXCJ0ZW1wbGF0ZVwiKS5jb250ZW50fWVsc2V7dmFyIHI9aShlKTtzd2l0Y2gocil7Y2FzZVwidGhlYWRcIjpjYXNlXCJ0Ym9keVwiOmNhc2VcInRmb290XCI6Y2FzZVwiY29sZ3JvdXBcIjpjYXNlXCJjYXB0aW9uXCI6cmV0dXJuIG8oXCI8dGFibGU+XCIrZStcIjwvdGFibGU+XCIsMSk7Y2FzZVwiY29sXCI6cmV0dXJuIG8oXCI8dGFibGU+PGNvbGdyb3VwPlwiK2UrXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIsMik7Y2FzZVwidHJcIjpyZXR1cm4gbyhcIjx0YWJsZT48dGJvZHk+XCIrZStcIjwvdGJvZHk+PC90YWJsZT5cIiwyKTtjYXNlXCJ0ZFwiOmNhc2VcInRoXCI6cmV0dXJuIG8oXCI8dGFibGU+PHRib2R5Pjx0cj5cIitlK1wiPC90cj48L3Rib2R5PjwvdGFibGU+XCIsMyk7Y2FzZVwic2NyaXB0XCI6cmV0dXJuIG8oXCI8ZGl2PlwiK2UrXCI8L2Rpdj5cIiwxKTtkZWZhdWx0OnJldHVybiBvKGUsMCl9fX1mdW5jdGlvbiBVKGUpe2lmKGUpe2UoKX19ZnVuY3Rpb24gYShlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSk9PT1cIltvYmplY3QgXCIrdCtcIl1cIn1mdW5jdGlvbiBmKGUpe3JldHVybiBhKGUsXCJGdW5jdGlvblwiKX1mdW5jdGlvbiBnKGUpe3JldHVybiBhKGUsXCJPYmplY3RcIil9ZnVuY3Rpb24gaihlKXt2YXIgdD1cImh0bXgtaW50ZXJuYWwtZGF0YVwiO3ZhciByPWVbdF07aWYoIXIpe3I9ZVt0XT17fX1yZXR1cm4gcn1mdW5jdGlvbiBwKGUpe3ZhciB0PVtdO2lmKGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt0LnB1c2goZVtyXSl9fXJldHVybiB0fWZ1bmN0aW9uIEIoZSx0KXtpZihlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dChlW3JdKX19fWZ1bmN0aW9uIG0oZSl7dmFyIHQ9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt2YXIgcj10LnRvcDt2YXIgbj10LmJvdHRvbTtyZXR1cm4gcjx3aW5kb3cuaW5uZXJIZWlnaHQmJm4+PTB9ZnVuY3Rpb24geihlKXtyZXR1cm4gUCgpLmJvZHkuY29udGFpbnMoZSl9ZnVuY3Rpb24geShlKXtyZXR1cm4gZS50cmltKCkuc3BsaXQoL1xccysvKX1mdW5jdGlvbiBWKGUsdCl7Zm9yKHZhciByIGluIHQpe2lmKHQuaGFzT3duUHJvcGVydHkocikpe2Vbcl09dFtyXX19cmV0dXJuIGV9ZnVuY3Rpb24geChlKXt0cnl7cmV0dXJuIEpTT04ucGFyc2UoZSl9Y2F0Y2goZSl7dXQoZSk7cmV0dXJuIG51bGx9fWZ1bmN0aW9uIGUoZSl7cmV0dXJuIFV0KFAoKS5ib2R5LGZ1bmN0aW9uKCl7cmV0dXJuIGV2YWwoZSl9KX1mdW5jdGlvbiB0KHQpe3ZhciBlPUQub24oXCJodG14OmxvYWRcIixmdW5jdGlvbihlKXt0KGUuZGV0YWlsLmVsdCl9KTtyZXR1cm4gZX1mdW5jdGlvbiBiKCl7RC5sb2dnZXI9ZnVuY3Rpb24oZSx0LHIpe2lmKGNvbnNvbGUpe2NvbnNvbGUubG9nKHQsZSxyKX19fWZ1bmN0aW9uIHcoZSx0KXtpZih0KXtyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKHQpfWVsc2V7cmV0dXJuIHcoUCgpLGUpfX1mdW5jdGlvbiBTKGUsdCl7aWYodCl7cmV0dXJuIGUucXVlcnlTZWxlY3RvckFsbCh0KX1lbHNle3JldHVybiBTKFAoKSxlKX19ZnVuY3Rpb24gRShlLHQpe2U9SChlKTtpZih0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7RShlKX0sdCl9ZWxzZXtlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZSl9fWZ1bmN0aW9uIEMoZSx0LHIpe2U9SChlKTtpZihyKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7QyhlLHQpfSxyKX1lbHNle2UuY2xhc3NMaXN0JiZlLmNsYXNzTGlzdC5hZGQodCl9fWZ1bmN0aW9uIFIoZSx0LHIpe2U9SChlKTtpZihyKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7UihlLHQpfSxyKX1lbHNle2lmKGUuY2xhc3NMaXN0KXtlLmNsYXNzTGlzdC5yZW1vdmUodCk7aWYoZS5jbGFzc0xpc3QubGVuZ3RoPT09MCl7ZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKX19fX1mdW5jdGlvbiBxKGUsdCl7ZT1IKGUpO2UuY2xhc3NMaXN0LnRvZ2dsZSh0KX1mdW5jdGlvbiBMKGUsdCl7ZT1IKGUpO0IoZS5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLGZ1bmN0aW9uKGUpe1IoZSx0KX0pO0MoZSx0KX1mdW5jdGlvbiBPKGUsdCl7ZT1IKGUpO2lmKGUuY2xvc2VzdCl7cmV0dXJuIGUuY2xvc2VzdCh0KX1lbHNle2Rve2lmKGU9PW51bGx8fHYoZSx0KSl7cmV0dXJuIGV9fXdoaWxlKGU9ZSYmbChlKSl9fWZ1bmN0aW9uIFQoZSx0KXtpZih0LmluZGV4T2YoXCJjbG9zZXN0IFwiKT09PTApe3JldHVybltPKGUsdC5zdWJzdHIoOCkpXX1lbHNlIGlmKHQuaW5kZXhPZihcImZpbmQgXCIpPT09MCl7cmV0dXJuW3coZSx0LnN1YnN0cig1KSldfWVsc2UgaWYodD09PVwiZG9jdW1lbnRcIil7cmV0dXJuW2RvY3VtZW50XX1lbHNlIGlmKHQ9PT1cIndpbmRvd1wiKXtyZXR1cm5bd2luZG93XX1lbHNle3JldHVybiBQKCkucXVlcnlTZWxlY3RvckFsbCh0KX19ZnVuY3Rpb24gQShlLHQpe2lmKHQpe3JldHVybiBUKGUsdClbMF19ZWxzZXtyZXR1cm4gVChQKCkuYm9keSxlKVswXX19ZnVuY3Rpb24gSChlKXtpZihhKGUsXCJTdHJpbmdcIikpe3JldHVybiB3KGUpfWVsc2V7cmV0dXJuIGV9fWZ1bmN0aW9uIGsoZSx0LHIpe2lmKGYodCkpe3JldHVybnt0YXJnZXQ6UCgpLmJvZHksZXZlbnQ6ZSxsaXN0ZW5lcjp0fX1lbHNle3JldHVybnt0YXJnZXQ6SChlKSxldmVudDp0LGxpc3RlbmVyOnJ9fX1mdW5jdGlvbiBOKHQscixuKXtycihmdW5jdGlvbigpe3ZhciBlPWsodCxyLG4pO2UudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZS5ldmVudCxlLmxpc3RlbmVyKX0pO3ZhciBlPWYocik7cmV0dXJuIGU/cjpufWZ1bmN0aW9uIEkodCxyLG4pe3JyKGZ1bmN0aW9uKCl7dmFyIGU9ayh0LHIsbik7ZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLmV2ZW50LGUubGlzdGVuZXIpfSk7cmV0dXJuIGYocik/cjpufWZ1bmN0aW9uIF8oZSl7dmFyIHQ9ZChlLGZ1bmN0aW9uKGUpe3JldHVybiBGKGUsXCJoeC10YXJnZXRcIikhPT1udWxsfSk7aWYodCl7dmFyIHI9Rih0LFwiaHgtdGFyZ2V0XCIpO2lmKHI9PT1cInRoaXNcIil7cmV0dXJuIHR9ZWxzZXtyZXR1cm4gQShlLHIpfX1lbHNle3ZhciBuPWooZSk7aWYobi5ib29zdGVkKXtyZXR1cm4gUCgpLmJvZHl9ZWxzZXtyZXR1cm4gZX19fWZ1bmN0aW9uIE0oZSl7dmFyIHQ9RC5jb25maWcuYXR0cmlidXRlc1RvU2V0dGxlO2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXtpZihlPT09dFtyXSl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX1mdW5jdGlvbiBXKHQscil7Qih0LmF0dHJpYnV0ZXMsZnVuY3Rpb24oZSl7aWYoIXIuaGFzQXR0cmlidXRlKGUubmFtZSkmJk0oZS5uYW1lKSl7dC5yZW1vdmVBdHRyaWJ1dGUoZS5uYW1lKX19KTtCKHIuYXR0cmlidXRlcyxmdW5jdGlvbihlKXtpZihNKGUubmFtZSkpe3Quc2V0QXR0cmlidXRlKGUubmFtZSxlLnZhbHVlKX19KX1mdW5jdGlvbiAkKGUsdCl7dmFyIHI9dHIodCk7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07dHJ5e2lmKGkuaXNJbmxpbmVTd2FwKGUpKXtyZXR1cm4gdHJ1ZX19Y2F0Y2goZSl7dXQoZSl9fXJldHVybiBlPT09XCJvdXRlckhUTUxcIn1mdW5jdGlvbiBKKGUsdCxyKXt2YXIgbj1cIiNcIit0LmlkO3ZhciBpPVwib3V0ZXJIVE1MXCI7aWYoZT09PVwidHJ1ZVwiKXt9ZWxzZSBpZihlLmluZGV4T2YoXCI6XCIpPjApe2k9ZS5zdWJzdHIoMCxlLmluZGV4T2YoXCI6XCIpKTtuPWUuc3Vic3RyKGUuaW5kZXhPZihcIjpcIikrMSxlLmxlbmd0aCl9ZWxzZXtpPWV9dmFyIG89UCgpLnF1ZXJ5U2VsZWN0b3Iobik7aWYobyl7dmFyIGE7YT1QKCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2EuYXBwZW5kQ2hpbGQodCk7aWYoISQoaSxvKSl7YT10fWxlKGksbyxvLGEscil9ZWxzZXt0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCk7b3QoUCgpLmJvZHksXCJodG14Om9vYkVycm9yTm9UYXJnZXRcIix7Y29udGVudDp0fSl9cmV0dXJuIGV9ZnVuY3Rpb24gWihlLHIpe0IoUyhlLFwiW2h4LXN3YXAtb29iXSwgW2RhdGEtaHgtc3dhcC1vb2JdXCIpLGZ1bmN0aW9uKGUpe3ZhciB0PUYoZSxcImh4LXN3YXAtb29iXCIpO2lmKHQhPW51bGwpe0oodCxlLHIpfX0pfWZ1bmN0aW9uIEcoZSl7QihTKGUsXCJbaHgtcHJlc2VydmVdLCBbZGF0YS1oeC1wcmVzZXJ2ZV1cIiksZnVuY3Rpb24oZSl7dmFyIHQ9RihlLFwiaWRcIik7dmFyIHI9UCgpLmdldEVsZW1lbnRCeUlkKHQpO2lmKHIhPW51bGwpe2UucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocixlKX19KX1mdW5jdGlvbiBLKG4sZSxpKXtCKGUucXVlcnlTZWxlY3RvckFsbChcIltpZF1cIiksZnVuY3Rpb24oZSl7aWYoZS5pZCYmZS5pZC5sZW5ndGg+MCl7dmFyIHQ9bi5xdWVyeVNlbGVjdG9yKGUudGFnTmFtZStcIltpZD0nXCIrZS5pZCtcIiddXCIpO2lmKHQmJnQhPT1uKXt2YXIgcj1lLmNsb25lTm9kZSgpO1coZSx0KTtpLnRhc2tzLnB1c2goZnVuY3Rpb24oKXtXKGUscil9KX19fSl9ZnVuY3Rpb24gWShlKXtyZXR1cm4gZnVuY3Rpb24oKXtSKGUsRC5jb25maWcuYWRkZWRDbGFzcyk7cnQoZSk7S2UoZSk7UShlKTtsdChlLFwiaHRteDpsb2FkXCIpfX1mdW5jdGlvbiBRKGUpe3ZhciB0PVwiW2F1dG9mb2N1c11cIjt2YXIgcj12KGUsdCk/ZTplLnF1ZXJ5U2VsZWN0b3IodCk7aWYociE9bnVsbCl7ci5mb2N1cygpfX1mdW5jdGlvbiBlZShlLHQscixuKXtLKGUscixuKTt3aGlsZShyLmNoaWxkTm9kZXMubGVuZ3RoPjApe3ZhciBpPXIuZmlyc3RDaGlsZDtDKGksRC5jb25maWcuYWRkZWRDbGFzcyk7ZS5pbnNlcnRCZWZvcmUoaSx0KTtpZihpLm5vZGVUeXBlIT09Tm9kZS5URVhUX05PREUmJmkubm9kZVR5cGUhPT1Ob2RlLkNPTU1FTlRfTk9ERSl7bi50YXNrcy5wdXNoKFkoaSkpfX19ZnVuY3Rpb24gdGUodCl7dmFyIGU9aih0KTtpZihlLndlYlNvY2tldCl7ZS53ZWJTb2NrZXQuY2xvc2UoKX1pZihlLnNzZUV2ZW50U291cmNlKXtlLnNzZUV2ZW50U291cmNlLmNsb3NlKCl9aWYoZS5saXN0ZW5lckluZm9zKXtCKGUubGlzdGVuZXJJbmZvcyxmdW5jdGlvbihlKXtpZih0IT09ZS5vbil7ZS5vbi5yZW1vdmVFdmVudExpc3RlbmVyKGUudHJpZ2dlcixlLmxpc3RlbmVyKX19KX1pZih0LmNoaWxkcmVuKXtCKHQuY2hpbGRyZW4sZnVuY3Rpb24oZSl7dGUoZSl9KX19ZnVuY3Rpb24gcmUoZSx0LHIpe2lmKGUudGFnTmFtZT09PVwiQk9EWVwiKXtyZXR1cm4gc2UoZSx0LHIpfWVsc2V7dmFyIG49ZS5wcmV2aW91c1NpYmxpbmc7ZWUobChlKSxlLHQscik7aWYobj09bnVsbCl7dmFyIGk9bChlKS5maXJzdENoaWxkfWVsc2V7dmFyIGk9bi5uZXh0U2libGluZ31qKGUpLnJlcGxhY2VkV2l0aD1pO3IuZWx0cz1bXTt3aGlsZShpJiZpIT09ZSl7aWYoaS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKXtyLmVsdHMucHVzaChpKX1pPWkubmV4dEVsZW1lbnRTaWJsaW5nfXRlKGUpO2woZSkucmVtb3ZlQ2hpbGQoZSl9fWZ1bmN0aW9uIG5lKGUsdCxyKXtyZXR1cm4gZWUoZSxlLmZpcnN0Q2hpbGQsdCxyKX1mdW5jdGlvbiBpZShlLHQscil7cmV0dXJuIGVlKGwoZSksZSx0LHIpfWZ1bmN0aW9uIG9lKGUsdCxyKXtyZXR1cm4gZWUoZSxudWxsLHQscil9ZnVuY3Rpb24gYWUoZSx0LHIpe3JldHVybiBlZShsKGUpLGUubmV4dFNpYmxpbmcsdCxyKX1mdW5jdGlvbiBzZShlLHQscil7dmFyIG49ZS5maXJzdENoaWxkO2VlKGUsbix0LHIpO2lmKG4pe3doaWxlKG4ubmV4dFNpYmxpbmcpe3RlKG4ubmV4dFNpYmxpbmcpO2UucmVtb3ZlQ2hpbGQobi5uZXh0U2libGluZyl9dGUobik7ZS5yZW1vdmVDaGlsZChuKX19ZnVuY3Rpb24gdWUoZSx0KXt2YXIgcj1YKGUsXCJoeC1zZWxlY3RcIik7aWYocil7dmFyIG49UCgpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtCKHQucXVlcnlTZWxlY3RvckFsbChyKSxmdW5jdGlvbihlKXtuLmFwcGVuZENoaWxkKGUpfSk7dD1ufXJldHVybiB0fWZ1bmN0aW9uIGxlKGUsdCxyLG4saSl7c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm47Y2FzZVwib3V0ZXJIVE1MXCI6cmUocixuLGkpO3JldHVybjtjYXNlXCJhZnRlcmJlZ2luXCI6bmUocixuLGkpO3JldHVybjtjYXNlXCJiZWZvcmViZWdpblwiOmllKHIsbixpKTtyZXR1cm47Y2FzZVwiYmVmb3JlZW5kXCI6b2UocixuLGkpO3JldHVybjtjYXNlXCJhZnRlcmVuZFwiOmFlKHIsbixpKTtyZXR1cm47ZGVmYXVsdDp2YXIgbz10cih0KTtmb3IodmFyIGE9MDthPG8ubGVuZ3RoO2ErKyl7dmFyIHM9b1thXTt0cnl7dmFyIHU9cy5oYW5kbGVTd2FwKGUscixuLGkpO2lmKHUpe2lmKHR5cGVvZiB1Lmxlbmd0aCE9PVwidW5kZWZpbmVkXCIpe2Zvcih2YXIgbD0wO2w8dS5sZW5ndGg7bCsrKXt2YXIgZj11W2xdO2lmKGYubm9kZVR5cGUhPT1Ob2RlLlRFWFRfTk9ERSYmZi5ub2RlVHlwZSE9PU5vZGUuQ09NTUVOVF9OT0RFKXtpLnRhc2tzLnB1c2goWShmKSl9fX1yZXR1cm59fWNhdGNoKGUpe3V0KGUpfX1zZShyLG4saSl9fWZ1bmN0aW9uIGZlKGUpe2lmKGUuaW5kZXhPZihcIjx0aXRsZVwiKT4tMSl7dmFyIHQ9ZS5yZXBsYWNlKC88c3ZnKFxcc1tePl0qPnw+KShbXFxzXFxTXSo/KTxcXC9zdmc+L2dpbSxcIlwiKTt2YXIgcj10Lm1hdGNoKC88dGl0bGUoXFxzW14+XSo+fD4pKFtcXHNcXFNdKj8pPFxcL3RpdGxlPi9pbSk7aWYocil7cmV0dXJuIHJbMl19fX1mdW5jdGlvbiBjZShlLHQscixuLGkpe3ZhciBvPWZlKG4pO2lmKG8pe3ZhciBhPXcoXCJ0aXRsZVwiKTtpZihhKXthLmlubmVySFRNTD1vfWVsc2V7d2luZG93LmRvY3VtZW50LnRpdGxlPW99fXZhciBzPXUobik7aWYocyl7WihzLGkpO3M9dWUocixzKTtHKHMpO3JldHVybiBsZShlLHIsdCxzLGkpfX1mdW5jdGlvbiBoZShlLHQscil7dmFyIG49ZS5nZXRSZXNwb25zZUhlYWRlcih0KTtpZihuLmluZGV4T2YoXCJ7XCIpPT09MCl7dmFyIGk9eChuKTtmb3IodmFyIG8gaW4gaSl7aWYoaS5oYXNPd25Qcm9wZXJ0eShvKSl7dmFyIGE9aVtvXTtpZighZyhhKSl7YT17dmFsdWU6YX19bHQocixvLGEpfX19ZWxzZXtsdChyLG4sW10pfX12YXIgZGU9L1xccy87dmFyIHZlPS9bXFxzLF0vO3ZhciBnZT0vW18kYS16QS1aXS87dmFyIHBlPS9bXyRhLXpBLVowLTldLzt2YXIgbWU9WydcIicsXCInXCIsXCIvXCJdO3ZhciB5ZT0vW15cXHNdLztmdW5jdGlvbiB4ZShlKXt2YXIgdD1bXTt2YXIgcj0wO3doaWxlKHI8ZS5sZW5ndGgpe2lmKGdlLmV4ZWMoZS5jaGFyQXQocikpKXt2YXIgbj1yO3doaWxlKHBlLmV4ZWMoZS5jaGFyQXQocisxKSkpe3IrK310LnB1c2goZS5zdWJzdHIobixyLW4rMSkpfWVsc2UgaWYobWUuaW5kZXhPZihlLmNoYXJBdChyKSkhPT0tMSl7dmFyIGk9ZS5jaGFyQXQocik7dmFyIG49cjtyKys7d2hpbGUocjxlLmxlbmd0aCYmZS5jaGFyQXQocikhPT1pKXtpZihlLmNoYXJBdChyKT09PVwiXFxcXFwiKXtyKyt9cisrfXQucHVzaChlLnN1YnN0cihuLHItbisxKSl9ZWxzZXt2YXIgbz1lLmNoYXJBdChyKTt0LnB1c2gobyl9cisrfXJldHVybiB0fWZ1bmN0aW9uIGJlKGUsdCxyKXtyZXR1cm4gZ2UuZXhlYyhlLmNoYXJBdCgwKSkmJmUhPT1cInRydWVcIiYmZSE9PVwiZmFsc2VcIiYmZSE9PVwidGhpc1wiJiZlIT09ciYmdCE9PVwiLlwifWZ1bmN0aW9uIHdlKGUsdCxyKXtpZih0WzBdPT09XCJbXCIpe3Quc2hpZnQoKTt2YXIgbj0xO3ZhciBpPVwiIHJldHVybiAoZnVuY3Rpb24oXCIrcitcIil7IHJldHVybiAoXCI7dmFyIG89bnVsbDt3aGlsZSh0Lmxlbmd0aD4wKXt2YXIgYT10WzBdO2lmKGE9PT1cIl1cIil7bi0tO2lmKG49PT0wKXtpZihvPT09bnVsbCl7aT1pK1widHJ1ZVwifXQuc2hpZnQoKTtpKz1cIil9KVwiO3RyeXt2YXIgcz1VdChlLGZ1bmN0aW9uKCl7cmV0dXJuIEZ1bmN0aW9uKGkpKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIHRydWV9KTtzLnNvdXJjZT1pO3JldHVybiBzfWNhdGNoKGUpe290KFAoKS5ib2R5LFwiaHRteDpzeW50YXg6ZXJyb3JcIix7ZXJyb3I6ZSxzb3VyY2U6aX0pO3JldHVybiBudWxsfX19ZWxzZSBpZihhPT09XCJbXCIpe24rK31pZihiZShhLG8scikpe2krPVwiKChcIityK1wiLlwiK2ErXCIpID8gKFwiK3IrXCIuXCIrYStcIikgOiAod2luZG93LlwiK2ErXCIpKVwifWVsc2V7aT1pK2F9bz10LnNoaWZ0KCl9fX1mdW5jdGlvbiBTZShlLHQpe3ZhciByPVwiXCI7d2hpbGUoZS5sZW5ndGg+MCYmIWVbMF0ubWF0Y2godCkpe3IrPWUuc2hpZnQoKX1yZXR1cm4gcn12YXIgRWU9XCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFwiO2Z1bmN0aW9uIENlKGUpe3ZhciB0PUYoZSxcImh4LXRyaWdnZXJcIik7dmFyIHI9W107aWYodCl7dmFyIG49eGUodCk7ZG97U2Uobix5ZSk7dmFyIGk9bi5sZW5ndGg7dmFyIG89U2UobiwvWyxcXFtcXHNdLyk7aWYobyE9PVwiXCIpe2lmKG89PT1cImV2ZXJ5XCIpe3ZhciBhPXt0cmlnZ2VyOlwiZXZlcnlcIn07U2Uobix5ZSk7YS5wb2xsSW50ZXJ2YWw9aChTZShuLC9bLFxcW1xcc10vKSk7U2Uobix5ZSk7dmFyIHM9d2UoZSxuLFwiZXZlbnRcIik7aWYocyl7YS5ldmVudEZpbHRlcj1zfXIucHVzaChhKX1lbHNlIGlmKG8uaW5kZXhPZihcInNzZTpcIik9PT0wKXtyLnB1c2goe3RyaWdnZXI6XCJzc2VcIixzc2VFdmVudDpvLnN1YnN0cig0KX0pfWVsc2V7dmFyIHU9e3RyaWdnZXI6b307dmFyIHM9d2UoZSxuLFwiZXZlbnRcIik7aWYocyl7dS5ldmVudEZpbHRlcj1zfXdoaWxlKG4ubGVuZ3RoPjAmJm5bMF0hPT1cIixcIil7U2Uobix5ZSk7dmFyIGw9bi5zaGlmdCgpO2lmKGw9PT1cImNoYW5nZWRcIil7dS5jaGFuZ2VkPXRydWV9ZWxzZSBpZihsPT09XCJvbmNlXCIpe3Uub25jZT10cnVlfWVsc2UgaWYobD09PVwiY29uc3VtZVwiKXt1LmNvbnN1bWU9dHJ1ZX1lbHNlIGlmKGw9PT1cImRlbGF5XCImJm5bMF09PT1cIjpcIil7bi5zaGlmdCgpO3UuZGVsYXk9aChTZShuLHZlKSl9ZWxzZSBpZihsPT09XCJmcm9tXCImJm5bMF09PT1cIjpcIil7bi5zaGlmdCgpO3UuZnJvbT1TZShuLHZlKX1lbHNlIGlmKGw9PT1cInRhcmdldFwiJiZuWzBdPT09XCI6XCIpe24uc2hpZnQoKTt1LnRhcmdldD1TZShuLHZlKX1lbHNlIGlmKGw9PT1cInRocm90dGxlXCImJm5bMF09PT1cIjpcIil7bi5zaGlmdCgpO3UudGhyb3R0bGU9aChTZShuLHZlKSl9ZWxzZSBpZihsPT09XCJxdWV1ZVwiJiZuWzBdPT09XCI6XCIpe24uc2hpZnQoKTt1LnF1ZXVlPVNlKG4sdmUpfWVsc2UgaWYoKGw9PT1cInJvb3RcInx8bD09PVwidGhyZXNob2xkXCIpJiZuWzBdPT09XCI6XCIpe24uc2hpZnQoKTt1W2xdPVNlKG4sdmUpfWVsc2V7b3QoZSxcImh0bXg6c3ludGF4OmVycm9yXCIse3Rva2VuOm4uc2hpZnQoKX0pfX1yLnB1c2godSl9fWlmKG4ubGVuZ3RoPT09aSl7b3QoZSxcImh0bXg6c3ludGF4OmVycm9yXCIse3Rva2VuOm4uc2hpZnQoKX0pfVNlKG4seWUpfXdoaWxlKG5bMF09PT1cIixcIiYmbi5zaGlmdCgpKX1pZihyLmxlbmd0aD4wKXtyZXR1cm4gcn1lbHNlIGlmKHYoZSxcImZvcm1cIikpe3JldHVyblt7dHJpZ2dlcjpcInN1Ym1pdFwifV19ZWxzZSBpZih2KGUsRWUpKXtyZXR1cm5be3RyaWdnZXI6XCJjaGFuZ2VcIn1dfWVsc2V7cmV0dXJuW3t0cmlnZ2VyOlwiY2xpY2tcIn1dfX1mdW5jdGlvbiBSZShlKXtqKGUpLmNhbmNlbGxlZD10cnVlfWZ1bmN0aW9uIHFlKGUsdCxyLG4pe3ZhciBpPWooZSk7aS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZih6KGUpJiZpLmNhbmNlbGxlZCE9PXRydWUpe2lmKCFIZShuLGl0KFwiaHg6cG9sbDp0cmlnZ2VyXCIse3RyaWdnZXJTcGVjOm59KSkpe1p0KHQscixlKX1xZShlLHQsRihlLFwiaHgtXCIrdCksbil9fSxuLnBvbGxJbnRlcnZhbCl9ZnVuY3Rpb24gTGUoZSl7cmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lPT09ZS5ob3N0bmFtZSYmYyhlLFwiaHJlZlwiKSYmYyhlLFwiaHJlZlwiKS5pbmRleE9mKFwiI1wiKSE9PTB9ZnVuY3Rpb24gT2UodCxyLGUpe2lmKHQudGFnTmFtZT09PVwiQVwiJiZMZSh0KXx8dC50YWdOYW1lPT09XCJGT1JNXCIpe3IuYm9vc3RlZD10cnVlO3ZhciBuLGk7aWYodC50YWdOYW1lPT09XCJBXCIpe249XCJnZXRcIjtpPWModCxcImhyZWZcIik7ci5wdXNoVVJMPXRydWV9ZWxzZXt2YXIgbz1jKHQsXCJtZXRob2RcIik7bj1vP28udG9Mb3dlckNhc2UoKTpcImdldFwiO2lmKG49PT1cImdldFwiKXtyLnB1c2hVUkw9dHJ1ZX1pPWModCxcImFjdGlvblwiKX1lLmZvckVhY2goZnVuY3Rpb24oZSl7a2UodCxuLGkscixlLHRydWUpfSl9fWZ1bmN0aW9uIFRlKGUpe3JldHVybiBlLnRhZ05hbWU9PT1cIkZPUk1cInx8dihlLCdpbnB1dFt0eXBlPVwic3VibWl0XCJdLCBidXR0b24nKSYmTyhlLFwiZm9ybVwiKSE9PW51bGx8fGUudGFnTmFtZT09PVwiQVwiJiZlLmhyZWYmJihlLmdldEF0dHJpYnV0ZShcImhyZWZcIik9PT1cIiNcInx8ZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLmluZGV4T2YoXCIjXCIpIT09MCl9ZnVuY3Rpb24gQWUoZSx0KXtyZXR1cm4gaihlKS5ib29zdGVkJiZlLnRhZ05hbWU9PT1cIkFcIiYmdC50eXBlPT09XCJjbGlja1wiJiYodC5jdHJsS2V5fHx0Lm1ldGFLZXkpfWZ1bmN0aW9uIEhlKGUsdCl7dmFyIHI9ZS5ldmVudEZpbHRlcjtpZihyKXt0cnl7cmV0dXJuIHIodCkhPT10cnVlfWNhdGNoKGUpe290KFAoKS5ib2R5LFwiaHRteDpldmVudEZpbHRlcjplcnJvclwiLHtlcnJvcjplLHNvdXJjZTpyLnNvdXJjZX0pO3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24ga2UobyxhLHMsZSx1LGwpe3ZhciB0O2lmKHUuZnJvbSl7dD1UKG8sdS5mcm9tKX1lbHNle3Q9W29dfUIodCxmdW5jdGlvbihuKXt2YXIgaT1mdW5jdGlvbihlKXtpZigheihvKSl7bi5yZW1vdmVFdmVudExpc3RlbmVyKHUudHJpZ2dlcixpKTtyZXR1cm59aWYoQWUobyxlKSl7cmV0dXJufWlmKGx8fFRlKG8pKXtlLnByZXZlbnREZWZhdWx0KCl9aWYoSGUodSxlKSl7cmV0dXJufXZhciB0PWooZSk7dC50cmlnZ2VyU3BlYz11O2lmKHQuaGFuZGxlZEZvcj09bnVsbCl7dC5oYW5kbGVkRm9yPVtdfXZhciByPWoobyk7aWYodC5oYW5kbGVkRm9yLmluZGV4T2Yobyk8MCl7dC5oYW5kbGVkRm9yLnB1c2gobyk7aWYodS5jb25zdW1lKXtlLnN0b3BQcm9wYWdhdGlvbigpfWlmKHUudGFyZ2V0JiZlLnRhcmdldCl7aWYoIXYoZS50YXJnZXQsdS50YXJnZXQpKXtyZXR1cm59fWlmKHUub25jZSl7aWYoci50cmlnZ2VyZWRPbmNlKXtyZXR1cm59ZWxzZXtyLnRyaWdnZXJlZE9uY2U9dHJ1ZX19aWYodS5jaGFuZ2VkKXtpZihyLmxhc3RWYWx1ZT09PW8udmFsdWUpe3JldHVybn1lbHNle3IubGFzdFZhbHVlPW8udmFsdWV9fWlmKHIuZGVsYXllZCl7Y2xlYXJUaW1lb3V0KHIuZGVsYXllZCl9aWYoci50aHJvdHRsZSl7cmV0dXJufWlmKHUudGhyb3R0bGUpe2lmKCFyLnRocm90dGxlKXtadChhLHMsbyxlKTtyLnRocm90dGxlPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtyLnRocm90dGxlPW51bGx9LHUudGhyb3R0bGUpfX1lbHNlIGlmKHUuZGVsYXkpe3IuZGVsYXllZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7WnQoYSxzLG8sZSl9LHUuZGVsYXkpfWVsc2V7WnQoYSxzLG8sZSl9fX07aWYoZS5saXN0ZW5lckluZm9zPT1udWxsKXtlLmxpc3RlbmVySW5mb3M9W119ZS5saXN0ZW5lckluZm9zLnB1c2goe3RyaWdnZXI6dS50cmlnZ2VyLGxpc3RlbmVyOmksb246bn0pO24uYWRkRXZlbnRMaXN0ZW5lcih1LnRyaWdnZXIsaSl9KX12YXIgTmU9ZmFsc2U7dmFyIEllPW51bGw7ZnVuY3Rpb24gTWUoKXtpZighSWUpe0llPWZ1bmN0aW9uKCl7TmU9dHJ1ZX07d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixJZSk7c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtpZihOZSl7TmU9ZmFsc2U7QihQKCkucXVlcnlTZWxlY3RvckFsbChcIltoeC10cmlnZ2VyPSdyZXZlYWxlZCddLFtkYXRhLWh4LXRyaWdnZXI9J3JldmVhbGVkJ11cIiksZnVuY3Rpb24oZSl7RGUoZSl9KX19LDIwMCl9fWZ1bmN0aW9uIERlKGUpe3ZhciB0PWooZSk7aWYoIXQucmV2ZWFsZWQmJm0oZSkpe3QucmV2ZWFsZWQ9dHJ1ZTtpZih0LmluaXRpYWxpemVkKXtadCh0LnZlcmIsdC5wYXRoLGUpfWVsc2V7ZS5hZGRFdmVudExpc3RlbmVyKFwiaHRteDphZnRlclByb2Nlc3NOb2RlXCIsZnVuY3Rpb24oKXtadCh0LnZlcmIsdC5wYXRoLGUpfSx7b25jZTp0cnVlfSl9fX1mdW5jdGlvbiBGZShlLHQscil7dmFyIG49eShyKTtmb3IodmFyIGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIG89bltpXS5zcGxpdCgvOiguKykvKTtpZihvWzBdPT09XCJjb25uZWN0XCIpe1BlKGUsb1sxXSwwKX1pZihvWzBdPT09XCJzZW5kXCIpe1VlKGUpfX19ZnVuY3Rpb24gUGUocyxyLG4pe2lmKCF6KHMpKXtyZXR1cm59aWYoci5pbmRleE9mKFwiL1wiKT09MCl7dmFyIGU9bG9jYXRpb24uaG9zdG5hbWUrKGxvY2F0aW9uLnBvcnQ/XCI6XCIrbG9jYXRpb24ucG9ydDpcIlwiKTtpZihsb2NhdGlvbi5wcm90b2NvbD09XCJodHRwczpcIil7cj1cIndzczovL1wiK2Urcn1lbHNlIGlmKGxvY2F0aW9uLnByb3RvY29sPT1cImh0dHA6XCIpe3I9XCJ3czovL1wiK2Urcn19dmFyIHQ9RC5jcmVhdGVXZWJTb2NrZXQocik7dC5vbmVycm9yPWZ1bmN0aW9uKGUpe290KHMsXCJodG14OndzRXJyb3JcIix7ZXJyb3I6ZSxzb2NrZXQ6dH0pO1hlKHMpfTt0Lm9uY2xvc2U9ZnVuY3Rpb24oZSl7aWYoWzEwMDYsMTAxMiwxMDEzXS5pbmRleE9mKGUuY29kZSk+PTApe3ZhciB0PWplKG4pO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtQZShzLHIsbisxKX0sdCl9fTt0Lm9ub3Blbj1mdW5jdGlvbihlKXtuPTB9O2oocykud2ViU29ja2V0PXQ7dC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGUpe2lmKFhlKHMpKXtyZXR1cm59dmFyIHQ9ZS5kYXRhO3N0KHMsZnVuY3Rpb24oZSl7dD1lLnRyYW5zZm9ybVJlc3BvbnNlKHQsbnVsbCxzKX0pO3ZhciByPUZ0KHMpO3ZhciBuPXUodCk7dmFyIGk9cChuLmNoaWxkcmVuKTtmb3IodmFyIG89MDtvPGkubGVuZ3RoO28rKyl7dmFyIGE9aVtvXTtKKEYoYSxcImh4LXN3YXAtb29iXCIpfHxcInRydWVcIixhLHIpfW10KHIudGFza3MpfSl9ZnVuY3Rpb24gWGUoZSl7aWYoIXooZSkpe2ooZSkud2ViU29ja2V0LmNsb3NlKCk7cmV0dXJuIHRydWV9fWZ1bmN0aW9uIFVlKGwpe3ZhciBmPWQobCxmdW5jdGlvbihlKXtyZXR1cm4gaihlKS53ZWJTb2NrZXQhPW51bGx9KTtpZihmKXtsLmFkZEV2ZW50TGlzdGVuZXIoQ2UobClbMF0udHJpZ2dlcixmdW5jdGlvbihlKXt2YXIgdD1qKGYpLndlYlNvY2tldDt2YXIgcj1rdChsLGYpO3ZhciBuPU90KGwsXCJwb3N0XCIpO3ZhciBpPW4uZXJyb3JzO3ZhciBvPW4udmFsdWVzO3ZhciBhPXp0KGwpO3ZhciBzPVYobyxhKTt2YXIgdT1OdChzLGwpO3VbXCJIRUFERVJTXCJdPXI7aWYoaSYmaS5sZW5ndGg+MCl7bHQobCxcImh0bXg6dmFsaWRhdGlvbjpoYWx0ZWRcIixpKTtyZXR1cm59dC5zZW5kKEpTT04uc3RyaW5naWZ5KHUpKTtpZihUZShsKSl7ZS5wcmV2ZW50RGVmYXVsdCgpfX0pfWVsc2V7b3QobCxcImh0bXg6bm9XZWJTb2NrZXRTb3VyY2VFcnJvclwiKX19ZnVuY3Rpb24gamUoZSl7dmFyIHQ9RC5jb25maWcud3NSZWNvbm5lY3REZWxheTtpZih0eXBlb2YgdD09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHQoZSl9aWYodD09PVwiZnVsbC1qaXR0ZXJcIil7dmFyIHI9TWF0aC5taW4oZSw2KTt2YXIgbj0xZTMqTWF0aC5wb3coMixyKTtyZXR1cm4gbipNYXRoLnJhbmRvbSgpfXV0KCdodG14LmNvbmZpZy53c1JlY29ubmVjdERlbGF5IG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgdGhlIHN0cmluZyBcImZ1bGwtaml0dGVyXCInKX1mdW5jdGlvbiBCZShlLHQscil7dmFyIG49eShyKTtmb3IodmFyIGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIG89bltpXS5zcGxpdCgvOiguKykvKTtpZihvWzBdPT09XCJjb25uZWN0XCIpe3plKGUsb1sxXSl9aWYob1swXT09PVwic3dhcFwiKXtWZShlLG9bMV0pfX19ZnVuY3Rpb24gemUodCxlKXt2YXIgcj1ELmNyZWF0ZUV2ZW50U291cmNlKGUpO3Iub25lcnJvcj1mdW5jdGlvbihlKXtvdCh0LFwiaHRteDpzc2VFcnJvclwiLHtlcnJvcjplLHNvdXJjZTpyfSk7V2UodCl9O2oodCkuc3NlRXZlbnRTb3VyY2U9cn1mdW5jdGlvbiBWZShvLGEpe3ZhciBzPWQobywkZSk7aWYocyl7dmFyIHU9aihzKS5zc2VFdmVudFNvdXJjZTt2YXIgbD1mdW5jdGlvbihlKXtpZihXZShzKSl7dS5yZW1vdmVFdmVudExpc3RlbmVyKGEsbCk7cmV0dXJufXZhciB0PWUuZGF0YTtzdChvLGZ1bmN0aW9uKGUpe3Q9ZS50cmFuc2Zvcm1SZXNwb25zZSh0LG51bGwsbyl9KTt2YXIgcj1NdChvKTt2YXIgbj1fKG8pO3ZhciBpPUZ0KG8pO2NlKHIuc3dhcFN0eWxlLG8sbix0LGkpO210KGkudGFza3MpO2x0KG8sXCJodG14OnNzZU1lc3NhZ2VcIixlKX07aihvKS5zc2VMaXN0ZW5lcj1sO3UuYWRkRXZlbnRMaXN0ZW5lcihhLGwpfWVsc2V7b3QobyxcImh0bXg6bm9TU0VTb3VyY2VFcnJvclwiKX19ZnVuY3Rpb24gX2UoZSx0LHIsbil7dmFyIGk9ZChlLCRlKTtpZihpKXt2YXIgbz1qKGkpLnNzZUV2ZW50U291cmNlO3ZhciBhPWZ1bmN0aW9uKCl7aWYoIVdlKGkpKXtpZih6KGUpKXtadCh0LHIsZSl9ZWxzZXtvLnJlbW92ZUV2ZW50TGlzdGVuZXIobixhKX19fTtqKGUpLnNzZUxpc3RlbmVyPWE7by5hZGRFdmVudExpc3RlbmVyKG4sYSl9ZWxzZXtvdChlLFwiaHRteDpub1NTRVNvdXJjZUVycm9yXCIpfX1mdW5jdGlvbiBXZShlKXtpZigheihlKSl7aihlKS5zc2VFdmVudFNvdXJjZS5jbG9zZSgpO3JldHVybiB0cnVlfX1mdW5jdGlvbiAkZShlKXtyZXR1cm4gaihlKS5zc2VFdmVudFNvdXJjZSE9bnVsbH1mdW5jdGlvbiBKZShlLHQscixuLGkpe3ZhciBvPWZ1bmN0aW9uKCl7aWYoIW4ubG9hZGVkKXtuLmxvYWRlZD10cnVlO1p0KHQscixlKX19O2lmKGkpe3NldFRpbWVvdXQobyxpKX1lbHNle28oKX19ZnVuY3Rpb24gWmUobyxhLGUpe3ZhciB0PWZhbHNlO0IocixmdW5jdGlvbihuKXtpZihzKG8sXCJoeC1cIituKSl7dmFyIGk9RihvLFwiaHgtXCIrbik7dD10cnVlO2EucGF0aD1pO2EudmVyYj1uO2UuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlLnNzZUV2ZW50KXtfZShvLG4saSxlLnNzZUV2ZW50KX1lbHNlIGlmKGUudHJpZ2dlcj09PVwicmV2ZWFsZWRcIil7TWUoKTtEZShvKX1lbHNlIGlmKGUudHJpZ2dlcj09PVwiaW50ZXJzZWN0XCIpe3ZhciB0PXt9O2lmKGUucm9vdCl7dC5yb290PUEobyxlLnJvb3QpfWlmKGUudGhyZXNob2xkKXt0LnRocmVzaG9sZD1wYXJzZUZsb2F0KGUudGhyZXNob2xkKX12YXIgcj1uZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07aWYoci5pc0ludGVyc2VjdGluZyl7bHQobyxcImludGVyc2VjdFwiKTticmVha319fSx0KTtyLm9ic2VydmUobyk7a2UobyxuLGksYSxlKX1lbHNlIGlmKGUudHJpZ2dlcj09PVwibG9hZFwiKXtKZShvLG4saSxhLGUuZGVsYXkpfWVsc2UgaWYoZS5wb2xsSW50ZXJ2YWwpe2EucG9sbGluZz10cnVlO3FlKG8sbixpLGUpfWVsc2V7a2UobyxuLGksYSxlKX19KX19KTtyZXR1cm4gdH1mdW5jdGlvbiBHZShlKXtpZihlLnR5cGU9PT1cInRleHQvamF2YXNjcmlwdFwifHxlLnR5cGU9PT1cIlwiKXt2YXIgdD1QKCkuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtCKGUuYXR0cmlidXRlcyxmdW5jdGlvbihlKXt0LnNldEF0dHJpYnV0ZShlLm5hbWUsZS52YWx1ZSl9KTt0LnRleHRDb250ZW50PWUudGV4dENvbnRlbnQ7dC5hc3luYz1mYWxzZTt2YXIgcj1lLnBhcmVudEVsZW1lbnQ7dHJ5e3IuaW5zZXJ0QmVmb3JlKHQsZSl9Y2F0Y2goZSl7dXQoZSl9ZmluYWxseXtyLnJlbW92ZUNoaWxkKGUpfX19ZnVuY3Rpb24gS2UoZSl7aWYodihlLFwic2NyaXB0XCIpKXtHZShlKX1CKFMoZSxcInNjcmlwdFwiKSxmdW5jdGlvbihlKXtHZShlKX0pfWZ1bmN0aW9uIFllKCl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbaHgtYm9vc3RdLCBbZGF0YS1oeC1ib29zdF1cIil9ZnVuY3Rpb24gUWUoZSl7aWYoZS5xdWVyeVNlbGVjdG9yQWxsKXt2YXIgdD1ZZSgpP1wiLCBhLCBmb3JtXCI6XCJcIjt2YXIgcj1lLnF1ZXJ5U2VsZWN0b3JBbGwobit0K1wiLCBbaHgtc3NlXSwgW2RhdGEtaHgtc3NlXSwgW2h4LXdzXSxcIitcIiBbZGF0YS1oeC13c11cIik7cmV0dXJuIHJ9ZWxzZXtyZXR1cm5bXX19ZnVuY3Rpb24gZXQocil7dmFyIGU9ZnVuY3Rpb24oZSl7aWYodihlLnRhcmdldCxcImJ1dHRvbiwgaW5wdXRbdHlwZT0nc3VibWl0J11cIikpe3ZhciB0PWoocik7dC5sYXN0QnV0dG9uQ2xpY2tlZD1lLnRhcmdldH19O3IuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZSk7ci5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLGUpO3IuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsZnVuY3Rpb24oZSl7dmFyIHQ9aihyKTt0Lmxhc3RCdXR0b25DbGlja2VkPW51bGx9KX1mdW5jdGlvbiB0dChlKXtpZihlLmNsb3Nlc3QmJmUuY2xvc2VzdChELmNvbmZpZy5kaXNhYmxlU2VsZWN0b3IpKXtyZXR1cm59dmFyIHQ9aihlKTtpZighdC5pbml0aWFsaXplZCl7dC5pbml0aWFsaXplZD10cnVlO2x0KGUsXCJodG14OmJlZm9yZVByb2Nlc3NOb2RlXCIpO2lmKGUudmFsdWUpe3QubGFzdFZhbHVlPWUudmFsdWV9dmFyIHI9Q2UoZSk7dmFyIG49WmUoZSx0LHIpO2lmKCFuJiZYKGUsXCJoeC1ib29zdFwiKT09PVwidHJ1ZVwiKXtPZShlLHQscil9aWYoZS50YWdOYW1lPT09XCJGT1JNXCIpe2V0KGUpfXZhciBpPUYoZSxcImh4LXNzZVwiKTtpZihpKXtCZShlLHQsaSl9dmFyIG89RihlLFwiaHgtd3NcIik7aWYobyl7RmUoZSx0LG8pfWx0KGUsXCJodG14OmFmdGVyUHJvY2Vzc05vZGVcIil9fWZ1bmN0aW9uIHJ0KGUpe2U9SChlKTt0dChlKTtCKFFlKGUpLGZ1bmN0aW9uKGUpe3R0KGUpfSl9ZnVuY3Rpb24gbnQoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZyxcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gaXQoZSx0KXt2YXIgcjtpZih3aW5kb3cuQ3VzdG9tRXZlbnQmJnR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQ9PT1cImZ1bmN0aW9uXCIpe3I9bmV3IEN1c3RvbUV2ZW50KGUse2J1YmJsZXM6dHJ1ZSxjYW5jZWxhYmxlOnRydWUsZGV0YWlsOnR9KX1lbHNle3I9UCgpLmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7ci5pbml0Q3VzdG9tRXZlbnQoZSx0cnVlLHRydWUsdCl9cmV0dXJuIHJ9ZnVuY3Rpb24gb3QoZSx0LHIpe2x0KGUsdCxWKHtlcnJvcjp0fSxyKSl9ZnVuY3Rpb24gYXQoZSl7cmV0dXJuIGU9PT1cImh0bXg6YWZ0ZXJQcm9jZXNzTm9kZVwifWZ1bmN0aW9uIHN0KGUsdCl7Qih0cihlKSxmdW5jdGlvbihlKXt0cnl7dChlKX1jYXRjaChlKXt1dChlKX19KX1mdW5jdGlvbiB1dChlKXtpZihjb25zb2xlLmVycm9yKXtjb25zb2xlLmVycm9yKGUpfWVsc2UgaWYoY29uc29sZS5sb2cpe2NvbnNvbGUubG9nKFwiRVJST1I6IFwiLGUpfX1mdW5jdGlvbiBsdChlLHQscil7ZT1IKGUpO2lmKHI9PW51bGwpe3I9e319cltcImVsdFwiXT1lO3ZhciBuPWl0KHQscik7aWYoRC5sb2dnZXImJiFhdCh0KSl7RC5sb2dnZXIoZSx0LHIpfWlmKHIuZXJyb3Ipe3V0KHIuZXJyb3IpO2x0KGUsXCJodG14OmVycm9yXCIse2Vycm9ySW5mbzpyfSl9dmFyIGk9ZS5kaXNwYXRjaEV2ZW50KG4pO3ZhciBvPW50KHQpO2lmKGkmJm8hPT10KXt2YXIgYT1pdChvLG4uZGV0YWlsKTtpPWkmJmUuZGlzcGF0Y2hFdmVudChhKX1zdChlLGZ1bmN0aW9uKGUpe2k9aSYmZS5vbkV2ZW50KHQsbikhPT1mYWxzZX0pO3JldHVybiBpfXZhciBmdD1udWxsO2Z1bmN0aW9uIGN0KCl7dmFyIGU9UCgpLnF1ZXJ5U2VsZWN0b3IoXCJbaHgtaGlzdG9yeS1lbHRdLFtkYXRhLWh4LWhpc3RvcnktZWx0XVwiKTtyZXR1cm4gZXx8UCgpLmJvZHl9ZnVuY3Rpb24gaHQoZSx0LHIsbil7dmFyIGk9eChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImh0bXgtaGlzdG9yeS1jYWNoZVwiKSl8fFtdO2Zvcih2YXIgbz0wO288aS5sZW5ndGg7bysrKXtpZihpW29dLnVybD09PWUpe2kuc3BsaWNlKG8sMSk7YnJlYWt9fWkucHVzaCh7dXJsOmUsY29udGVudDp0LHRpdGxlOnIsc2Nyb2xsOm59KTt3aGlsZShpLmxlbmd0aD5ELmNvbmZpZy5oaXN0b3J5Q2FjaGVTaXplKXtpLnNoaWZ0KCl9d2hpbGUoaS5sZW5ndGg+MCl7dHJ5e2xvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaHRteC1oaXN0b3J5LWNhY2hlXCIsSlNPTi5zdHJpbmdpZnkoaSkpO2JyZWFrfWNhdGNoKGUpe290KFAoKS5ib2R5LFwiaHRteDpoaXN0b3J5Q2FjaGVFcnJvclwiLHtjYXVzZTplLGNhY2hlOml9KTtpLnNoaWZ0KCl9fX1mdW5jdGlvbiBkdChlKXt2YXIgdD14KGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaHRteC1oaXN0b3J5LWNhY2hlXCIpKXx8W107Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe2lmKHRbcl0udXJsPT09ZSl7cmV0dXJuIHRbcl19fXJldHVybiBudWxsfWZ1bmN0aW9uIHZ0KGUpe3ZhciB0PUQuY29uZmlnLnJlcXVlc3RDbGFzczt2YXIgcj1lLmNsb25lTm9kZSh0cnVlKTtCKFMocixcIi5cIit0KSxmdW5jdGlvbihlKXtSKGUsdCl9KTtyZXR1cm4gci5pbm5lckhUTUx9ZnVuY3Rpb24gZ3QoKXt2YXIgZT1jdCgpO3ZhciB0PWZ0fHxsb2NhdGlvbi5wYXRobmFtZStsb2NhdGlvbi5zZWFyY2g7bHQoUCgpLmJvZHksXCJodG14OmJlZm9yZUhpc3RvcnlTYXZlXCIse3BhdGg6dCxoaXN0b3J5RWx0OmV9KTtpZihELmNvbmZpZy5oaXN0b3J5RW5hYmxlZCloaXN0b3J5LnJlcGxhY2VTdGF0ZSh7aHRteDp0cnVlfSxQKCkudGl0bGUsd2luZG93LmxvY2F0aW9uLmhyZWYpO2h0KHQsdnQoZSksUCgpLnRpdGxlLHdpbmRvdy5zY3JvbGxZKX1mdW5jdGlvbiBwdChlKXtpZihELmNvbmZpZy5oaXN0b3J5RW5hYmxlZCloaXN0b3J5LnB1c2hTdGF0ZSh7aHRteDp0cnVlfSxcIlwiLGUpO2Z0PWV9ZnVuY3Rpb24gbXQoZSl7QihlLGZ1bmN0aW9uKGUpe2UuY2FsbCgpfSl9ZnVuY3Rpb24geXQobil7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3ZhciBpPXtwYXRoOm4seGhyOmV9O2x0KFAoKS5ib2R5LFwiaHRteDpoaXN0b3J5Q2FjaGVNaXNzXCIsaSk7ZS5vcGVuKFwiR0VUXCIsbix0cnVlKTtlLnNldFJlcXVlc3RIZWFkZXIoXCJIWC1IaXN0b3J5LVJlc3RvcmUtUmVxdWVzdFwiLFwidHJ1ZVwiKTtlLm9ubG9hZD1mdW5jdGlvbigpe2lmKHRoaXMuc3RhdHVzPj0yMDAmJnRoaXMuc3RhdHVzPDQwMCl7bHQoUCgpLmJvZHksXCJodG14Omhpc3RvcnlDYWNoZU1pc3NMb2FkXCIsaSk7dmFyIGU9dSh0aGlzLnJlc3BvbnNlKTtlPWUucXVlcnlTZWxlY3RvcihcIltoeC1oaXN0b3J5LWVsdF0sW2RhdGEtaHgtaGlzdG9yeS1lbHRdXCIpfHxlO3ZhciB0PWN0KCk7dmFyIHI9RnQodCk7c2UodCxlLHIpO210KHIudGFza3MpO2Z0PW47bHQoUCgpLmJvZHksXCJodG14Omhpc3RvcnlSZXN0b3JlXCIse3BhdGg6bn0pfWVsc2V7b3QoUCgpLmJvZHksXCJodG14Omhpc3RvcnlDYWNoZU1pc3NMb2FkRXJyb3JcIixpKX19O2Uuc2VuZCgpfWZ1bmN0aW9uIHh0KGUpe2d0KCk7ZT1lfHxsb2NhdGlvbi5wYXRobmFtZStsb2NhdGlvbi5zZWFyY2g7dmFyIHQ9ZHQoZSk7aWYodCl7dmFyIHI9dSh0LmNvbnRlbnQpO3ZhciBuPWN0KCk7dmFyIGk9RnQobik7c2UobixyLGkpO210KGkudGFza3MpO2RvY3VtZW50LnRpdGxlPXQudGl0bGU7d2luZG93LnNjcm9sbFRvKDAsdC5zY3JvbGwpO2Z0PWU7bHQoUCgpLmJvZHksXCJodG14Omhpc3RvcnlSZXN0b3JlXCIse3BhdGg6ZX0pfWVsc2V7aWYoRC5jb25maWcucmVmcmVzaE9uSGlzdG9yeU1pc3Mpe3dpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSl9ZWxzZXt5dChlKX19fWZ1bmN0aW9uIGJ0KGUpe3ZhciB0PVgoZSxcImh4LXB1c2gtdXJsXCIpO3JldHVybiB0JiZ0IT09XCJmYWxzZVwifHxqKGUpLmJvb3N0ZWQmJmooZSkucHVzaFVSTH1mdW5jdGlvbiB3dChlKXt2YXIgdD1YKGUsXCJoeC1wdXNoLXVybFwiKTtyZXR1cm4gdD09PVwidHJ1ZVwifHx0PT09XCJmYWxzZVwiP251bGw6dH1mdW5jdGlvbiBTdChlKXt2YXIgdD1YKGUsXCJoeC1pbmRpY2F0b3JcIik7aWYodCl7dmFyIHI9VChlLHQpfWVsc2V7cj1bZV19QihyLGZ1bmN0aW9uKGUpe2UuY2xhc3NMaXN0W1wiYWRkXCJdLmNhbGwoZS5jbGFzc0xpc3QsRC5jb25maWcucmVxdWVzdENsYXNzKX0pO3JldHVybiByfWZ1bmN0aW9uIEV0KGUpe0IoZSxmdW5jdGlvbihlKXtlLmNsYXNzTGlzdFtcInJlbW92ZVwiXS5jYWxsKGUuY2xhc3NMaXN0LEQuY29uZmlnLnJlcXVlc3RDbGFzcyl9KX1mdW5jdGlvbiBDdChlLHQpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbj1lW3JdO2lmKG4uaXNTYW1lTm9kZSh0KSl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX1mdW5jdGlvbiBSdChlKXtpZihlLm5hbWU9PT1cIlwifHxlLm5hbWU9PW51bGx8fGUuZGlzYWJsZWQpe3JldHVybiBmYWxzZX1pZihlLnR5cGU9PT1cImJ1dHRvblwifHxlLnR5cGU9PT1cInN1Ym1pdFwifHxlLnRhZ05hbWU9PT1cImltYWdlXCJ8fGUudGFnTmFtZT09PVwicmVzZXRcInx8ZS50YWdOYW1lPT09XCJmaWxlXCIpe3JldHVybiBmYWxzZX1pZihlLnR5cGU9PT1cImNoZWNrYm94XCJ8fGUudHlwZT09PVwicmFkaW9cIil7cmV0dXJuIGUuY2hlY2tlZH1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiBxdCh0LHIsbixlLGkpe2lmKGU9PW51bGx8fEN0KHQsZSkpe3JldHVybn1lbHNle3QucHVzaChlKX1pZihSdChlKSl7dmFyIG89YyhlLFwibmFtZVwiKTt2YXIgYT1lLnZhbHVlO2lmKGUubXVsdGlwbGUpe2E9cChlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJvcHRpb246Y2hlY2tlZFwiKSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnZhbHVlfSl9aWYoZS5maWxlcyl7YT1wKGUuZmlsZXMpfWlmKG8hPW51bGwmJmEhPW51bGwpe3ZhciBzPXJbb107aWYocyl7aWYoQXJyYXkuaXNBcnJheShzKSl7aWYoQXJyYXkuaXNBcnJheShhKSl7cltvXT1zLmNvbmNhdChhKX1lbHNle3MucHVzaChhKX19ZWxzZXtpZihBcnJheS5pc0FycmF5KGEpKXtyW29dPVtzXS5jb25jYXQoYSl9ZWxzZXtyW29dPVtzLGFdfX19ZWxzZXtyW29dPWF9fWlmKGkpe0x0KGUsbil9fWlmKHYoZSxcImZvcm1cIikpe3ZhciB1PWUuZWxlbWVudHM7Qih1LGZ1bmN0aW9uKGUpe3F0KHQscixuLGUsaSl9KX19ZnVuY3Rpb24gTHQoZSx0KXtpZihlLndpbGxWYWxpZGF0ZSl7bHQoZSxcImh0bXg6dmFsaWRhdGlvbjp2YWxpZGF0ZVwiKTtpZighZS5jaGVja1ZhbGlkaXR5KCkpe3QucHVzaCh7ZWx0OmUsbWVzc2FnZTplLnZhbGlkYXRpb25NZXNzYWdlLHZhbGlkaXR5OmUudmFsaWRpdHl9KTtsdChlLFwiaHRteDp2YWxpZGF0aW9uOmZhaWxlZFwiLHttZXNzYWdlOmUudmFsaWRhdGlvbk1lc3NhZ2UsdmFsaWRpdHk6ZS52YWxpZGl0eX0pfX19ZnVuY3Rpb24gT3QoZSx0KXt2YXIgcj1bXTt2YXIgbj17fTt2YXIgaT17fTt2YXIgbz1bXTt2YXIgYT12KGUsXCJmb3JtXCIpJiZlLm5vVmFsaWRhdGUhPT10cnVlO2lmKHQhPT1cImdldFwiKXtxdChyLGksbyxPKGUsXCJmb3JtXCIpLGEpfXF0KHIsbixvLGUsYSk7dmFyIHM9aihlKTtpZihzLmxhc3RCdXR0b25DbGlja2VkKXt2YXIgdT1jKHMubGFzdEJ1dHRvbkNsaWNrZWQsXCJuYW1lXCIpO2lmKHUpe25bdV09cy5sYXN0QnV0dG9uQ2xpY2tlZC52YWx1ZX19dmFyIGw9WChlLFwiaHgtaW5jbHVkZVwiKTtpZihsKXt2YXIgZj1UKGUsbCk7QihmLGZ1bmN0aW9uKGUpe3F0KHIsbixvLGUsYSk7aWYoIXYoZSxcImZvcm1cIikpe0IoZS5xdWVyeVNlbGVjdG9yQWxsKEVlKSxmdW5jdGlvbihlKXtxdChyLG4sbyxlLGEpfSl9fSl9bj1WKG4saSk7cmV0dXJue2Vycm9yczpvLHZhbHVlczpufX1mdW5jdGlvbiBUdChlLHQscil7aWYoZSE9PVwiXCIpe2UrPVwiJlwifWUrPWVuY29kZVVSSUNvbXBvbmVudCh0KStcIj1cIitlbmNvZGVVUklDb21wb25lbnQocik7cmV0dXJuIGV9ZnVuY3Rpb24gQXQoZSl7dmFyIHQ9XCJcIjtmb3IodmFyIHIgaW4gZSl7aWYoZS5oYXNPd25Qcm9wZXJ0eShyKSl7dmFyIG49ZVtyXTtpZihBcnJheS5pc0FycmF5KG4pKXtCKG4sZnVuY3Rpb24oZSl7dD1UdCh0LHIsZSl9KX1lbHNle3Q9VHQodCxyLG4pfX19cmV0dXJuIHR9ZnVuY3Rpb24gSHQoZSl7dmFyIHQ9bmV3IEZvcm1EYXRhO2Zvcih2YXIgciBpbiBlKXtpZihlLmhhc093blByb3BlcnR5KHIpKXt2YXIgbj1lW3JdO2lmKEFycmF5LmlzQXJyYXkobikpe0IobixmdW5jdGlvbihlKXt0LmFwcGVuZChyLGUpfSl9ZWxzZXt0LmFwcGVuZChyLG4pfX19cmV0dXJuIHR9ZnVuY3Rpb24ga3QoZSx0LHIpe3ZhciBuPXtcIkhYLVJlcXVlc3RcIjpcInRydWVcIixcIkhYLVRyaWdnZXJcIjpjKGUsXCJpZFwiKSxcIkhYLVRyaWdnZXItTmFtZVwiOmMoZSxcIm5hbWVcIiksXCJIWC1UYXJnZXRcIjpGKHQsXCJpZFwiKSxcIkhYLUN1cnJlbnQtVVJMXCI6UCgpLmxvY2F0aW9uLmhyZWZ9O1h0KGUsXCJoeC1oZWFkZXJzXCIsZmFsc2Usbik7aWYociE9PXVuZGVmaW5lZCl7bltcIkhYLVByb21wdFwiXT1yfWlmKGooZSkuYm9vc3RlZCl7bltcIkhYLUJvb3N0ZWRcIl09XCJ0cnVlXCJ9cmV0dXJuIG59ZnVuY3Rpb24gTnQodCxlKXt2YXIgcj1YKGUsXCJoeC1wYXJhbXNcIik7aWYocil7aWYocj09PVwibm9uZVwiKXtyZXR1cm57fX1lbHNlIGlmKHI9PT1cIipcIil7cmV0dXJuIHR9ZWxzZSBpZihyLmluZGV4T2YoXCJub3QgXCIpPT09MCl7QihyLnN1YnN0cig0KS5zcGxpdChcIixcIiksZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtkZWxldGUgdFtlXX0pO3JldHVybiB0fWVsc2V7dmFyIG49e307QihyLnNwbGl0KFwiLFwiKSxmdW5jdGlvbihlKXtlPWUudHJpbSgpO25bZV09dFtlXX0pO3JldHVybiBufX1lbHNle3JldHVybiB0fX1mdW5jdGlvbiBJdChlKXtyZXR1cm4gYyhlLFwiaHJlZlwiKSYmYyhlLFwiaHJlZlwiKS5pbmRleE9mKFwiI1wiKT49MH1mdW5jdGlvbiBNdChlKXt2YXIgdD1YKGUsXCJoeC1zd2FwXCIpO3ZhciByPXtzd2FwU3R5bGU6aihlKS5ib29zdGVkP1wiaW5uZXJIVE1MXCI6RC5jb25maWcuZGVmYXVsdFN3YXBTdHlsZSxzd2FwRGVsYXk6RC5jb25maWcuZGVmYXVsdFN3YXBEZWxheSxzZXR0bGVEZWxheTpELmNvbmZpZy5kZWZhdWx0U2V0dGxlRGVsYXl9O2lmKGooZSkuYm9vc3RlZCYmIUl0KGUpKXtyW1wic2hvd1wiXT1cInRvcFwifWlmKHQpe3ZhciBuPXkodCk7aWYobi5sZW5ndGg+MCl7cltcInN3YXBTdHlsZVwiXT1uWzBdO2Zvcih2YXIgaT0xO2k8bi5sZW5ndGg7aSsrKXt2YXIgbz1uW2ldO2lmKG8uaW5kZXhPZihcInN3YXA6XCIpPT09MCl7cltcInN3YXBEZWxheVwiXT1oKG8uc3Vic3RyKDUpKX1pZihvLmluZGV4T2YoXCJzZXR0bGU6XCIpPT09MCl7cltcInNldHRsZURlbGF5XCJdPWgoby5zdWJzdHIoNykpfWlmKG8uaW5kZXhPZihcInNjcm9sbDpcIik9PT0wKXt2YXIgYT1vLnN1YnN0cig3KTt2YXIgcz1hLnNwbGl0KFwiOlwiKTt2YXIgdT1zLnBvcCgpO3ZhciBsPXMubGVuZ3RoPjA/cy5qb2luKFwiOlwiKTpudWxsO3JbXCJzY3JvbGxcIl09dTtyW1wic2Nyb2xsVGFyZ2V0XCJdPWx9aWYoby5pbmRleE9mKFwic2hvdzpcIik9PT0wKXt2YXIgZj1vLnN1YnN0cig1KTt2YXIgcz1mLnNwbGl0KFwiOlwiKTt2YXIgYz1zLnBvcCgpO3ZhciBsPXMubGVuZ3RoPjA/cy5qb2luKFwiOlwiKTpudWxsO3JbXCJzaG93XCJdPWM7cltcInNob3dUYXJnZXRcIl09bH19fX1yZXR1cm4gcn1mdW5jdGlvbiBEdCh0LHIsbil7dmFyIGk9bnVsbDtzdChyLGZ1bmN0aW9uKGUpe2lmKGk9PW51bGwpe2k9ZS5lbmNvZGVQYXJhbWV0ZXJzKHQsbixyKX19KTtpZihpIT1udWxsKXtyZXR1cm4gaX1lbHNle2lmKFgocixcImh4LWVuY29kaW5nXCIpPT09XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJ8fHYocixcImZvcm1cIikmJmMocixcImVuY3R5cGVcIik9PT1cIm11bHRpcGFydC9mb3JtLWRhdGFcIil7cmV0dXJuIEh0KG4pfWVsc2V7cmV0dXJuIEF0KG4pfX19ZnVuY3Rpb24gRnQoZSl7cmV0dXJue3Rhc2tzOltdLGVsdHM6W2VdfX1mdW5jdGlvbiBQdChlLHQpe3ZhciByPWVbMF07dmFyIG49ZVtlLmxlbmd0aC0xXTtpZih0LnNjcm9sbCl7dmFyIGk9bnVsbDtpZih0LnNjcm9sbFRhcmdldCl7aT1BKHIsdC5zY3JvbGxUYXJnZXQpfWlmKHQuc2Nyb2xsPT09XCJ0b3BcIiYmKHJ8fGkpKXtpPWl8fHI7aS5zY3JvbGxUb3A9MH1pZih0LnNjcm9sbD09PVwiYm90dG9tXCImJihufHxpKSl7aT1pfHxuO2kuc2Nyb2xsVG9wPWkuc2Nyb2xsSGVpZ2h0fX1pZih0LnNob3cpe3ZhciBpPW51bGw7aWYodC5zaG93VGFyZ2V0KXt2YXIgbz10LnNob3dUYXJnZXQ7aWYodC5zaG93VGFyZ2V0PT09XCJ3aW5kb3dcIil7bz1cImJvZHlcIn1pPUEocixvKX1pZih0LnNob3c9PT1cInRvcFwiJiYocnx8aSkpe2k9aXx8cjtpLnNjcm9sbEludG9WaWV3KHtibG9jazpcInN0YXJ0XCIsYmVoYXZpb3I6RC5jb25maWcuc2Nyb2xsQmVoYXZpb3J9KX1pZih0LnNob3c9PT1cImJvdHRvbVwiJiYobnx8aSkpe2k9aXx8bjtpLnNjcm9sbEludG9WaWV3KHtibG9jazpcImVuZFwiLGJlaGF2aW9yOkQuY29uZmlnLnNjcm9sbEJlaGF2aW9yfSl9fX1mdW5jdGlvbiBYdChlLHQscixuKXtpZihuPT1udWxsKXtuPXt9fWlmKGU9PW51bGwpe3JldHVybiBufXZhciBpPUYoZSx0KTtpZihpKXt2YXIgbz1pLnRyaW0oKTt2YXIgYT1yO2lmKG8uaW5kZXhPZihcImphdmFzY3JpcHQ6XCIpPT09MCl7bz1vLnN1YnN0cigxMSk7YT10cnVlfWVsc2UgaWYoby5pbmRleE9mKFwianM6XCIpPT09MCl7bz1vLnN1YnN0cigzKTthPXRydWV9aWYoby5pbmRleE9mKFwie1wiKSE9PTApe289XCJ7XCIrbytcIn1cIn12YXIgcztpZihhKXtzPVV0KGUsZnVuY3Rpb24oKXtyZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gKFwiK28rXCIpXCIpKCl9LHt9KX1lbHNle3M9eChvKX1mb3IodmFyIHUgaW4gcyl7aWYocy5oYXNPd25Qcm9wZXJ0eSh1KSl7aWYoblt1XT09bnVsbCl7blt1XT1zW3VdfX19fXJldHVybiBYdChsKGUpLHQscixuKX1mdW5jdGlvbiBVdChlLHQscil7aWYoRC5jb25maWcuYWxsb3dFdmFsKXtyZXR1cm4gdCgpfWVsc2V7b3QoZSxcImh0bXg6ZXZhbERpc2FsbG93ZWRFcnJvclwiKTtyZXR1cm4gcn19ZnVuY3Rpb24ganQoZSx0KXtyZXR1cm4gWHQoZSxcImh4LXZhcnNcIix0cnVlLHQpfWZ1bmN0aW9uIEJ0KGUsdCl7cmV0dXJuIFh0KGUsXCJoeC12YWxzXCIsZmFsc2UsdCl9ZnVuY3Rpb24genQoZSl7cmV0dXJuIFYoanQoZSksQnQoZSkpfWZ1bmN0aW9uIFZ0KHQscixuKXtpZihuIT09bnVsbCl7dHJ5e3Quc2V0UmVxdWVzdEhlYWRlcihyLG4pfWNhdGNoKGUpe3Quc2V0UmVxdWVzdEhlYWRlcihyLGVuY29kZVVSSUNvbXBvbmVudChuKSk7dC5zZXRSZXF1ZXN0SGVhZGVyKHIrXCItVVJJLUF1dG9FbmNvZGVkXCIsXCJ0cnVlXCIpfX19ZnVuY3Rpb24gX3QodCl7aWYodC5yZXNwb25zZVVSTCYmdHlwZW9mIFVSTCE9PVwidW5kZWZpbmVkXCIpe3RyeXt2YXIgZT1uZXcgVVJMKHQucmVzcG9uc2VVUkwpO3JldHVybiBlLnBhdGhuYW1lK2Uuc2VhcmNofWNhdGNoKGUpe290KFAoKS5ib2R5LFwiaHRteDpiYWRSZXNwb25zZVVybFwiLHt1cmw6dC5yZXNwb25zZVVSTH0pfX19ZnVuY3Rpb24gV3QoZSx0KXtyZXR1cm4gZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5tYXRjaCh0KX1mdW5jdGlvbiAkdChlLHQscil7ZT1lLnRvTG93ZXJDYXNlKCk7aWYocil7aWYociBpbnN0YW5jZW9mIEVsZW1lbnR8fGEocixcIlN0cmluZ1wiKSl7cmV0dXJuIFp0KGUsdCxudWxsLG51bGwse3RhcmdldE92ZXJyaWRlOkgocikscmV0dXJuUHJvbWlzZTp0cnVlfSl9ZWxzZXtyZXR1cm4gWnQoZSx0LEgoci5zb3VyY2UpLHIuZXZlbnQse2hhbmRsZXI6ci5oYW5kbGVyLGhlYWRlcnM6ci5oZWFkZXJzLHZhbHVlczpyLnZhbHVlcyx0YXJnZXRPdmVycmlkZTpIKHIudGFyZ2V0KSxyZXR1cm5Qcm9taXNlOnRydWV9KX19ZWxzZXtyZXR1cm4gWnQoZSx0LG51bGwsbnVsbCx7cmV0dXJuUHJvbWlzZTp0cnVlfSl9fWZ1bmN0aW9uIEp0KGUpe3ZhciB0PVtdO3doaWxlKGUpe3QucHVzaChlKTtlPWUucGFyZW50RWxlbWVudH1yZXR1cm4gdH1mdW5jdGlvbiBadChlLHQsbixyLGkpe3ZhciBvPW51bGw7dmFyIGE9bnVsbDtpPWkhPW51bGw/aTp7fTtpZihpLnJldHVyblByb21pc2UmJnR5cGVvZiBQcm9taXNlIT09XCJ1bmRlZmluZWRcIil7dmFyIHM9bmV3IFByb21pc2UoZnVuY3Rpb24oZSx0KXtvPWU7YT10fSl9aWYobj09bnVsbCl7bj1QKCkuYm9keX12YXIgdT1pLmhhbmRsZXJ8fEd0O2lmKCF6KG4pKXtyZXR1cm59dmFyIGw9aS50YXJnZXRPdmVycmlkZXx8XyhuKTtpZihsPT1udWxsKXtvdChuLFwiaHRteDp0YXJnZXRFcnJvclwiLHt0YXJnZXQ6RihuLFwiaHgtdGFyZ2V0XCIpfSk7cmV0dXJufXZhciBmPWoobik7aWYoZi5yZXF1ZXN0SW5GbGlnaHQpe3ZhciBjPVwibGFzdFwiO2lmKHIpe3ZhciBoPWoocik7aWYoaCYmaC50cmlnZ2VyU3BlYyYmaC50cmlnZ2VyU3BlYy5xdWV1ZSl7Yz1oLnRyaWdnZXJTcGVjLnF1ZXVlfX1pZihmLnF1ZXVlZFJlcXVlc3RzPT1udWxsKXtmLnF1ZXVlZFJlcXVlc3RzPVtdfWlmKGM9PT1cImZpcnN0XCImJmYucXVldWVkUmVxdWVzdHMubGVuZ3RoPT09MCl7Zi5xdWV1ZWRSZXF1ZXN0cy5wdXNoKGZ1bmN0aW9uKCl7WnQoZSx0LG4scixpKX0pfWVsc2UgaWYoYz09PVwiYWxsXCIpe2YucXVldWVkUmVxdWVzdHMucHVzaChmdW5jdGlvbigpe1p0KGUsdCxuLHIsaSl9KX1lbHNlIGlmKGM9PT1cImxhc3RcIil7Zi5xdWV1ZWRSZXF1ZXN0cz1bXTtmLnF1ZXVlZFJlcXVlc3RzLnB1c2goZnVuY3Rpb24oKXtadChlLHQsbixyLGkpfSl9cmV0dXJufWVsc2V7Zi5yZXF1ZXN0SW5GbGlnaHQ9dHJ1ZX12YXIgZD1mdW5jdGlvbigpe2YucmVxdWVzdEluRmxpZ2h0PWZhbHNlO2lmKGYucXVldWVkUmVxdWVzdHMhPW51bGwmJmYucXVldWVkUmVxdWVzdHMubGVuZ3RoPjApe3ZhciBlPWYucXVldWVkUmVxdWVzdHMuc2hpZnQoKTtlKCl9fTt2YXIgdj1YKG4sXCJoeC1wcm9tcHRcIik7aWYodil7dmFyIGc9cHJvbXB0KHYpO2lmKGc9PT1udWxsfHwhbHQobixcImh0bXg6cHJvbXB0XCIse3Byb21wdDpnLHRhcmdldDpsfSkpe1Uobyk7ZCgpO3JldHVybiBzfX12YXIgcD1YKG4sXCJoeC1jb25maXJtXCIpO2lmKHApe2lmKCFjb25maXJtKHApKXtVKG8pO2QoKTtyZXR1cm4gc319dmFyIG09bmV3IFhNTEh0dHBSZXF1ZXN0O3ZhciB5PWt0KG4sbCxnKTtpZihpLmhlYWRlcnMpe3k9Vih5LGkuaGVhZGVycyl9dmFyIHg9T3QobixlKTt2YXIgYj14LmVycm9yczt2YXIgdz14LnZhbHVlcztpZihpLnZhbHVlcyl7dz1WKHcsaS52YWx1ZXMpfXZhciBTPXp0KG4pO3ZhciBFPVYodyxTKTt2YXIgQz1OdChFLG4pO2lmKGUhPT1cImdldFwiJiZYKG4sXCJoeC1lbmNvZGluZ1wiKT09bnVsbCl7eVtcIkNvbnRlbnQtVHlwZVwiXT1cImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwifWlmKHQ9PW51bGx8fHQ9PT1cIlwiKXt0PVAoKS5sb2NhdGlvbi5ocmVmfXZhciBSPVh0KG4sXCJoeC1yZXF1ZXN0XCIpO3ZhciBxPXtwYXJhbWV0ZXJzOkMsdW5maWx0ZXJlZFBhcmFtZXRlcnM6RSxoZWFkZXJzOnksdGFyZ2V0OmwsdmVyYjplLGVycm9yczpiLHdpdGhDcmVkZW50aWFsczppLmNyZWRlbnRpYWxzfHxSLmNyZWRlbnRpYWxzfHxELmNvbmZpZy53aXRoQ3JlZGVudGlhbHMsdGltZW91dDppLnRpbWVvdXR8fFIudGltZW91dHx8RC5jb25maWcudGltZW91dCxwYXRoOnQsdHJpZ2dlcmluZ0V2ZW50OnJ9O2lmKCFsdChuLFwiaHRteDpjb25maWdSZXF1ZXN0XCIscSkpe1Uobyk7ZCgpO3JldHVybiBzfXQ9cS5wYXRoO2U9cS52ZXJiO3k9cS5oZWFkZXJzO0M9cS5wYXJhbWV0ZXJzO2I9cS5lcnJvcnM7aWYoYiYmYi5sZW5ndGg+MCl7bHQobixcImh0bXg6dmFsaWRhdGlvbjpoYWx0ZWRcIixxKTtVKG8pO2QoKTtyZXR1cm4gc312YXIgTD10LnNwbGl0KFwiI1wiKTt2YXIgTz1MWzBdO3ZhciBUPUxbMV07aWYoZT09PVwiZ2V0XCIpe3ZhciBBPU87dmFyIEg9T2JqZWN0LmtleXMoQykubGVuZ3RoIT09MDtpZihIKXtpZihBLmluZGV4T2YoXCI/XCIpPDApe0ErPVwiP1wifWVsc2V7QSs9XCImXCJ9QSs9QXQoQyk7aWYoVCl7QSs9XCIjXCIrVH19bS5vcGVuKFwiR0VUXCIsQSx0cnVlKX1lbHNle20ub3BlbihlLnRvVXBwZXJDYXNlKCksdCx0cnVlKX1tLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L2h0bWxcIik7bS53aXRoQ3JlZGVudGlhbHM9cS53aXRoQ3JlZGVudGlhbHM7bS50aW1lb3V0PXEudGltZW91dDtpZihSLm5vSGVhZGVycyl7fWVsc2V7Zm9yKHZhciBrIGluIHkpe2lmKHkuaGFzT3duUHJvcGVydHkoaykpe3ZhciBOPXlba107VnQobSxrLE4pfX19dmFyIEk9e3hocjptLHRhcmdldDpsLHJlcXVlc3RDb25maWc6cSxwYXRoSW5mbzp7cGF0aDp0LGZpbmFsUGF0aDpBLGFuY2hvcjpUfX07bS5vbmxvYWQ9ZnVuY3Rpb24oKXt0cnl7dmFyIGU9SnQobik7dShuLEkpO0V0KE0pO2x0KG4sXCJodG14OmFmdGVyUmVxdWVzdFwiLEkpO2x0KG4sXCJodG14OmFmdGVyT25Mb2FkXCIsSSk7aWYoIXoobikpe3ZhciB0PW51bGw7d2hpbGUoZS5sZW5ndGg+MCYmdD09bnVsbCl7dmFyIHI9ZS5zaGlmdCgpO2lmKHoocikpe3Q9cn19aWYodCl7bHQodCxcImh0bXg6YWZ0ZXJSZXF1ZXN0XCIsSSk7bHQodCxcImh0bXg6YWZ0ZXJPbkxvYWRcIixJKX19VShvKTtkKCl9Y2F0Y2goZSl7b3QobixcImh0bXg6b25Mb2FkRXJyb3JcIixWKHtlcnJvcjplfSxJKSk7dGhyb3cgZX19O20ub25lcnJvcj1mdW5jdGlvbigpe0V0KE0pO290KG4sXCJodG14OmFmdGVyUmVxdWVzdFwiLEkpO290KG4sXCJodG14OnNlbmRFcnJvclwiLEkpO1UoYSk7ZCgpfTttLm9uYWJvcnQ9ZnVuY3Rpb24oKXtFdChNKTtvdChuLFwiaHRteDphZnRlclJlcXVlc3RcIixJKTtvdChuLFwiaHRteDpzZW5kQWJvcnRcIixJKTtVKGEpO2QoKX07bS5vbnRpbWVvdXQ9ZnVuY3Rpb24oKXtFdChNKTtvdChuLFwiaHRteDphZnRlclJlcXVlc3RcIixJKTtvdChuLFwiaHRteDp0aW1lb3V0XCIsSSk7VShhKTtkKCl9O2lmKCFsdChuLFwiaHRteDpiZWZvcmVSZXF1ZXN0XCIsSSkpe1Uobyk7ZCgpO3JldHVybiBzfXZhciBNPVN0KG4pO0IoW1wibG9hZHN0YXJ0XCIsXCJsb2FkZW5kXCIsXCJwcm9ncmVzc1wiLFwiYWJvcnRcIl0sZnVuY3Rpb24odCl7QihbbSxtLnVwbG9hZF0sZnVuY3Rpb24oZSl7ZS5hZGRFdmVudExpc3RlbmVyKHQsZnVuY3Rpb24oZSl7bHQobixcImh0bXg6eGhyOlwiK3Qse2xlbmd0aENvbXB1dGFibGU6ZS5sZW5ndGhDb21wdXRhYmxlLGxvYWRlZDplLmxvYWRlZCx0b3RhbDplLnRvdGFsfSl9KX0pfSk7bHQobixcImh0bXg6YmVmb3JlU2VuZFwiLEkpO20uc2VuZChlPT09XCJnZXRcIj9udWxsOkR0KG0sbixDKSk7cmV0dXJuIHN9ZnVuY3Rpb24gR3QoYSxzKXt2YXIgdT1zLnhocjt2YXIgbD1zLnRhcmdldDtpZighbHQoYSxcImh0bXg6YmVmb3JlT25Mb2FkXCIscykpcmV0dXJuO2lmKFd0KHUsL0hYLVRyaWdnZXI6L2kpKXtoZSh1LFwiSFgtVHJpZ2dlclwiLGEpfWlmKFd0KHUsL0hYLVB1c2g6L2kpKXt2YXIgZj11LmdldFJlc3BvbnNlSGVhZGVyKFwiSFgtUHVzaFwiKX1pZihXdCh1LC9IWC1SZWRpcmVjdDovaSkpe3dpbmRvdy5sb2NhdGlvbi5ocmVmPXUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJIWC1SZWRpcmVjdFwiKTtyZXR1cm59aWYoV3QodSwvSFgtUmVmcmVzaDovaSkpe2lmKFwidHJ1ZVwiPT09dS5nZXRSZXNwb25zZUhlYWRlcihcIkhYLVJlZnJlc2hcIikpe2xvY2F0aW9uLnJlbG9hZCgpO3JldHVybn19dmFyIGM9YnQoYSl8fGY7dmFyIGU9dS5zdGF0dXM+PTIwMCYmdS5zdGF0dXM8NDAwJiZ1LnN0YXR1cyE9PTIwNDt2YXIgaD11LnJlc3BvbnNlO3ZhciB0PVYoe3Nob3VsZFN3YXA6ZSxzZXJ2ZXJSZXNwb25zZTpofSxzKTtpZighbHQobCxcImh0bXg6YmVmb3JlU3dhcFwiLHQpKXJldHVybjtsPXQudGFyZ2V0O2g9dC5zZXJ2ZXJSZXNwb25zZTtpZih0LnNob3VsZFN3YXApe2lmKHUuc3RhdHVzPT09Mjg2KXtSZShhKX1zdChhLGZ1bmN0aW9uKGUpe2g9ZS50cmFuc2Zvcm1SZXNwb25zZShoLHUsYSl9KTtpZihjKXtndCgpfXZhciBkPU10KGEpO2wuY2xhc3NMaXN0LmFkZChELmNvbmZpZy5zd2FwcGluZ0NsYXNzKTt2YXIgcj1mdW5jdGlvbigpe3RyeXt2YXIgZT1kb2N1bWVudC5hY3RpdmVFbGVtZW50O3ZhciB0PXt9O3RyeXt0PXtlbHQ6ZSxzdGFydDplP2Uuc2VsZWN0aW9uU3RhcnQ6bnVsbCxlbmQ6ZT9lLnNlbGVjdGlvbkVuZDpudWxsfX1jYXRjaChlKXt9dmFyIHI9RnQobCk7Y2UoZC5zd2FwU3R5bGUsbCxhLGgscik7aWYodC5lbHQmJiF6KHQuZWx0KSYmdC5lbHQuaWQpe3ZhciBuPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQuZWx0LmlkKTtpZihuKXtpZih0LnN0YXJ0JiZuLnNldFNlbGVjdGlvblJhbmdlKXtuLnNldFNlbGVjdGlvblJhbmdlKHQuc3RhcnQsdC5lbmQpfW4uZm9jdXMoKX19bC5jbGFzc0xpc3QucmVtb3ZlKEQuY29uZmlnLnN3YXBwaW5nQ2xhc3MpO0Ioci5lbHRzLGZ1bmN0aW9uKGUpe2lmKGUuY2xhc3NMaXN0KXtlLmNsYXNzTGlzdC5hZGQoRC5jb25maWcuc2V0dGxpbmdDbGFzcyl9bHQoZSxcImh0bXg6YWZ0ZXJTd2FwXCIscyl9KTtpZihzLnBhdGhJbmZvLmFuY2hvcil7bG9jYXRpb24uaGFzaD1zLnBhdGhJbmZvLmFuY2hvcn1pZihXdCh1LC9IWC1UcmlnZ2VyLUFmdGVyLVN3YXA6L2kpKXt2YXIgaT1hO2lmKCF6KGEpKXtpPVAoKS5ib2R5fWhlKHUsXCJIWC1UcmlnZ2VyLUFmdGVyLVN3YXBcIixpKX12YXIgbz1mdW5jdGlvbigpe0Ioci50YXNrcyxmdW5jdGlvbihlKXtlLmNhbGwoKX0pO0Ioci5lbHRzLGZ1bmN0aW9uKGUpe2lmKGUuY2xhc3NMaXN0KXtlLmNsYXNzTGlzdC5yZW1vdmUoRC5jb25maWcuc2V0dGxpbmdDbGFzcyl9bHQoZSxcImh0bXg6YWZ0ZXJTZXR0bGVcIixzKX0pO2lmKGMpe3ZhciBlPWZ8fHd0KGEpfHxfdCh1KXx8cy5wYXRoSW5mby5maW5hbFBhdGh8fHMucGF0aEluZm8ucGF0aDtwdChlKTtsdChQKCkuYm9keSxcImh0bXg6cHVzaGVkSW50b0hpc3RvcnlcIix7cGF0aDplfSl9UHQoci5lbHRzLGQpO2lmKFd0KHUsL0hYLVRyaWdnZXItQWZ0ZXItU2V0dGxlOi9pKSl7dmFyIHQ9YTtpZigheihhKSl7dD1QKCkuYm9keX1oZSh1LFwiSFgtVHJpZ2dlci1BZnRlci1TZXR0bGVcIix0KX19O2lmKGQuc2V0dGxlRGVsYXk+MCl7c2V0VGltZW91dChvLGQuc2V0dGxlRGVsYXkpfWVsc2V7bygpfX1jYXRjaChlKXtvdChhLFwiaHRteDpzd2FwRXJyb3JcIixzKTt0aHJvdyBlfX07aWYoZC5zd2FwRGVsYXk+MCl7c2V0VGltZW91dChyLGQuc3dhcERlbGF5KX1lbHNle3IoKX19ZWxzZXtvdChhLFwiaHRteDpyZXNwb25zZUVycm9yXCIsVih7ZXJyb3I6XCJSZXNwb25zZSBTdGF0dXMgRXJyb3IgQ29kZSBcIit1LnN0YXR1cytcIiBmcm9tIFwiK3MucGF0aEluZm8ucGF0aH0scykpfX12YXIgS3Q9e307ZnVuY3Rpb24gWXQoKXtyZXR1cm57b25FdmVudDpmdW5jdGlvbihlLHQpe3JldHVybiB0cnVlfSx0cmFuc2Zvcm1SZXNwb25zZTpmdW5jdGlvbihlLHQscil7cmV0dXJuIGV9LGlzSW5saW5lU3dhcDpmdW5jdGlvbihlKXtyZXR1cm4gZmFsc2V9LGhhbmRsZVN3YXA6ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIGZhbHNlfSxlbmNvZGVQYXJhbWV0ZXJzOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbnVsbH19fWZ1bmN0aW9uIFF0KGUsdCl7S3RbZV09VihZdCgpLHQpfWZ1bmN0aW9uIGVyKGUpe2RlbGV0ZSBLdFtlXX1mdW5jdGlvbiB0cihlLHIsbil7aWYoZT09dW5kZWZpbmVkKXtyZXR1cm4gcn1pZihyPT11bmRlZmluZWQpe3I9W119aWYobj09dW5kZWZpbmVkKXtuPVtdfXZhciB0PUYoZSxcImh4LWV4dFwiKTtpZih0KXtCKHQuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGUpe2U9ZS5yZXBsYWNlKC8gL2csXCJcIik7aWYoZS5zbGljZSgwLDcpPT1cImlnbm9yZTpcIil7bi5wdXNoKGUuc2xpY2UoNykpO3JldHVybn1pZihuLmluZGV4T2YoZSk8MCl7dmFyIHQ9S3RbZV07aWYodCYmci5pbmRleE9mKHQpPDApe3IucHVzaCh0KX19fSl9cmV0dXJuIHRyKGwoZSkscixuKX1mdW5jdGlvbiBycihlKXtpZihQKCkucmVhZHlTdGF0ZSE9PVwibG9hZGluZ1wiKXtlKCl9ZWxzZXtQKCkuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixlKX19ZnVuY3Rpb24gbnIoKXtpZihELmNvbmZpZy5pbmNsdWRlSW5kaWNhdG9yU3R5bGVzIT09ZmFsc2Upe1AoKS5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHN0eWxlPiAgICAgICAgICAgICAgICAgICAgICAuXCIrRC5jb25maWcuaW5kaWNhdG9yQ2xhc3MrXCJ7b3BhY2l0eTowO3RyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbjt9ICAgICAgICAgICAgICAgICAgICAgIC5cIitELmNvbmZpZy5yZXF1ZXN0Q2xhc3MrXCIgLlwiK0QuY29uZmlnLmluZGljYXRvckNsYXNzK1wie29wYWNpdHk6MX0gICAgICAgICAgICAgICAgICAgICAgLlwiK0QuY29uZmlnLnJlcXVlc3RDbGFzcytcIi5cIitELmNvbmZpZy5pbmRpY2F0b3JDbGFzcytcIntvcGFjaXR5OjF9ICAgICAgICAgICAgICAgICAgICA8L3N0eWxlPlwiKX19ZnVuY3Rpb24gaXIoKXt2YXIgZT1QKCkucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiaHRteC1jb25maWdcIl0nKTtpZihlKXtyZXR1cm4geChlLmNvbnRlbnQpfWVsc2V7cmV0dXJuIG51bGx9fWZ1bmN0aW9uIG9yKCl7dmFyIGU9aXIoKTtpZihlKXtELmNvbmZpZz1WKEQuY29uZmlnLGUpfX1ycihmdW5jdGlvbigpe29yKCk7bnIoKTt2YXIgZT1QKCkuYm9keTtydChlKTt3aW5kb3cub25wb3BzdGF0ZT1mdW5jdGlvbihlKXtpZihlLnN0YXRlJiZlLnN0YXRlLmh0bXgpe3h0KCl9fTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bHQoZSxcImh0bXg6bG9hZFwiLHt9KX0sMCl9KTtyZXR1cm4gRH0oKX0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/htmx.org/dist/htmx.min.js\n");

/***/ }),

/***/ "./assets/css/app.scss":
/*!*****************************!*\
  !*** ./assets/css/app.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5zY3NzPzAwNTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBIiwiZmlsZSI6Ii4vYXNzZXRzL2Nzcy9hcHAuc2Nzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/css/app.scss\n");

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popper);\n//# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcz9mMGJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix5REFBeUQ7O0FBRTlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQixnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsY0FBYztBQUM1QjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsT0FBTztBQUNyQixhQUFhLFdBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZCw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpREFBaUQsdUNBQXVDLGtEQUFrRDtBQUMxSSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQSx5REFBeUQscUJBQU07QUFDL0Q7QUFDQTs7QUFFQSxpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTYuMVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgdGltZW91dER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA/IHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZiAoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdGx5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/popper.js/dist/esm/popper.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					result = fn();
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) var result = runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./assets/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./assets/css/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;